{
  "problem_id": 16,
  "title": "Feature Scaling Implementation",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useMemo, useRef, useEffect } from 'react';\n\n// ============================================\n// Design Tokens\n// ============================================\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst featureColors = ['#f472b6', '#38bdf8'];\n\n// ============================================\n// Feature Scaling Calculations\n// ============================================\nfunction computeScaling(data) {\n  const rows = data.length;\n  const cols = data[0].length;\n  \n  // Per-column stats\n  const stats = [];\n  for (let j = 0; j < cols; j++) {\n    const col = data.map(row => row[j]);\n    const mean = col.reduce((a, b) => a + b, 0) / rows;\n    const variance = col.reduce((a, b) => a + (b - mean) ** 2, 0) / rows;\n    const std = Math.sqrt(variance);\n    const min = Math.min(...col);\n    const max = Math.max(...col);\n    stats.push({ mean, std, min, max });\n  }\n  \n  // Standardized\n  const standardized = data.map(row =>\n    row.map((val, j) => Math.round(((val - stats[j].mean) / stats[j].std) * 10000) / 10000)\n  );\n  \n  // Min-Max Normalized\n  const normalized = data.map(row =>\n    row.map((val, j) => {\n      const range = stats[j].max - stats[j].min;\n      return range === 0 ? 0 : Math.round(((val - stats[j].min) / range) * 10000) / 10000;\n    })\n  );\n  \n  return { stats, standardized, normalized };\n}\n\n// ============================================\n// Number Line Visualization\n// ============================================\nfunction NumberLineViz({ original, transformed, stats, featureIdx, method, step }) {\n  const canvasRef = useRef(null);\n  const width = 280;\n  const height = 100;\n  const padding = 30;\n  const color = featureColors[featureIdx];\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Determine scale based on method\n    let minVal, maxVal, tickLabels;\n    if (step === 1) {\n      // Original scale\n      minVal = stats.min - (stats.max - stats.min) * 0.2;\n      maxVal = stats.max + (stats.max - stats.min) * 0.2;\n      tickLabels = [stats.min, stats.mean, stats.max];\n    } else if (method === 'standardized') {\n      minVal = -2;\n      maxVal = 2;\n      tickLabels = [-2, -1, 0, 1, 2];\n    } else {\n      minVal = -0.2;\n      maxVal = 1.2;\n      tickLabels = [0, 0.5, 1];\n    }\n    \n    const scaleX = (v) => padding + ((v - minVal) / (maxVal - minVal)) * (width - 2 * padding);\n    \n    // Draw axis line\n    ctx.strokeStyle = theme.colors.textMuted;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(padding, height / 2);\n    ctx.lineTo(width - padding, height / 2);\n    ctx.stroke();\n    \n    // Draw ticks and labels\n    ctx.fillStyle = theme.colors.textMuted;\n    ctx.font = '9px JetBrains Mono';\n    ctx.textAlign = 'center';\n    tickLabels.forEach(val => {\n      const x = scaleX(val);\n      ctx.beginPath();\n      ctx.moveTo(x, height / 2 - 5);\n      ctx.lineTo(x, height / 2 + 5);\n      ctx.stroke();\n      ctx.fillText(typeof val === 'number' ? (Number.isInteger(val) ? val : val.toFixed(1)) : val, x, height / 2 + 18);\n    });\n    \n    // Draw reference lines for standardized (mean at 0)\n    if (step > 1 && method === 'standardized') {\n      ctx.strokeStyle = `${theme.colors.yellow}50`;\n      ctx.setLineDash([4, 4]);\n      ctx.beginPath();\n      ctx.moveTo(scaleX(0), height / 2 - 20);\n      ctx.lineTo(scaleX(0), height / 2 + 20);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      ctx.fillStyle = theme.colors.yellow;\n      ctx.fillText('mean=0', scaleX(0), height / 2 - 25);\n    }\n    \n    // Draw reference for min-max (0 and 1)\n    if (step > 1 && method === 'normalized') {\n      ctx.strokeStyle = `${theme.colors.green}50`;\n      ctx.setLineDash([4, 4]);\n      [0, 1].forEach(v => {\n        ctx.beginPath();\n        ctx.moveTo(scaleX(v), height / 2 - 20);\n        ctx.lineTo(scaleX(v), height / 2 + 20);\n        ctx.stroke();\n      });\n      ctx.setLineDash([]);\n      ctx.fillStyle = theme.colors.green;\n      ctx.fillText('min=0', scaleX(0), height / 2 - 25);\n      ctx.fillText('max=1', scaleX(1), height / 2 - 25);\n    }\n    \n    // Draw data points\n    const values = step === 1 ? original : transformed;\n    values.forEach((val, i) => {\n      const x = scaleX(val);\n      \n      // Draw point\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(x, height / 2, 8, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Label\n      ctx.fillStyle = theme.colors.text;\n      ctx.font = '10px JetBrains Mono';\n      ctx.fillText(val.toFixed(2), x, height / 2 - 15);\n    });\n    \n  }, [original, transformed, stats, step, method, color]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      style={{ borderRadius: '8px', display: 'block' }}\n    />\n  );\n}\n\n// ============================================\n// 2D Scatter Comparison\n// ============================================\nfunction ScatterComparison({ data, transformed, step, method }) {\n  const canvasRef = useRef(null);\n  const size = 180;\n  const padding = 25;\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n    \n    const values = step === 1 ? data : transformed;\n    \n    // Determine scale\n    let xMin, xMax, yMin, yMax;\n    if (step === 1) {\n      const allX = data.map(r => r[0]);\n      const allY = data.map(r => r[1]);\n      xMin = Math.min(...allX) - 1;\n      xMax = Math.max(...allX) + 1;\n      yMin = Math.min(...allY) - 1;\n      yMax = Math.max(...allY) + 1;\n    } else if (method === 'standardized') {\n      xMin = yMin = -2;\n      xMax = yMax = 2;\n    } else {\n      xMin = yMin = -0.2;\n      xMax = yMax = 1.2;\n    }\n    \n    const scaleX = (v) => padding + ((v - xMin) / (xMax - xMin)) * (size - 2 * padding);\n    const scaleY = (v) => size - padding - ((v - yMin) / (yMax - yMin)) * (size - 2 * padding);\n    \n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let i = 0; i <= 4; i++) {\n      const x = padding + (i / 4) * (size - 2 * padding);\n      const y = padding + (i / 4) * (size - 2 * padding);\n      ctx.beginPath();\n      ctx.moveTo(x, padding);\n      ctx.lineTo(x, size - padding);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(padding, y);\n      ctx.lineTo(size - padding, y);\n      ctx.stroke();\n    }\n    \n    // Axes\n    ctx.strokeStyle = theme.colors.textMuted;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(padding, size - padding);\n    ctx.lineTo(size - padding, size - padding);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(padding, padding);\n    ctx.lineTo(padding, size - padding);\n    ctx.stroke();\n    \n    // Points\n    values.forEach((row) => {\n      ctx.fillStyle = theme.colors.primary;\n      ctx.beginPath();\n      ctx.arc(scaleX(row[0]), scaleY(row[1]), 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = theme.colors.text;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    });\n    \n    // Axis labels\n    ctx.fillStyle = featureColors[0];\n    ctx.font = '10px JetBrains Mono';\n    ctx.textAlign = 'center';\n    ctx.fillText('Feature 1', size / 2, size - 5);\n    ctx.save();\n    ctx.translate(8, size / 2);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillStyle = featureColors[1];\n    ctx.fillText('Feature 2', 0, 0);\n    ctx.restore();\n    \n  }, [data, transformed, step, method]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      width={size}\n      height={size}\n      style={{ borderRadius: '8px', display: 'block' }}\n    />\n  );\n}\n\n// ============================================\n// Stats Display\n// ============================================\nfunction StatsCard({ stats, featureIdx }) {\n  const color = featureColors[featureIdx];\n  return (\n    <div style={{\n      padding: '10px',\n      background: theme.colors.surface,\n      borderRadius: '8px',\n      border: `1px solid ${color}40`,\n      fontSize: '10px',\n    }}>\n      <div style={{ color, fontWeight: '600', marginBottom: '6px' }}>Feature {featureIdx + 1}</div>\n      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', color: theme.colors.textSecondary }}>\n        <span>Mean:</span><span style={{ color: theme.colors.text }}>{stats.mean.toFixed(2)}</span>\n        <span>Std:</span><span style={{ color: theme.colors.text }}>{stats.std.toFixed(2)}</span>\n        <span>Min:</span><span style={{ color: theme.colors.text }}>{stats.min}</span>\n        <span>Max:</span><span style={{ color: theme.colors.text }}>{stats.max}</span>\n      </div>\n    </div>\n  );\n}\n\n// ============================================\n// Main App\n// ============================================\nexport default function FeatureScalingPlayground() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  \n  const examples = [\n    {\n      name: 'Different Scales',\n      data: [[1, 100], [3, 200], [5, 300]],\n      desc: 'Features on vastly different scales',\n    },\n    {\n      name: 'Similar Range',\n      data: [[1, 2], [3, 4], [5, 6]],\n      desc: 'Features with similar ranges',\n    },\n    {\n      name: 'With Outlier',\n      data: [[1, 10], [2, 20], [3, 30], [10, 25]],\n      desc: 'One outlier affects scaling',\n    },\n  ];\n  \n  const ex = examples[exampleIdx];\n  const result = useMemo(() => computeScaling(ex.data), [exampleIdx]);\n  \n  const totalSteps = 3;\n  \n  const reset = () => { setStep(0); setPlaying(false); };\n  const next = () => step < totalSteps && setStep(step + 1);\n  const prev = () => step > 0 && setStep(step - 1);\n  \n  const auto = async () => {\n    setPlaying(true);\n    for (let s = 0; s <= totalSteps; s++) {\n      setStep(s);\n      await new Promise(r => setTimeout(r, 1500));\n    }\n    setPlaying(false);\n  };\n\n  const stepInfo = [\n    { title: \"Why Scale Features?\", desc: \"When features have different ranges (like age 0-100 vs income 0-1M), some algorithms get confused. Scaling puts all features on equal footing.\", color: theme.colors.primary },\n    { title: \"Original Data\", desc: \"Look at the raw values. Notice how the features might be on completely different scales. This can cause problems for distance-based algorithms.\", color: theme.colors.text },\n    { title: \"Standardization (Z-Score)\", desc: \"Shift so mean becomes 0, scale so standard deviation becomes 1. Values tell you 'how many standard deviations from average'.\", color: theme.colors.yellow },\n    { title: \"Min-Max Normalization\", desc: \"Squeeze all values into [0, 1] range. Minimum becomes 0, maximum becomes 1. Good when you need bounded values.\", color: theme.colors.green },\n  ];\n\n  const currentMethod = step === 2 ? 'standardized' : step === 3 ? 'normalized' : null;\n  const currentData = step === 2 ? result.standardized : step === 3 ? result.normalized : ex.data;\n\n  return (\n    <div style={{\n      minHeight: '100vh',\n      background: theme.colors.background,\n      color: theme.colors.text,\n      fontFamily: theme.font,\n      padding: '16px',\n    }}>\n      <div style={{ maxWidth: '520px', margin: '0 auto' }}>\n        {/* Header */}\n        <div style={{ textAlign: 'center', marginBottom: '16px' }}>\n          <h1 style={{ fontSize: '18px', fontWeight: '700', margin: 0 }}>Feature Scaling</h1>\n          <p style={{ color: theme.colors.textSecondary, fontSize: '11px', marginTop: '4px' }}>\n            Put all features on the same playing field\n          </p>\n        </div>\n        \n        {/* Example Tabs */}\n        <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '16px' }}>\n          {examples.map((e, idx) => (\n            <button\n              key={idx}\n              onClick={() => { setExampleIdx(idx); reset(); }}\n              style={{\n                padding: '6px 12px',\n                background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n                border: 'none',\n                borderRadius: '6px',\n                color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n                fontFamily: theme.font,\n                fontSize: '11px',\n                cursor: 'pointer',\n              }}\n            >\n              {e.name}\n            </button>\n          ))}\n        </div>\n        \n        {/* Main Card */}\n        <div style={{ background: theme.colors.surfaceAlt, borderRadius: '12px', padding: '16px' }}>\n          \n          {/* Visualizations */}\n          <div style={{ display: 'flex', gap: '16px', marginBottom: '12px' }}>\n            {/* Number Lines */}\n            <div style={{ flex: 1 }}>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginBottom: '6px', textAlign: 'center' }}>\n                {step === 1 ? 'ORIGINAL VALUES' : step === 2 ? 'STANDARDIZED (mean=0, std=1)' : step === 3 ? 'NORMALIZED (0 to 1)' : 'FEATURE DISTRIBUTIONS'}\n              </div>\n              {[0, 1].map(featureIdx => (\n                <div key={featureIdx} style={{ marginBottom: '8px' }}>\n                  <div style={{ fontSize: '9px', color: featureColors[featureIdx], marginBottom: '2px' }}>\n                    Feature {featureIdx + 1}\n                  </div>\n                  <NumberLineViz\n                    original={ex.data.map(row => row[featureIdx])}\n                    transformed={currentData.map(row => row[featureIdx])}\n                    stats={result.stats[featureIdx]}\n                    featureIdx={featureIdx}\n                    method={currentMethod}\n                    step={step}\n                  />\n                </div>\n              ))}\n            </div>\n            \n            {/* 2D Scatter */}\n            <div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginBottom: '6px', textAlign: 'center' }}>\n                2D VIEW\n              </div>\n              <ScatterComparison\n                data={ex.data}\n                transformed={currentData}\n                step={step}\n                method={currentMethod}\n              />\n            </div>\n          </div>\n          \n          {/* Step Explanation */}\n          <div style={{\n            padding: '10px 12px',\n            background: theme.colors.surface,\n            borderRadius: '8px',\n            borderLeft: `3px solid ${stepInfo[step].color}`,\n            marginBottom: '12px',\n          }}>\n            <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text, marginBottom: '2px' }}>\n              {stepInfo[step].title}\n            </div>\n            <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.4 }}>\n              {stepInfo[step].desc}\n            </div>\n          </div>\n          \n          {/* Step Indicator */}\n          <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n            {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n              <div\n                key={i}\n                onClick={() => setStep(i)}\n                style={{\n                  width: i === step ? '20px' : '8px',\n                  height: '8px',\n                  borderRadius: '4px',\n                  background: i <= step ? theme.colors.primary : theme.colors.border,\n                  cursor: 'pointer',\n                  transition: 'all 0.3s',\n                }}\n              />\n            ))}\n          </div>\n          \n          {/* Controls */}\n          <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '16px' }}>\n            <button onClick={prev} disabled={step <= 0} style={{\n              padding: '10px 14px',\n              background: theme.colors.surface,\n              border: 'none',\n              borderRadius: '8px',\n              color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n              cursor: step <= 0 ? 'not-allowed' : 'pointer',\n              fontSize: '14px',\n            }}>\n              ←\n            </button>\n            \n            <button onClick={next} disabled={step >= totalSteps} style={{\n              flex: 1,\n              padding: '12px',\n              background: step < totalSteps ? theme.colors.primary : theme.colors.positive,\n              border: 'none',\n              borderRadius: '8px',\n              color: '#fff',\n              fontFamily: theme.font,\n              fontSize: '12px',\n              fontWeight: '600',\n              cursor: step < totalSteps ? 'pointer' : 'default',\n            }}>\n              {step === 0 ? 'Start' : step < totalSteps ? 'Next Method' : 'Complete'}\n            </button>\n            \n            <button onClick={auto} disabled={playing || step >= totalSteps} style={{\n              padding: '10px 14px',\n              background: theme.colors.surface,\n              border: 'none',\n              borderRadius: '8px',\n              color: playing || step >= totalSteps ? theme.colors.textMuted : theme.colors.text,\n              cursor: playing || step >= totalSteps ? 'not-allowed' : 'pointer',\n              fontSize: '12px',\n            }}>\n              ▶▶\n            </button>\n            \n            <button onClick={reset} style={{\n              padding: '10px 14px',\n              background: theme.colors.surface,\n              border: 'none',\n              borderRadius: '8px',\n              color: theme.colors.text,\n              cursor: 'pointer',\n              fontSize: '14px',\n            }}>\n              ↺\n            </button>\n          </div>\n          \n          {/* Stats and Data Below Controls */}\n          {step >= 1 && (\n            <div style={{ marginBottom: '12px' }}>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginBottom: '6px', textAlign: 'center' }}>\n                FEATURE STATISTICS\n              </div>\n              <div style={{ display: 'flex', gap: '12px' }}>\n                {result.stats.map((stat, i) => (\n                  <StatsCard key={i} stats={stat} featureIdx={i} />\n                ))}\n              </div>\n            </div>\n          )}\n          \n          {/* Transformation Details */}\n          {step >= 2 && (\n            <div style={{\n              padding: '12px',\n              background: step === 2 ? `${theme.colors.yellow}10` : `${theme.colors.green}10`,\n              borderRadius: '8px',\n              border: `1px solid ${step === 2 ? theme.colors.yellow : theme.colors.green}40`,\n            }}>\n              <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '8px', textAlign: 'center' }}>\n                {step === 2 ? 'STANDARDIZATION' : 'MIN-MAX NORMALIZATION'}\n              </div>\n              <div style={{ fontSize: '11px', color: theme.colors.textSecondary, textAlign: 'center', marginBottom: '8px' }}>\n                {step === 2 \n                  ? 'For each value: (value - mean) / std'\n                  : 'For each value: (value - min) / (max - min)'}\n              </div>\n              \n              {/* Show data table */}\n              <div style={{ display: 'flex', gap: '16px', justifyContent: 'center' }}>\n                <div>\n                  <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginBottom: '4px' }}>Original</div>\n                  {ex.data.map((row, i) => (\n                    <div key={i} style={{ fontSize: '10px', color: theme.colors.text }}>\n                      [{row.map(v => v.toString().padStart(3)).join(', ')}]\n                    </div>\n                  ))}\n                </div>\n                <div style={{ display: 'flex', alignItems: 'center', color: theme.colors.textMuted }}>→</div>\n                <div>\n                  <div style={{ fontSize: '9px', color: step === 2 ? theme.colors.yellow : theme.colors.green, marginBottom: '4px' }}>\n                    {step === 2 ? 'Standardized' : 'Normalized'}\n                  </div>\n                  {currentData.map((row, i) => (\n                    <div key={i} style={{ fontSize: '10px', color: theme.colors.text }}>\n                      [{row.map(v => v.toFixed(2).padStart(6)).join(', ')}]\n                    </div>\n                  ))}\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n        \n        {/* Key Insight */}\n        <div style={{\n          marginTop: '12px',\n          padding: '10px 14px',\n          background: theme.colors.surface,\n          borderRadius: '8px',\n          fontSize: '10px',\n          color: theme.colors.textSecondary,\n          textAlign: 'center',\n        }}>\n          <strong style={{ color: theme.colors.text }}>When to use which:</strong> Standardization preserves outliers and works well for most ML. \n          Min-Max is better when you need strict bounds (like neural network inputs).\n        </div>\n      </div>\n    </div>\n  );\n}",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}