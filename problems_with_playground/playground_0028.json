{
  "problem_id": 28,
  "title": "SVD of a 2x2 Matrix",
  "category": "Linear Algebra",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useMemo } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// SVD computation for 2x2\nconst computeSVD = (A) => {\n  const a = A[0][0], b = A[0][1], c = A[1][0], d = A[1][1];\n  \n  const y1 = c + b, x1 = a - d;\n  const y2 = c - b, x2 = a + d;\n  \n  const h1 = Math.sqrt(y1*y1 + x1*x1);\n  const h2 = Math.sqrt(y2*y2 + x2*x2);\n  \n  const t1 = h1 > 1e-10 ? x1/h1 : 1.0;\n  const t2 = h2 > 1e-10 ? x2/h2 : 1.0;\n  \n  const cc = Math.sqrt(Math.max(0, (1+t1)*(1+t2)));\n  const ss = Math.sqrt(Math.max(0, (1-t1)*(1-t2)));\n  const cs = Math.sqrt(Math.max(0, (1+t1)*(1-t2)));\n  const sc = Math.sqrt(Math.max(0, (1-t1)*(1+t2)));\n  \n  let c1 = (cc - ss) / 2, s1 = (sc + cs) / 2;\n  if (y1 < 0) s1 = -s1;\n  \n  const U = [[c1, -s1], [s1, c1]];\n  const sigma1 = (h1 + h2) / 2;\n  const sigma2 = Math.abs(h1 - h2) / 2;\n  \n  const Ut = [[U[0][0], U[1][0]], [U[0][1], U[1][1]]];\n  const UtA = [\n    [Ut[0][0]*a + Ut[0][1]*c, Ut[0][0]*b + Ut[0][1]*d],\n    [Ut[1][0]*a + Ut[1][1]*c, Ut[1][0]*b + Ut[1][1]*d]\n  ];\n  \n  const s1Inv = sigma1 > 1e-10 ? 1/sigma1 : 0;\n  const s2Inv = sigma2 > 1e-10 ? 1/sigma2 : 0;\n  \n  const V = [\n    [s1Inv * UtA[0][0], s1Inv * UtA[0][1]],\n    [s2Inv * UtA[1][0], s2Inv * UtA[1][1]]\n  ];\n  \n  return { U, S: [sigma1, sigma2], V };\n};\n\nconst matMul = (A, B) => [\n  [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n  [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n];\n\nconst transpose = (M) => [[M[0][0], M[1][0]], [M[0][1], M[1][1]]];\n\nconst lerp = (a, b, t) => a + (b - a) * t;\nconst lerpMat = (A, B, t) => [\n  [lerp(A[0][0], B[0][0], t), lerp(A[0][1], B[0][1], t)],\n  [lerp(A[1][0], B[1][0], t), lerp(A[1][1], B[1][1], t)]\n];\n\nexport default function App() {\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [matrix, setMatrix] = useState([[2, 1], [1, 2]]);\n  const [animPhase, setAnimPhase] = useState(0); // 0-3 for the 3 transformations\n\n  const numSteps = 5;\n  const svd = useMemo(() => computeSVD(matrix), [matrix]);\n\n  // Generate circle points\n  const circlePoints = useMemo(() => {\n    const pts = [];\n    for (let i = 0; i <= 48; i++) {\n      const t = (i / 48) * Math.PI * 2;\n      pts.push([Math.cos(t), Math.sin(t)]);\n    }\n    return pts;\n  }, []);\n\n  // Transform points by matrix\n  const transform = (pts, M) => pts.map(([x, y]) => [M[0][0]*x + M[0][1]*y, M[1][0]*x + M[1][1]*y]);\n\n  // Get current transformation matrix based on step and animation\n  const getCurrentMatrix = () => {\n    const I = [[1, 0], [0, 1]];\n    const Vt = transpose(svd.V);\n    const S = [[svd.S[0], 0], [0, svd.S[1]]];\n    const { U } = svd;\n\n    if (step === 0) return I; // Just circle\n    if (step === 1) return Vt; // After Vt rotation\n    if (step === 2) return matMul(S, Vt); // After scaling\n    if (step === 3) return matMul(U, matMul(S, Vt)); // Full transform\n    \n    // Step 4: Animated\n    const t = animPhase;\n    if (t < 1) return lerpMat(I, Vt, t);\n    if (t < 2) return lerpMat(Vt, matMul(S, Vt), t - 1);\n    return lerpMat(matMul(S, Vt), matMul(U, matMul(S, Vt)), t - 2);\n  };\n\n  const currentMatrix = getCurrentMatrix();\n  const transformedPoints = transform(circlePoints, currentMatrix);\n\n  // Animation loop for step 4\n  useEffect(() => {\n    if (step === 4) {\n      const interval = setInterval(() => {\n        setAnimPhase(p => {\n          const next = p + 0.02;\n          return next >= 3 ? 0 : next;\n        });\n      }, 30);\n      return () => clearInterval(interval);\n    } else {\n      setAnimPhase(0);\n    }\n  }, [step]);\n\n  // Auto-play\n  useEffect(() => {\n    if (playing) {\n      const timer = setTimeout(() => {\n        if (step < numSteps - 1) setStep(s => s + 1);\n        else setPlaying(false);\n      }, 2500);\n      return () => clearTimeout(timer);\n    }\n  }, [playing, step]);\n\n  const stepInfo = [\n    { title: 'Unit Circle', desc: 'Start with the unit circle. We\\'ll see how matrix A transforms it.', color: theme.colors.primary },\n    { title: 'Step 1: Rotate by Vᵀ', desc: 'First rotation aligns the circle to the \"natural axes\" of the transformation.', color: theme.colors.blue },\n    { title: 'Step 2: Scale by S', desc: 'Stretch by σ₁ and σ₂ along the axes. Circle becomes axis-aligned ellipse.', color: theme.colors.yellow },\n    { title: 'Step 3: Rotate by U', desc: 'Final rotation puts the ellipse in its output orientation. This equals A·x!', color: theme.colors.pink },\n    { title: 'Animation: Full Decomposition', desc: `A = U · S · Vᵀ means: ${animPhase < 1 ? '▶ Rotate Vᵀ' : animPhase < 2 ? '▶ Scale S' : '▶ Rotate U'}`, color: theme.colors.green },\n  ];\n\n  const reset = () => { setStep(0); setPlaying(false); setMatrix([[2, 1], [1, 2]]); setAnimPhase(0); };\n\n  // SVG setup\n  const scale = 55, cx = 180, cy = 160;\n  const toSvg = (x, y) => [cx + x * scale, cy - y * scale];\n\n  const pathFromPoints = (pts) => {\n    const svgPts = pts.map(p => toSvg(p[0], p[1]));\n    return 'M ' + svgPts.map(([x, y]) => `${x},${y}`).join(' L ') + ' Z';\n  };\n\n  const Arrow = ({ to, color, label, dashed = false }) => {\n    const [x1, y1] = toSvg(0, 0);\n    const [x2, y2] = toSvg(to[0], to[1]);\n    const angle = Math.atan2(y1 - y2, x2 - x1);\n    const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);\n    if (len < 8) return null;\n    return (\n      <g>\n        <line x1={x1} y1={y1} x2={x2} y2={y2} stroke={color} strokeWidth=\"2.5\" strokeDasharray={dashed ? '5,4' : 'none'} />\n        <polygon points={`${x2},${y2} ${x2-8*Math.cos(angle-0.4)},${y2+8*Math.sin(angle-0.4)} ${x2-8*Math.cos(angle+0.4)},${y2+8*Math.sin(angle+0.4)}`} fill={color} />\n        {label && <text x={x2 + 12*Math.cos(angle+0.3)} y={y2 - 12*Math.sin(angle+0.3)} fill={color} fontSize=\"12\" fontWeight=\"600\">{label}</text>}\n      </g>\n    );\n  };\n\n  // V and U vectors\n  const v1 = [svd.V[0][0], svd.V[1][0]], v2 = [svd.V[0][1], svd.V[1][1]];\n  const u1 = [svd.U[0][0], svd.U[1][0]], u2 = [svd.U[0][1], svd.U[1][1]];\n\n  // Current phase label for step 4\n  const phaseLabels = ['Rotating by Vᵀ', 'Scaling by S', 'Rotating by U'];\n  const currentPhaseLabel = step === 4 ? phaseLabels[Math.min(Math.floor(animPhase), 2)] : '';\n\n  return (\n    <div style={{ background: theme.colors.background, minHeight: '100vh', padding: '12px', fontFamily: theme.font, color: theme.colors.text }}>\n      \n      {/* Header */}\n      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px' }}>\n        <div>\n          <div style={{ fontSize: '18px', fontWeight: '700' }}>SVD: Singular Value Decomposition</div>\n          <div style={{ fontSize: '12px', color: theme.colors.textSecondary }}>A = U · S · Vᵀ (rotate → stretch → rotate)</div>\n        </div>\n        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n          <button onClick={() => setStep(Math.max(0, step - 1))} disabled={step === 0}\n            style={{ padding: '6px 12px', background: theme.colors.surface, border: 'none', borderRadius: '6px',\n              color: step === 0 ? theme.colors.textMuted : theme.colors.text, fontSize: '14px', cursor: 'pointer' }}>{'<'}</button>\n          <div style={{ display: 'flex', gap: '5px' }}>\n            {Array.from({ length: numSteps }, (_, i) => (\n              <div key={i} onClick={() => setStep(i)} style={{\n                width: i === step ? '18px' : '10px', height: '10px', borderRadius: '5px',\n                background: i <= step ? stepInfo[i].color : theme.colors.border, cursor: 'pointer'\n              }} />\n            ))}\n          </div>\n          <button onClick={() => setStep(Math.min(numSteps - 1, step + 1))} disabled={step === numSteps - 1}\n            style={{ padding: '6px 12px', background: step === numSteps - 1 ? theme.colors.surface : theme.colors.primary,\n              border: 'none', borderRadius: '6px', color: theme.colors.text, fontSize: '14px', cursor: 'pointer' }}>{'>'}</button>\n          <button onClick={() => setPlaying(!playing)}\n            style={{ padding: '6px 12px', background: playing ? theme.colors.green : theme.colors.surface,\n              border: 'none', borderRadius: '6px', color: playing ? theme.colors.background : theme.colors.text,\n              fontSize: '12px', cursor: 'pointer' }}>{playing ? '...' : 'Play'}</button>\n          <button onClick={reset}\n            style={{ padding: '6px 10px', background: theme.colors.surface, border: 'none', borderRadius: '6px',\n              color: theme.colors.textSecondary, fontSize: '14px', cursor: 'pointer' }}>~</button>\n        </div>\n      </div>\n\n      {/* Step info */}\n      <div style={{ padding: '8px 12px', background: theme.colors.surface, borderLeft: `3px solid ${stepInfo[step].color}`,\n        borderRadius: '0 6px 6px 0', marginBottom: '10px' }}>\n        <span style={{ fontWeight: '600', color: stepInfo[step].color, fontSize: '14px' }}>{stepInfo[step].title}: </span>\n        <span style={{ color: theme.colors.textSecondary, fontSize: '13px' }}>{stepInfo[step].desc}</span>\n      </div>\n\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>\n        {/* Main visualization */}\n        <div style={{ flex: 1.4, background: theme.colors.surface, borderRadius: '10px', padding: '10px' }}>\n          <svg viewBox=\"0 0 360 320\" style={{ width: '100%', height: '300px' }}>\n            <rect x=\"0\" y=\"0\" width=\"360\" height=\"320\" fill={theme.colors.surfaceAlt} rx=\"8\" />\n            \n            {/* Grid */}\n            {[-3,-2,-1,0,1,2,3].map(i => (\n              <g key={i}>\n                <line x1={cx + i*scale} y1=\"10\" x2={cx + i*scale} y2=\"310\" stroke={theme.colors.border} strokeWidth=\"0.5\" />\n                <line x1=\"10\" y1={cy - i*scale} x2=\"350\" y2={cy - i*scale} stroke={theme.colors.border} strokeWidth=\"0.5\" />\n              </g>\n            ))}\n            <line x1=\"10\" y1={cy} x2=\"350\" y2={cy} stroke={theme.colors.textMuted} strokeWidth=\"1\" />\n            <line x1={cx} y1=\"10\" x2={cx} y2=\"310\" stroke={theme.colors.textMuted} strokeWidth=\"1\" />\n\n            {/* Unit circle (always shown, dashed) */}\n            <path d={pathFromPoints(circlePoints)} fill=\"none\" stroke={theme.colors.textMuted} strokeWidth=\"1.5\" strokeDasharray=\"4,4\" />\n\n            {/* Transformed shape */}\n            <path d={pathFromPoints(transformedPoints)} fill={stepInfo[step].color + '20'} stroke={stepInfo[step].color} strokeWidth=\"2.5\" />\n\n            {/* V vectors (input directions) - show on steps 1+ */}\n            {step >= 1 && step < 4 && (\n              <>\n                <Arrow to={v1} color={theme.colors.blue} label=\"v₁\" />\n                <Arrow to={v2} color={theme.colors.blue} label=\"v₂\" dashed />\n              </>\n            )}\n\n            {/* Scaled axes after S (step 2+) */}\n            {step >= 2 && step < 4 && (\n              <>\n                <Arrow to={[svd.S[0], 0]} color={theme.colors.yellow} label={`σ₁=${svd.S[0].toFixed(1)}`} />\n                {svd.S[1] > 0.1 && <Arrow to={[0, svd.S[1]]} color={theme.colors.orange} label={`σ₂=${svd.S[1].toFixed(1)}`} />}\n              </>\n            )}\n\n            {/* U vectors (output directions) - show on step 3 */}\n            {step === 3 && (\n              <>\n                <Arrow to={[u1[0]*svd.S[0], u1[1]*svd.S[0]]} color={theme.colors.pink} label=\"σ₁u₁\" />\n                <Arrow to={[u2[0]*svd.S[1], u2[1]*svd.S[1]]} color={theme.colors.pink} label=\"σ₂u₂\" dashed />\n              </>\n            )}\n\n            {/* Origin */}\n            <circle cx={cx} cy={cy} r=\"4\" fill={theme.colors.text} />\n\n            {/* Phase indicator for animation */}\n            {step === 4 && (\n              <text x=\"180\" y=\"25\" textAnchor=\"middle\" fill={theme.colors.green} fontSize=\"14\" fontWeight=\"600\">\n                {currentPhaseLabel}\n              </text>\n            )}\n          </svg>\n\n          {/* Legend */}\n          <div style={{ display: 'flex', justifyContent: 'center', gap: '16px', marginTop: '8px', fontSize: '11px', color: theme.colors.textSecondary }}>\n            <span>--- Unit circle</span>\n            <span style={{ color: stepInfo[step].color }}>● Current shape</span>\n          </div>\n        </div>\n\n        {/* Right panel */}\n        <div style={{ flex: 0.6, display: 'flex', flexDirection: 'column', gap: '8px' }}>\n          \n          {/* Matrix input */}\n          <div style={{ background: theme.colors.surface, borderRadius: '8px', padding: '12px' }}>\n            <div style={{ fontSize: '11px', color: theme.colors.textMuted, marginBottom: '8px' }}>Matrix A</div>\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px' }}>\n              {[[0,0],[0,1],[1,0],[1,1]].map(([i,j]) => (\n                <input key={`${i}${j}`} type=\"number\" step=\"0.5\" value={matrix[i][j]}\n                  onChange={e => {\n                    const m = matrix.map(r => [...r]);\n                    m[i][j] = parseFloat(e.target.value) || 0;\n                    setMatrix(m);\n                  }}\n                  style={{ background: theme.colors.surfaceAlt, border: `1px solid ${theme.colors.border}`,\n                    borderRadius: '4px', padding: '8px', color: theme.colors.text, fontSize: '14px',\n                    textAlign: 'center', fontFamily: theme.font }} />\n              ))}\n            </div>\n          </div>\n\n          {/* Singular values */}\n          <div style={{ background: theme.colors.surface, borderRadius: '8px', padding: '12px' }}>\n            <div style={{ fontSize: '11px', color: theme.colors.textMuted, marginBottom: '8px' }}>Singular Values</div>\n            <div style={{ fontSize: '13px' }}>\n              <div style={{ marginBottom: '4px' }}>\n                <span style={{ color: theme.colors.yellow }}>σ₁</span> = <span style={{ color: theme.colors.text, fontWeight: '600' }}>{svd.S[0].toFixed(3)}</span>\n              </div>\n              <div>\n                <span style={{ color: theme.colors.orange }}>σ₂</span> = <span style={{ color: theme.colors.text, fontWeight: '600' }}>{svd.S[1].toFixed(3)}</span>\n              </div>\n            </div>\n            <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '8px' }}>\n              = semi-axis lengths of ellipse\n            </div>\n          </div>\n\n          {/* Decomposition steps */}\n          <div style={{ background: theme.colors.surface, borderRadius: '8px', padding: '12px' }}>\n            <div style={{ fontSize: '11px', color: theme.colors.textMuted, marginBottom: '8px' }}>Decomposition</div>\n            <div style={{ fontSize: '12px', lineHeight: 1.8 }}>\n              <div style={{ opacity: step >= 1 ? 1 : 0.3 }}>\n                <span style={{ color: theme.colors.blue }}>1. Vᵀ</span>: rotate input\n              </div>\n              <div style={{ opacity: step >= 2 ? 1 : 0.3 }}>\n                <span style={{ color: theme.colors.yellow }}>2. S</span>: stretch axes\n              </div>\n              <div style={{ opacity: step >= 3 ? 1 : 0.3 }}>\n                <span style={{ color: theme.colors.pink }}>3. U</span>: rotate output\n              </div>\n            </div>\n          </div>\n\n          {/* Animation progress */}\n          {step === 4 && (\n            <div style={{ background: theme.colors.surface, borderRadius: '8px', padding: '12px' }}>\n              <div style={{ fontSize: '11px', color: theme.colors.textMuted, marginBottom: '8px' }}>Animation</div>\n              <div style={{ display: 'flex', gap: '4px' }}>\n                {[0,1,2].map(i => (\n                  <div key={i} style={{ flex: 1, height: '6px', background: theme.colors.border, borderRadius: '3px', overflow: 'hidden' }}>\n                    <div style={{\n                      height: '100%',\n                      background: [theme.colors.blue, theme.colors.yellow, theme.colors.pink][i],\n                      width: animPhase >= i+1 ? '100%' : animPhase > i ? `${(animPhase - i) * 100}%` : '0%',\n                      transition: 'width 0.03s linear'\n                    }} />\n                  </div>\n                ))}\n              </div>\n              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                <span>Vᵀ</span><span>S</span><span>U</span>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Key Insight */}\n      <div style={{ background: theme.colors.surfaceAlt, borderRadius: '8px', padding: '10px 14px',\n        fontSize: '12px', color: theme.colors.textSecondary, borderLeft: `3px solid ${theme.colors.primary}` }}>\n        <span style={{ color: theme.colors.primary, fontWeight: '600' }}>Key: </span>\n        {step === 0 && 'ANY matrix transformation can be decomposed into three simple steps: rotate, stretch along axes, rotate again.'}\n        {step === 1 && 'Vᵀ rotates input space to align with the \"natural directions\" of A — the directions that will become the ellipse axes.'}\n        {step === 2 && 'S stretches along x and y by σ₁ and σ₂. These singular values ARE the semi-axis lengths of the output ellipse!'}\n        {step === 3 && 'U rotates the axis-aligned ellipse to its final orientation. Together: A = U·S·Vᵀ. Try changing the matrix!'}\n        {step === 4 && 'Watch the circle transform: Vᵀ aligns it, S stretches it into an ellipse, U rotates to final position. Simple steps = complex transform!'}\n      </div>\n    </div>\n  );\n}",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}