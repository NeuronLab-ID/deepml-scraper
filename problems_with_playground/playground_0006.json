{
  "problem_id": 6,
  "title": "Calculate Eigenvalues of a Matrix",
  "category": "Linear Algebra",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useMemo, useRef, useEffect } from 'react';\n\n// ============================================\n// Design Tokens\n// ============================================\nconst theme = {\n  colors: {\n    primary: '#6366f1',\n    secondary: '#ffffff',\n    background: '#000000',\n    surface: '#0a0a0a',\n    surfaceAlt: '#111111',\n    border: '#1f1f1f',\n    text: '#ffffff',\n    textSecondary: '#a1a1aa',\n    textMuted: '#71717a',\n    lambda1: '#22c55e',\n    lambda2: '#f59e0b',\n    gridLine: '#1a1a2e',\n    vector: '#ec4899',\n    transformed: '#06b6d4',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// ============================================\n// Icons\n// ============================================\nconst Icons = {\n  Play: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <polygon points=\"5 3 19 12 5 21 5 3\"/>\n    </svg>\n  ),\n  RotateCcw: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <path d=\"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8\"/><path d=\"M3 3v5h5\"/>\n    </svg>\n  ),\n  Pause: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <rect x=\"6\" y=\"4\" width=\"4\" height=\"16\"/><rect x=\"14\" y=\"4\" width=\"4\" height=\"16\"/>\n    </svg>\n  ),\n};\n\n// ============================================\n// Card Component\n// ============================================\nfunction Card({ children, style = {} }) {\n  return (\n    <div style={{\n      background: theme.colors.surface,\n      border: `1px solid ${theme.colors.border}`,\n      borderRadius: '12px',\n      padding: '24px',\n      ...style,\n    }}>\n      {children}\n    </div>\n  );\n}\n\n// ============================================\n// Transformation Canvas\n// ============================================\nfunction TransformationCanvas({ matrix, showEigenvectors, animationT }) {\n  const canvasRef = useRef(null);\n  const size = 320;\n  const scale = 40;\n  const center = size / 2;\n  \n  const { a, b, c, d } = matrix;\n  \n  // Calculate eigenvalues and eigenvectors\n  const eigen = useMemo(() => {\n    const trace = a + d;\n    const det = a * d - b * c;\n    const disc = trace * trace - 4 * det;\n    \n    if (disc < 0) return { isComplex: true };\n    \n    const sqrtDisc = Math.sqrt(disc);\n    const lambda1 = (trace + sqrtDisc) / 2;\n    const lambda2 = (trace - sqrtDisc) / 2;\n    \n    // Calculate eigenvectors\n    let v1 = [1, 0], v2 = [0, 1];\n    \n    if (Math.abs(b) > 0.0001) {\n      v1 = [b, lambda1 - a];\n      v2 = [b, lambda2 - a];\n    } else if (Math.abs(c) > 0.0001) {\n      v1 = [lambda1 - d, c];\n      v2 = [lambda2 - d, c];\n    } else {\n      v1 = [1, 0];\n      v2 = [0, 1];\n    }\n    \n    // Normalize\n    const norm1 = Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1]);\n    const norm2 = Math.sqrt(v2[0]*v2[0] + v2[1]*v2[1]);\n    v1 = [v1[0]/norm1, v1[1]/norm1];\n    v2 = [v2[0]/norm2, v2[1]/norm2];\n    \n    return { lambda1, lambda2, v1, v2, isComplex: false };\n  }, [a, b, c, d]);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear\n    ctx.fillStyle = theme.colors.background;\n    ctx.fillRect(0, 0, size, size);\n    \n    // Helper: transform point\n    const transform = (x, y, t) => {\n      const mat = {\n        a: 1 + (a - 1) * t,\n        b: b * t,\n        c: c * t,\n        d: 1 + (d - 1) * t,\n      };\n      return [\n        mat.a * x + mat.b * y,\n        mat.c * x + mat.d * y,\n      ];\n    };\n    \n    // Helper: to canvas coords\n    const toCanvas = (x, y) => [center + x * scale, center - y * scale];\n    \n    // Draw grid lines\n    ctx.strokeStyle = theme.colors.gridLine;\n    ctx.lineWidth = 1;\n    for (let i = -4; i <= 4; i++) {\n      // Vertical lines\n      ctx.beginPath();\n      const [x1, y1] = toCanvas(...transform(i, -4, animationT));\n      const [x2, y2] = toCanvas(...transform(i, 4, animationT));\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n      \n      // Horizontal lines\n      ctx.beginPath();\n      const [x3, y3] = toCanvas(...transform(-4, i, animationT));\n      const [x4, y4] = toCanvas(...transform(4, i, animationT));\n      ctx.moveTo(x3, y3);\n      ctx.lineTo(x4, y4);\n      ctx.stroke();\n    }\n    \n    // Draw axes\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(0, center);\n    ctx.lineTo(size, center);\n    ctx.moveTo(center, 0);\n    ctx.lineTo(center, size);\n    ctx.stroke();\n    \n    // Draw unit circle transforming into ellipse\n    ctx.strokeStyle = theme.colors.vector;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {\n      const x = Math.cos(angle);\n      const y = Math.sin(angle);\n      const [tx, ty] = transform(x, y, animationT);\n      const [cx, cy] = toCanvas(tx, ty);\n      if (angle === 0) ctx.moveTo(cx, cy);\n      else ctx.lineTo(cx, cy);\n    }\n    ctx.closePath();\n    ctx.stroke();\n    \n    // Draw eigenvectors if enabled and real\n    if (showEigenvectors && !eigen.isComplex) {\n      const drawEigenvector = (v, lambda, color) => {\n        const len = 3;\n        const [x1, y1] = toCanvas(-v[0] * len, -v[1] * len);\n        const [x2, y2] = toCanvas(v[0] * len, v[1] * len);\n        \n        ctx.strokeStyle = color;\n        ctx.lineWidth = 3;\n        ctx.setLineDash([8, 4]);\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.setLineDash([]);\n        \n        // Draw arrow on eigenvector showing stretch\n        const [ox, oy] = toCanvas(v[0], v[1]);\n        const [tx, ty] = toCanvas(...transform(v[0], v[1], animationT));\n        \n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(ox, oy, 6, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.fillStyle = theme.colors.transformed;\n        ctx.beginPath();\n        ctx.arc(tx, ty, 6, 0, Math.PI * 2);\n        ctx.fill();\n      };\n      \n      drawEigenvector(eigen.v1, eigen.lambda1, theme.colors.lambda1);\n      drawEigenvector(eigen.v2, eigen.lambda2, theme.colors.lambda2);\n    }\n    \n    // Draw basis vectors\n    const drawArrow = (fromX, fromY, toX, toY, color) => {\n      const [fx, fy] = toCanvas(fromX, fromY);\n      const [tx, ty] = toCanvas(toX, toY);\n      \n      ctx.strokeStyle = color;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(fx, fy);\n      ctx.lineTo(tx, ty);\n      ctx.stroke();\n      \n      // Arrowhead\n      const angle = Math.atan2(fy - ty, fx - tx);\n      ctx.beginPath();\n      ctx.moveTo(tx, ty);\n      ctx.lineTo(tx + 10 * Math.cos(angle + 0.4), ty + 10 * Math.sin(angle + 0.4));\n      ctx.lineTo(tx + 10 * Math.cos(angle - 0.4), ty + 10 * Math.sin(angle - 0.4));\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n    };\n    \n    // Original basis vectors (faded)\n    if (animationT > 0) {\n      ctx.globalAlpha = 0.3;\n      drawArrow(0, 0, 1, 0, theme.colors.vector);\n      drawArrow(0, 0, 0, 1, theme.colors.vector);\n      ctx.globalAlpha = 1;\n    }\n    \n    // Transformed basis vectors\n    const [e1x, e1y] = transform(1, 0, animationT);\n    const [e2x, e2y] = transform(0, 1, animationT);\n    drawArrow(0, 0, e1x, e1y, theme.colors.transformed);\n    drawArrow(0, 0, e2x, e2y, theme.colors.transformed);\n    \n  }, [a, b, c, d, animationT, showEigenvectors, eigen]);\n  \n  return (\n    <div style={{ position: 'relative' }}>\n      <canvas\n        ref={canvasRef}\n        width={size}\n        height={size}\n        style={{\n          borderRadius: '8px',\n          border: `1px solid ${theme.colors.border}`,\n        }}\n      />\n      \n      {/* Legend */}\n      <div style={{\n        position: 'absolute',\n        bottom: '8px',\n        left: '8px',\n        background: 'rgba(0,0,0,0.8)',\n        padding: '8px 12px',\n        borderRadius: '6px',\n        fontSize: '11px',\n      }}>\n        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px' }}>\n          <div style={{ width: '12px', height: '3px', background: theme.colors.vector, borderRadius: '2px' }} />\n          <span style={{ color: theme.colors.vector }}>Original</span>\n        </div>\n        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>\n          <div style={{ width: '12px', height: '3px', background: theme.colors.transformed, borderRadius: '2px' }} />\n          <span style={{ color: theme.colors.transformed }}>Transformed</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// ============================================\n// Interactive Slider\n// ============================================\nfunction MatrixSlider({ label, value, onChange, min = -3, max = 3 }) {\n  return (\n    <div style={{ marginBottom: '12px' }}>\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        marginBottom: '6px',\n      }}>\n        <span style={{ fontSize: '13px', color: theme.colors.textSecondary }}>{label}</span>\n        <span style={{ \n          fontSize: '14px', \n          fontWeight: '600', \n          color: theme.colors.text,\n          fontFamily: theme.font,\n        }}>\n          {value.toFixed(1)}\n        </span>\n      </div>\n      <input\n        type=\"range\"\n        min={min}\n        max={max}\n        step={0.1}\n        value={value}\n        onChange={(e) => onChange(parseFloat(e.target.value))}\n        style={{\n          width: '100%',\n          height: '6px',\n          borderRadius: '3px',\n          background: theme.colors.surfaceAlt,\n          appearance: 'none',\n          cursor: 'pointer',\n        }}\n      />\n    </div>\n  );\n}\n\n// ============================================\n// Eigenvalue Display\n// ============================================\nfunction EigenDisplay({ lambda, label, color, eigenvector }) {\n  const isValid = typeof lambda === 'number' && !isNaN(lambda);\n  \n  return (\n    <div style={{\n      padding: '16px',\n      background: `${color}10`,\n      border: `1px solid ${color}40`,\n      borderRadius: '8px',\n      textAlign: 'center',\n    }}>\n      <div style={{ fontSize: '12px', color, fontWeight: '600', marginBottom: '4px' }}>\n        {label}\n      </div>\n      <div style={{\n        fontSize: '28px',\n        fontWeight: '700',\n        color: isValid ? theme.colors.text : theme.colors.textMuted,\n        fontFamily: theme.font,\n      }}>\n        {isValid ? lambda.toFixed(2) : '—'}\n      </div>\n      {isValid && (\n        <div style={{ fontSize: '11px', color: theme.colors.textMuted, marginTop: '8px' }}>\n          {lambda > 1 ? '↑ Stretch' : lambda > 0 ? '↓ Shrink' : lambda < 0 ? '↔ Flip' : '• Zero'}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// ============================================\n// Main Component\n// ============================================\nexport default function EigenvaluesVisual() {\n  const [matrix, setMatrix] = useState({ a: 2, b: 1, c: 0, d: 1 });\n  const [animationT, setAnimationT] = useState(1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [showEigenvectors, setShowEigenvectors] = useState(true);\n  \n  const { a, b, c, d } = matrix;\n  \n  // Calculate eigenvalues\n  const eigen = useMemo(() => {\n    const trace = a + d;\n    const det = a * d - b * c;\n    const disc = trace * trace - 4 * det;\n    \n    if (disc < 0) {\n      return { lambda1: NaN, lambda2: NaN, isComplex: true, trace, det };\n    }\n    \n    const sqrtDisc = Math.sqrt(disc);\n    return {\n      lambda1: (trace + sqrtDisc) / 2,\n      lambda2: (trace - sqrtDisc) / 2,\n      isComplex: false,\n      trace,\n      det,\n    };\n  }, [a, b, c, d]);\n  \n  // Animation loop\n  useEffect(() => {\n    if (!isPlaying) return;\n    \n    let frame;\n    let start = null;\n    const duration = 2000;\n    \n    const animate = (timestamp) => {\n      if (!start) start = timestamp;\n      const progress = (timestamp - start) / duration;\n      \n      if (progress < 1) {\n        setAnimationT(progress);\n        frame = requestAnimationFrame(animate);\n      } else {\n        setAnimationT(1);\n        setIsPlaying(false);\n      }\n    };\n    \n    setAnimationT(0);\n    frame = requestAnimationFrame(animate);\n    \n    return () => cancelAnimationFrame(frame);\n  }, [isPlaying]);\n  \n  // Presets\n  const presets = [\n    { name: 'Stretch', matrix: { a: 2, b: 0, c: 0, d: 1 } },\n    { name: 'Rotate 45°', matrix: { a: 0.7, b: -0.7, c: 0.7, d: 0.7 } },\n    { name: 'Shear', matrix: { a: 1, b: 1, c: 0, d: 1 } },\n    { name: 'Reflect', matrix: { a: 0, b: 1, c: 1, d: 0 } },\n    { name: 'Squeeze', matrix: { a: 2, b: 0, c: 0, d: 0.5 } },\n  ];\n\n  return (\n    <div style={{\n      minHeight: '100vh',\n      background: theme.colors.background,\n      color: theme.colors.text,\n      fontFamily: theme.font,\n      padding: '32px',\n    }}>\n      <div style={{ maxWidth: '900px', margin: '0 auto' }}>\n        {/* Header */}\n        <div style={{ marginBottom: '24px' }}>\n          <h1 style={{ fontSize: '24px', fontWeight: '600', margin: '0 0 8px 0' }}>\n            Eigenvalues: Visualized\n          </h1>\n          <p style={{ color: theme.colors.textSecondary, fontSize: '14px', margin: 0 }}>\n            Eigenvalues are the <strong style={{ color: theme.colors.lambda1 }}>scaling factors</strong> along \n            directions that <strong>don't rotate</strong> — only stretch or flip\n          </p>\n        </div>\n        \n        {/* Presets */}\n        <div style={{ \n          display: 'flex', \n          gap: '8px', \n          marginBottom: '16px',\n          flexWrap: 'wrap',\n        }}>\n          {presets.map(({ name, matrix: m }) => (\n            <button\n              key={name}\n              onClick={() => { setMatrix(m); setAnimationT(1); }}\n              style={{\n                padding: '8px 14px',\n                background: theme.colors.surfaceAlt,\n                border: `1px solid ${theme.colors.border}`,\n                borderRadius: '6px',\n                color: theme.colors.textSecondary,\n                fontFamily: theme.font,\n                fontSize: '12px',\n                cursor: 'pointer',\n              }}\n            >\n              {name}\n            </button>\n          ))}\n        </div>\n        \n        {/* Main Content */}\n        <div style={{ \n          display: 'grid', \n          gridTemplateColumns: '1fr 320px',\n          gap: '16px',\n        }}>\n          {/* Left: Controls */}\n          <Card>\n            {/* Matrix Display */}\n            <div style={{ marginBottom: '24px' }}>\n              <div style={{ \n                fontSize: '11px', \n                color: theme.colors.textMuted, \n                textTransform: 'uppercase',\n                letterSpacing: '0.5px',\n                marginBottom: '12px',\n              }}>\n                Matrix A\n              </div>\n              <div style={{\n                display: 'grid',\n                gridTemplateColumns: '1fr 1fr',\n                gap: '8px',\n                padding: '16px',\n                background: theme.colors.surfaceAlt,\n                borderRadius: '8px',\n                fontFamily: theme.font,\n                fontSize: '20px',\n                fontWeight: '600',\n                textAlign: 'center',\n              }}>\n                <div style={{ color: theme.colors.text }}>{a.toFixed(1)}</div>\n                <div style={{ color: theme.colors.text }}>{b.toFixed(1)}</div>\n                <div style={{ color: theme.colors.text }}>{c.toFixed(1)}</div>\n                <div style={{ color: theme.colors.text }}>{d.toFixed(1)}</div>\n              </div>\n            </div>\n            \n            {/* Sliders */}\n            <MatrixSlider label=\"a (top-left)\" value={a} onChange={(v) => setMatrix({ ...matrix, a: v })} />\n            <MatrixSlider label=\"b (top-right)\" value={b} onChange={(v) => setMatrix({ ...matrix, b: v })} />\n            <MatrixSlider label=\"c (bottom-left)\" value={c} onChange={(v) => setMatrix({ ...matrix, c: v })} />\n            <MatrixSlider label=\"d (bottom-right)\" value={d} onChange={(v) => setMatrix({ ...matrix, d: v })} />\n            \n            {/* Eigenvalues */}\n            <div style={{ marginTop: '24px' }}>\n              <div style={{ \n                fontSize: '11px', \n                color: theme.colors.textMuted, \n                textTransform: 'uppercase',\n                letterSpacing: '0.5px',\n                marginBottom: '12px',\n              }}>\n                Eigenvalues\n              </div>\n              \n              {eigen.isComplex ? (\n                <div style={{\n                  padding: '16px',\n                  background: `${theme.colors.primary}10`,\n                  border: `1px solid ${theme.colors.primary}40`,\n                  borderRadius: '8px',\n                  textAlign: 'center',\n                  color: theme.colors.primary,\n                }}>\n                  Complex eigenvalues — matrix rotates all vectors!\n                </div>\n              ) : (\n                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>\n                  <EigenDisplay \n                    lambda={eigen.lambda1} \n                    label=\"λ₁\" \n                    color={theme.colors.lambda1}\n                  />\n                  <EigenDisplay \n                    lambda={eigen.lambda2} \n                    label=\"λ₂\" \n                    color={theme.colors.lambda2}\n                  />\n                </div>\n              )}\n            </div>\n            \n            {/* Controls */}\n            <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>\n              <button\n                onClick={() => setIsPlaying(true)}\n                disabled={isPlaying}\n                style={{\n                  flex: 1,\n                  display: 'flex',\n                  alignItems: 'center',\n                  justifyContent: 'center',\n                  gap: '8px',\n                  padding: '12px',\n                  background: theme.colors.primary,\n                  border: 'none',\n                  borderRadius: '8px',\n                  color: theme.colors.secondary,\n                  fontFamily: theme.font,\n                  fontSize: '14px',\n                  fontWeight: '600',\n                  cursor: isPlaying ? 'not-allowed' : 'pointer',\n                  opacity: isPlaying ? 0.7 : 1,\n                }}\n              >\n                <Icons.Play size={16} />\n                {isPlaying ? 'Playing...' : 'Play Transform'}\n              </button>\n              \n              <button\n                onClick={() => { setMatrix({ a: 1, b: 0, c: 0, d: 1 }); setAnimationT(1); }}\n                style={{\n                  padding: '12px',\n                  background: theme.colors.surfaceAlt,\n                  border: `1px solid ${theme.colors.border}`,\n                  borderRadius: '8px',\n                  color: theme.colors.textSecondary,\n                  cursor: 'pointer',\n                }}\n              >\n                <Icons.RotateCcw size={16} />\n              </button>\n            </div>\n            \n            {/* Toggle eigenvectors */}\n            <label style={{\n              display: 'flex',\n              alignItems: 'center',\n              gap: '10px',\n              marginTop: '16px',\n              cursor: 'pointer',\n              fontSize: '13px',\n              color: theme.colors.textSecondary,\n            }}>\n              <input\n                type=\"checkbox\"\n                checked={showEigenvectors}\n                onChange={(e) => setShowEigenvectors(e.target.checked)}\n                style={{ width: '16px', height: '16px' }}\n              />\n              Show eigenvector directions\n            </label>\n          </Card>\n          \n          {/* Right: Canvas */}\n          <div>\n            <TransformationCanvas \n              matrix={matrix}\n              animationT={animationT}\n              showEigenvectors={showEigenvectors}\n            />\n            \n            {/* Explanation */}\n            <div style={{\n              marginTop: '16px',\n              padding: '16px',\n              background: theme.colors.surface,\n              border: `1px solid ${theme.colors.border}`,\n              borderRadius: '8px',\n              fontSize: '12px',\n              color: theme.colors.textSecondary,\n            }}>\n              {!eigen.isComplex ? (\n                <>\n                  <p style={{ margin: '0 0 8px 0' }}>\n                    The <strong style={{ color: theme.colors.lambda1 }}>green</strong> and <strong style={{ color: theme.colors.lambda2 }}>yellow</strong> dashed lines show <strong>eigenvector directions</strong>.\n                  </p>\n                  <p style={{ margin: 0 }}>\n                    Vectors on these lines <strong>only scale</strong> — they don't rotate. The eigenvalue tells you <em>how much</em> they scale.\n                  </p>\n                </>\n              ) : (\n                <p style={{ margin: 0 }}>\n                  When eigenvalues are <strong>complex</strong>, no direction stays fixed — the matrix rotates everything!\n                </p>\n              )}\n            </div>\n          </div>\n        </div>\n        \n        {/* Key Insight */}\n        <Card style={{ marginTop: '16px' }}>\n          <div style={{ \n            fontSize: '14px',\n            lineHeight: '1.6',\n          }}>\n            <strong style={{ color: theme.colors.primary }}>Key Insight:</strong>{' '}\n            <span style={{ color: theme.colors.textSecondary }}>\n              If Av = λv, then multiplying vector v by matrix A just scales it by λ. \n              The pink circle shows how the matrix transforms <em>all</em> vectors — \n              but only eigenvectors stay on their original line!\n            </span>\n          </div>\n        </Card>\n      </div>\n    </div>\n  );\n}",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}