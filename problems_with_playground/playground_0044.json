{
  "problem_id": 44,
  "title": "Leaky ReLU Activation Function",
  "category": "Deep Learning",
  "enabled": true,
  "type": "react",
  "code": "\nimport React, { useState } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// ReLU and Leaky ReLU functions\nconst relu = (z) => Math.max(0, z);\nconst leakyRelu = (z, alpha) => z > 0 ? z : alpha * z;\n\nexport default function LeakyReluPlayground() {\n  const [alpha, setAlpha] = useState(0.01);\n  const [inputZ, setInputZ] = useState(-2);\n  const [hoveredX, setHoveredX] = useState(null);\n\n  // SVG dimensions\n  const width = 360;\n  const height = 280;\n  const pad = 40;\n  const xMin = -5, xMax = 5;\n  const yMin = -1, yMax = 5;\n  \n  const xScale = (x) => pad + ((x - xMin) / (xMax - xMin)) * (width - 2 * pad);\n  const yScale = (y) => height - pad - ((y - yMin) / (yMax - yMin)) * (height - 2 * pad);\n\n  // Generate curve points\n  const generateCurve = (fn, alpha = 0.01) => {\n    const points = [];\n    for (let x = xMin; x <= xMax; x += 0.1) {\n      const y = fn(x, alpha);\n      if (y >= yMin && y <= yMax) {\n        points.push({ x, y });\n      }\n    }\n    return points;\n  };\n\n  const reluCurve = generateCurve(relu);\n  const leakyReluCurve = generateCurve(leakyRelu, alpha);\n\n  const output = leakyRelu(inputZ, alpha);\n  const reluOutput = relu(inputZ);\n\n  return (\n    <div style={{ minHeight: '100vh', background: theme.colors.background, padding: '16px', fontFamily: theme.font, color: theme.colors.text }}>\n      \n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '16px' }}>\n        <div style={{ fontSize: '20px', fontWeight: '700' }}>Leaky ReLU Activation</div>\n        <div style={{ fontSize: '12px', color: theme.colors.textSecondary }}>Solving the \"dying ReLU\" problem</div>\n      </div>\n\n      {/* Formula */}\n      <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '14px', marginBottom: '12px', textAlign: 'center' }}>\n        <div style={{ fontSize: '14px', marginBottom: '8px' }}>\n          <span style={{ color: theme.colors.yellow }}>f(z)</span> = {' '}\n          <span style={{ color: theme.colors.positive }}>z</span> if z {'>'} 0, {' '}\n          <span style={{ color: theme.colors.orange }}>α·z</span> if z ≤ 0\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textMuted }}>\n          Unlike ReLU, negative inputs get a small gradient (α) instead of zero\n        </div>\n      </div>\n\n      {/* Graph */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '16px', marginBottom: '12px' }}>\n        <svg \n          width={width} \n          height={height} \n          style={{ display: 'block', margin: '0 auto', background: theme.colors.surfaceAlt, borderRadius: '8px' }}\n          onMouseMove={(e) => {\n            const rect = e.currentTarget.getBoundingClientRect();\n            const x = ((e.clientX - rect.left - pad) / (width - 2 * pad)) * (xMax - xMin) + xMin;\n            if (x >= xMin && x <= xMax) setHoveredX(x);\n          }}\n          onMouseLeave={() => setHoveredX(null)}\n        >\n          {/* Grid lines */}\n          {[-4, -2, 0, 2, 4].map(x => (\n            <line key={`gx-${x}`} x1={xScale(x)} y1={yScale(yMin)} x2={xScale(x)} y2={yScale(yMax)} stroke={theme.colors.border} strokeWidth=\"1\" />\n          ))}\n          {[0, 1, 2, 3, 4].map(y => (\n            <line key={`gy-${y}`} x1={xScale(xMin)} y1={yScale(y)} x2={xScale(xMax)} y2={yScale(y)} stroke={theme.colors.border} strokeWidth=\"1\" />\n          ))}\n          \n          {/* Axes */}\n          <line x1={xScale(xMin)} y1={yScale(0)} x2={xScale(xMax)} y2={yScale(0)} stroke={theme.colors.textMuted} strokeWidth=\"2\" />\n          <line x1={xScale(0)} y1={yScale(yMin)} x2={xScale(0)} y2={yScale(yMax)} stroke={theme.colors.textMuted} strokeWidth=\"2\" />\n          \n          {/* Axis labels */}\n          <text x={xScale(xMax) + 5} y={yScale(0) + 4} fill={theme.colors.textMuted} fontSize=\"11\">z</text>\n          <text x={xScale(0) + 5} y={yScale(yMax) - 5} fill={theme.colors.textMuted} fontSize=\"11\">f(z)</text>\n          \n          {/* Tick labels */}\n          {[-4, -2, 2, 4].map(x => (\n            <text key={`tx-${x}`} x={xScale(x)} y={yScale(0) + 15} fill={theme.colors.textMuted} fontSize=\"9\" textAnchor=\"middle\">{x}</text>\n          ))}\n          {[1, 2, 3, 4].map(y => (\n            <text key={`ty-${y}`} x={xScale(0) - 10} y={yScale(y) + 3} fill={theme.colors.textMuted} fontSize=\"9\" textAnchor=\"end\">{y}</text>\n          ))}\n\n          {/* ReLU curve (for comparison) */}\n          <path\n            d={reluCurve.map((p, i) => `${i === 0 ? 'M' : 'L'} ${xScale(p.x)} ${yScale(p.y)}`).join(' ')}\n            fill=\"none\"\n            stroke={theme.colors.textMuted}\n            strokeWidth=\"2\"\n            strokeDasharray=\"6 4\"\n            opacity=\"0.5\"\n          />\n\n          {/* Leaky ReLU curve */}\n          <path\n            d={leakyReluCurve.map((p, i) => `${i === 0 ? 'M' : 'L'} ${xScale(p.x)} ${yScale(p.y)}`).join(' ')}\n            fill=\"none\"\n            stroke={theme.colors.yellow}\n            strokeWidth=\"3\"\n          />\n\n          {/* Dead zone indicator for ReLU */}\n          <rect \n            x={xScale(xMin)} \n            y={yScale(0)} \n            width={xScale(0) - xScale(xMin)} \n            height={yScale(yMin) - yScale(0)} \n            fill={theme.colors.negative} \n            opacity=\"0.1\" \n          />\n\n          {/* Hover point */}\n          {hoveredX !== null && (\n            <g>\n              <line x1={xScale(hoveredX)} y1={yScale(yMin)} x2={xScale(hoveredX)} y2={yScale(yMax)} stroke={theme.colors.primary} strokeWidth=\"1\" strokeDasharray=\"4\" />\n              <circle cx={xScale(hoveredX)} cy={yScale(leakyRelu(hoveredX, alpha))} r=\"6\" fill={theme.colors.yellow} />\n              <circle cx={xScale(hoveredX)} cy={yScale(relu(hoveredX))} r=\"4\" fill={theme.colors.textMuted} opacity=\"0.5\" />\n            </g>\n          )}\n\n          {/* Current input point */}\n          <circle cx={xScale(inputZ)} cy={yScale(output)} r=\"8\" fill={theme.colors.orange} stroke={theme.colors.background} strokeWidth=\"2\" />\n        </svg>\n\n        {/* Legend */}\n        <div style={{ display: 'flex', gap: '20px', justifyContent: 'center', marginTop: '12px', fontSize: '11px' }}>\n          <span><span style={{ color: theme.colors.yellow }}>━━</span> Leaky ReLU</span>\n          <span><span style={{ color: theme.colors.textMuted }}>┅┅</span> ReLU</span>\n          <span style={{ color: theme.colors.negative, opacity: 0.7 }}>■ Dead zone (ReLU)</span>\n        </div>\n\n        {/* Hover info */}\n        {hoveredX !== null && (\n          <div style={{ textAlign: 'center', marginTop: '8px', fontSize: '11px', color: theme.colors.textSecondary }}>\n            z = {hoveredX.toFixed(2)} → Leaky ReLU: <span style={{ color: theme.colors.yellow }}>{leakyRelu(hoveredX, alpha).toFixed(3)}</span>\n            {' | '} ReLU: <span style={{ color: theme.colors.textMuted }}>{relu(hoveredX).toFixed(3)}</span>\n          </div>\n        )}\n      </div>\n\n      {/* Controls */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '16px', marginBottom: '12px' }}>\n        <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap' }}>\n          {/* Alpha slider */}\n          <div style={{ flex: 1, minWidth: '140px' }}>\n            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}>\n              <span style={{ fontSize: '12px', color: theme.colors.orange }}>α (leak slope)</span>\n              <span style={{ fontSize: '12px', fontWeight: '600' }}>{alpha.toFixed(2)}</span>\n            </div>\n            <input \n              type=\"range\" \n              min=\"0.01\" \n              max=\"0.5\" \n              step=\"0.01\" \n              value={alpha}\n              onChange={(e) => setAlpha(parseFloat(e.target.value))}\n              style={{ width: '100%', accentColor: theme.colors.orange }}\n            />\n            <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>\n              Default: 0.01 | Higher = steeper negative slope\n            </div>\n          </div>\n\n          {/* Input z slider */}\n          <div style={{ flex: 1, minWidth: '140px' }}>\n            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}>\n              <span style={{ fontSize: '12px', color: theme.colors.primary }}>Input z</span>\n              <span style={{ fontSize: '12px', fontWeight: '600' }}>{inputZ.toFixed(1)}</span>\n            </div>\n            <input \n              type=\"range\" \n              min=\"-5\" \n              max=\"5\" \n              step=\"0.1\" \n              value={inputZ}\n              onChange={(e) => setInputZ(parseFloat(e.target.value))}\n              style={{ width: '100%', accentColor: theme.colors.primary }}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Output comparison */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '16px', marginBottom: '12px' }}>\n        <div style={{ fontSize: '12px', color: theme.colors.textMuted, marginBottom: '10px', textAlign: 'center' }}>\n          For z = <span style={{ color: theme.colors.primary, fontWeight: '600' }}>{inputZ.toFixed(1)}</span>\n        </div>\n        <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', flexWrap: 'wrap' }}>\n          <OutputBox \n            label=\"Leaky ReLU\" \n            value={output} \n            color={theme.colors.yellow}\n            formula={inputZ > 0 ? `${inputZ.toFixed(1)}` : `${alpha} × ${inputZ.toFixed(1)}`}\n          />\n          <OutputBox \n            label=\"Standard ReLU\" \n            value={reluOutput} \n            color={theme.colors.textMuted}\n            formula={inputZ > 0 ? `${inputZ.toFixed(1)}` : `max(0, ${inputZ.toFixed(1)})`}\n            isDead={inputZ <= 0}\n          />\n        </div>\n      </div>\n\n      {/* Key insight */}\n      <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '14px' }}>\n        <div style={{ fontSize: '12px', color: theme.colors.textSecondary, lineHeight: 1.7, textAlign: 'center' }}>\n          <strong style={{ color: theme.colors.negative }}>The Problem:</strong> ReLU outputs <strong>0</strong> for all negative inputs → gradient = 0 → neuron stops learning (\"dies\")\n          <br/><br/>\n          <strong style={{ color: theme.colors.positive }}>The Solution:</strong> Leaky ReLU multiplies negative inputs by small <strong style={{ color: theme.colors.orange }}>α</strong> → small gradient survives → neuron keeps learning!\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction OutputBox({ label, value, color, formula, isDead }) {\n  return (\n    <div style={{\n      padding: '14px 20px',\n      background: isDead ? `${theme.colors.negative}15` : theme.colors.surfaceAlt,\n      border: `2px solid ${isDead ? theme.colors.negative : color}`,\n      borderRadius: '10px',\n      textAlign: 'center',\n      minWidth: '130px',\n    }}>\n      <div style={{ fontSize: '11px', color, marginBottom: '4px' }}>{label}</div>\n      <div style={{ fontSize: '24px', fontWeight: '700', color: isDead ? theme.colors.negative : theme.colors.text }}>\n        {value.toFixed(3)}\n      </div>\n      <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '4px' }}>\n        {formula}\n      </div>\n      {isDead && (\n        <div style={{ fontSize: '9px', color: theme.colors.negative, marginTop: '4px' }}>\n          ⚠️ Dead neuron!\n        </div>\n      )}\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}