{
  "problem_id": 21,
  "title": "Pegasos Kernel SVM Implementation",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst initialExamples = [\n  {\n    name: 'Linear',\n    data: [[1, 2], [2, 3], [2, 1], [3, 2], [5, 5], [6, 4], [5, 6], [6, 6]],\n    labels: [1, 1, 1, 1, -1, -1, -1, -1],\n  },\n  {\n    name: 'XOR',\n    data: [[1, 1], [2, 2], [1, 5], [2, 4], [5, 1], [4, 2], [5, 5], [4, 4]],\n    labels: [1, 1, -1, -1, -1, -1, 1, 1],\n  },\n  {\n    name: 'Cluster',\n    data: [[3, 3], [3.5, 3.5], [2.5, 3.5], [3.5, 2.5], [1, 1], [6, 6], [1, 6], [6, 1]],\n    labels: [1, 1, 1, 1, -1, -1, -1, -1],\n  },\n];\n\nconst stepInfo = [\n  {\n    title: 'Explore the Data',\n    desc: 'Drag points to create your own dataset! Green (+1) and red (-1) are the two classes. Try making them overlap or separate them clearly.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'Step 1: Initialize and First Look',\n    desc: 'All alpha values start at 0, bias at 0. The kernel measures similarity between points. Linear: dot product. RBF: Gaussian similarity.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 2: First Training Iteration',\n    desc: 'Check each point: if y * f(x) < 1 (wrong side or too close to boundary), update its alpha and the bias. Watch points light up as they become support vectors!',\n    color: theme.colors.yellow,\n  },\n  {\n    title: 'Step 3: Second Iteration',\n    desc: 'Another pass through all points. The learning rate decreases (eta = 1/lambda*t). The boundary starts taking shape based on support vectors.',\n    color: theme.colors.pink,\n  },\n  {\n    title: 'Step 4: Train to Convergence',\n    desc: 'Now watch 50 iterations run automatically. The boundary stabilizes as the algorithm finds the optimal margin between classes.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Training Complete!',\n    desc: 'Points with glowing borders are support vectors (non-zero alphas). They alone define the decision boundary. Try the RBF kernel for non-linear separation!',\n    color: theme.colors.positive,\n  },\n];\n\nexport default function App() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [kernel, setKernel] = useState('linear');\n  const [data, setData] = useState([]);\n  const [labels, setLabels] = useState([]);\n  const [alphas, setAlphas] = useState([]);\n  const [bias, setBias] = useState(0);\n  const [iteration, setIteration] = useState(0);\n  const [iterating, setIterating] = useState(false);\n  const [dragging, setDragging] = useState(null);\n  const [violations, setViolations] = useState([]);\n  const canvasRef = useRef(null);\n\n  const totalSteps = 5;\n  const lambda_val = 0.01;\n  const sigma = 1.0;\n  const size = 300;\n  const padding = 25;\n  const plotSize = size - 2 * padding;\n  const bounds = { minX: 0, maxX: 7, minY: 0, maxY: 7 };\n\n  // Initialize when example changes\n  useEffect(() => {\n    const ex = initialExamples[exampleIdx];\n    setData(ex.data.map(p => [...p]));\n    setLabels([...ex.labels]);\n    setAlphas(new Array(ex.data.length).fill(0));\n    setBias(0);\n    setIteration(0);\n    setStep(0);\n    setIterating(false);\n    setViolations([]);\n  }, [exampleIdx]);\n\n  // Kernel functions\n  const linearKernel = (x, y) => x[0] * y[0] + x[1] * y[1];\n  \n  const rbfKernel = (x, y) => {\n    const diff0 = x[0] - y[0];\n    const diff1 = x[1] - y[1];\n    const norm = diff0 * diff0 + diff1 * diff1;\n    return Math.exp(-norm / (2 * sigma * sigma));\n  };\n\n  const getKernel = () => kernel === 'linear' ? linearKernel : rbfKernel;\n\n  // Compute decision value for a point\n  const computeDecision = (point, currentAlphas, currentBias) => {\n    const k = getKernel();\n    let sum = 0;\n    for (let j = 0; j < data.length; j++) {\n      sum += currentAlphas[j] * labels[j] * k(data[j], point);\n    }\n    return sum + currentBias;\n  };\n\n  // Run one full iteration\n  const runIteration = (currentAlphas, currentBias, t) => {\n    const newAlphas = [...currentAlphas];\n    let newBias = currentBias;\n    const eta = 1.0 / (lambda_val * t);\n    const k = getKernel();\n    const newViolations = [];\n\n    for (let i = 0; i < data.length; i++) {\n      let decision = 0;\n      for (let j = 0; j < data.length; j++) {\n        decision += newAlphas[j] * labels[j] * k(data[j], data[i]);\n      }\n      decision += newBias;\n\n      if (labels[i] * decision < 1) {\n        newAlphas[i] += eta * (labels[i] - lambda_val * newAlphas[i]);\n        newBias += eta * labels[i];\n        newViolations.push(i);\n      }\n    }\n\n    return { alphas: newAlphas, bias: newBias, violations: newViolations };\n  };\n\n  const reset = () => {\n    const ex = initialExamples[exampleIdx];\n    setData(ex.data.map(p => [...p]));\n    setLabels([...ex.labels]);\n    setAlphas(new Array(ex.data.length).fill(0));\n    setBias(0);\n    setIteration(0);\n    setStep(0);\n    setIterating(false);\n    setViolations([]);\n    setPlaying(false);\n  };\n\n  const next = () => {\n    if (step >= totalSteps) return;\n    \n    const newStep = step + 1;\n    setStep(newStep);\n    \n    if (newStep === 2) {\n      // First iteration\n      const result = runIteration(alphas, bias, 1);\n      setAlphas(result.alphas);\n      setBias(result.bias);\n      setViolations(result.violations);\n      setIteration(1);\n    } else if (newStep === 3) {\n      // Second iteration\n      const result = runIteration(alphas, bias, 2);\n      setAlphas(result.alphas);\n      setBias(result.bias);\n      setViolations(result.violations);\n      setIteration(2);\n    } else if (newStep === 4) {\n      // Start auto iterations\n      setIterating(true);\n    }\n  };\n\n  const prev = () => step > 0 && setStep(step - 1);\n\n  const auto = async () => {\n    setPlaying(true);\n    let curAlphas = [...alphas];\n    let curBias = bias;\n    let curIter = iteration;\n    \n    for (let s = step; s <= totalSteps; s++) {\n      setStep(s);\n      \n      if (s === 2 && curIter < 1) {\n        const result = runIteration(curAlphas, curBias, 1);\n        curAlphas = result.alphas;\n        curBias = result.bias;\n        setAlphas(curAlphas);\n        setBias(curBias);\n        setViolations(result.violations);\n        curIter = 1;\n        setIteration(1);\n      } else if (s === 3 && curIter < 2) {\n        const result = runIteration(curAlphas, curBias, 2);\n        curAlphas = result.alphas;\n        curBias = result.bias;\n        setAlphas(curAlphas);\n        setBias(curBias);\n        setViolations(result.violations);\n        curIter = 2;\n        setIteration(2);\n      } else if (s === 4) {\n        setIterating(true);\n      }\n      await new Promise(r => setTimeout(r, 1000));\n    }\n    setPlaying(false);\n  };\n\n  // Auto training loop\n  useEffect(() => {\n    if (!iterating || iteration >= 50) {\n      if (iteration >= 50) {\n        setIterating(false);\n        setStep(5);\n      }\n      return;\n    }\n\n    const timer = setTimeout(() => {\n      const t = iteration + 1;\n      const result = runIteration(alphas, bias, t);\n      setAlphas(result.alphas);\n      setBias(result.bias);\n      setViolations(result.violations);\n      setIteration(t);\n      \n      if (t >= 50) {\n        setIterating(false);\n        setStep(5);\n      }\n    }, 60);\n\n    return () => clearTimeout(timer);\n  }, [iterating, iteration, alphas, bias]);\n\n  // Mouse handlers for dragging\n  const getMousePos = (e) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    const dataX = bounds.minX + ((x - padding) / plotSize) * (bounds.maxX - bounds.minX);\n    const dataY = bounds.maxY - ((y - padding) / plotSize) * (bounds.maxY - bounds.minY);\n    \n    return [\n      Math.max(bounds.minX + 0.3, Math.min(bounds.maxX - 0.3, dataX)),\n      Math.max(bounds.minY + 0.3, Math.min(bounds.maxY - 0.3, dataY)),\n    ];\n  };\n\n  const handleMouseDown = (e) => {\n    if (step > 0) return;\n    const [mx, my] = getMousePos(e);\n    \n    let closest = null;\n    let minDist = 0.6;\n    data.forEach((p, i) => {\n      const d = Math.sqrt((p[0] - mx) ** 2 + (p[1] - my) ** 2);\n      if (d < minDist) {\n        minDist = d;\n        closest = i;\n      }\n    });\n    \n    if (closest !== null) {\n      setDragging(closest);\n    }\n  };\n\n  const handleMouseMove = (e) => {\n    if (dragging === null || step > 0) return;\n    const pos = getMousePos(e);\n    setData(prev => {\n      const newData = [...prev];\n      newData[dragging] = pos;\n      return newData;\n    });\n  };\n\n  const handleMouseUp = () => setDragging(null);\n\n  // Toggle label on double click\n  const handleDoubleClick = (e) => {\n    if (step > 0) return;\n    const [mx, my] = getMousePos(e);\n    \n    let closest = null;\n    let minDist = 0.6;\n    data.forEach((p, i) => {\n      const d = Math.sqrt((p[0] - mx) ** 2 + (p[1] - my) ** 2);\n      if (d < minDist) {\n        minDist = d;\n        closest = i;\n      }\n    });\n    \n    if (closest !== null) {\n      setLabels(prev => {\n        const newLabels = [...prev];\n        newLabels[closest] = -newLabels[closest];\n        return newLabels;\n      });\n    }\n  };\n\n  // Canvas drawing\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || data.length === 0) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    const scaleX = (x) => padding + ((x - bounds.minX) / (bounds.maxX - bounds.minX)) * plotSize;\n    const scaleY = (y) => size - padding - ((y - bounds.minY) / (bounds.maxY - bounds.minY)) * plotSize;\n\n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let i = 0; i <= 7; i++) {\n      const x = scaleX(i);\n      const y = scaleY(i);\n      ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, size - padding); ctx.stroke();\n      ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(size - padding, y); ctx.stroke();\n    }\n\n    // Decision boundary heatmap (show after step 1)\n    if (step >= 1) {\n      const resolution = 35;\n      const cellW = plotSize / resolution;\n      const cellH = plotSize / resolution;\n\n      for (let i = 0; i < resolution; i++) {\n        for (let j = 0; j < resolution; j++) {\n          const px = bounds.minX + ((i + 0.5) / resolution) * (bounds.maxX - bounds.minX);\n          const py = bounds.minY + ((j + 0.5) / resolution) * (bounds.maxY - bounds.minY);\n          const decision = computeDecision([px, py], alphas, bias);\n          \n          const intensity = Math.min(Math.abs(decision) / 2, 1);\n          if (decision > 0) {\n            ctx.fillStyle = `rgba(16, 185, 129, ${0.1 + intensity * 0.25})`;\n          } else {\n            ctx.fillStyle = `rgba(244, 63, 94, ${0.1 + intensity * 0.25})`;\n          }\n          ctx.fillRect(\n            padding + i * cellW,\n            size - padding - (j + 1) * cellH,\n            cellW + 1,\n            cellH + 1\n          );\n        }\n      }\n\n      // Decision boundary contour\n      ctx.strokeStyle = theme.colors.primary;\n      ctx.lineWidth = 3;\n      for (let i = 0; i < resolution - 1; i++) {\n        for (let j = 0; j < resolution - 1; j++) {\n          const px = bounds.minX + ((i + 0.5) / resolution) * (bounds.maxX - bounds.minX);\n          const py = bounds.minY + ((j + 0.5) / resolution) * (bounds.maxY - bounds.minY);\n          const px2 = bounds.minX + ((i + 1.5) / resolution) * (bounds.maxX - bounds.minX);\n          const py2 = bounds.minY + ((j + 1.5) / resolution) * (bounds.maxY - bounds.minY);\n          \n          const d1 = computeDecision([px, py], alphas, bias);\n          const d2 = computeDecision([px2, py], alphas, bias);\n          const d3 = computeDecision([px, py2], alphas, bias);\n          \n          if ((d1 >= 0) !== (d2 >= 0)) {\n            ctx.beginPath();\n            ctx.arc(scaleX((px + px2) / 2), scaleY(py), 2, 0, Math.PI * 2);\n            ctx.fill();\n          }\n          if ((d1 >= 0) !== (d3 >= 0)) {\n            ctx.beginPath();\n            ctx.arc(scaleX(px), scaleY((py + py2) / 2), 2, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n      }\n    }\n\n    // Data points\n    data.forEach((point, i) => {\n      const isPositive = labels[i] === 1;\n      const hasAlpha = Math.abs(alphas[i]) > 0.01;\n      const isViolation = violations.includes(i);\n      const cx = scaleX(point[0]);\n      const cy = scaleY(point[1]);\n      \n      // Support vector glow\n      if (hasAlpha) {\n        ctx.fillStyle = (isPositive ? theme.colors.positive : theme.colors.negative) + '50';\n        ctx.beginPath();\n        ctx.arc(cx, cy, 18, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      \n      // Violation indicator\n      if (isViolation && step >= 2 && step <= 3) {\n        ctx.strokeStyle = theme.colors.yellow;\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(cx, cy, 14, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n      \n      // Point fill\n      ctx.fillStyle = isPositive ? theme.colors.positive : theme.colors.negative;\n      ctx.beginPath();\n      ctx.arc(cx, cy, 10, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Point border\n      ctx.strokeStyle = theme.colors.text;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      \n      // Label\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 12px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(isPositive ? '+' : '-', cx, cy);\n    });\n\n    // Drag hint\n    if (step === 0) {\n      ctx.fillStyle = theme.colors.textSecondary;\n      ctx.font = '9px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText('Drag to move, double-click to flip label', size / 2, size - 8);\n    }\n\n    // Kernel indicator\n    ctx.fillStyle = theme.colors.yellow;\n    ctx.font = 'bold 10px JetBrains Mono, monospace';\n    ctx.textAlign = 'right';\n    ctx.fillText(kernel.toUpperCase(), size - 8, 16);\n\n  }, [step, data, labels, alphas, bias, iteration, kernel, violations, dragging]);\n\n  const formatNum = (n) => n.toFixed(2);\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          Pegasos Kernel SVM\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          Train a support vector machine step by step\n        </div>\n      </div>\n\n      {/* Example & Kernel Selection */}\n      <div style={{ display: 'flex', gap: '8px', justifyContent: 'center', marginBottom: '12px', flexWrap: 'wrap' }}>\n        <div style={{ display: 'flex', gap: '4px' }}>\n          {initialExamples.map((e, idx) => (\n            <button\n              key={idx}\n              onClick={() => setExampleIdx(idx)}\n              style={{\n                padding: '5px 10px',\n                background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n                border: 'none',\n                borderRadius: '6px',\n                color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n                fontFamily: theme.font,\n                fontSize: '10px',\n                cursor: 'pointer',\n              }}\n            >\n              {e.name}\n            </button>\n          ))}\n        </div>\n        <div style={{ display: 'flex', gap: '4px' }}>\n          {['linear', 'rbf'].map(k => (\n            <button\n              key={k}\n              onClick={() => { setKernel(k); reset(); }}\n              style={{\n                padding: '5px 10px',\n                background: kernel === k ? theme.colors.yellow + '30' : theme.colors.surface,\n                border: `1px solid ${kernel === k ? theme.colors.yellow : theme.colors.border}`,\n                borderRadius: '4px',\n                color: kernel === k ? theme.colors.yellow : theme.colors.textSecondary,\n                fontFamily: theme.font,\n                fontSize: '10px',\n                cursor: 'pointer',\n              }}\n            >\n              {k.toUpperCase()}\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Visualization */}\n      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '12px' }}>\n        <canvas\n          ref={canvasRef}\n          width={size}\n          height={size}\n          style={{\n            borderRadius: '8px',\n            border: `2px solid ${step === 0 ? theme.colors.primary : theme.colors.border}`,\n            cursor: step === 0 ? 'grab' : 'default',\n          }}\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onDoubleClick={handleDoubleClick}\n        />\n      </div>\n\n      {/* Stats Display */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        gap: '8px',\n        marginBottom: '12px',\n        flexWrap: 'wrap',\n      }}>\n        <div style={{\n          padding: '5px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n          border: '1px solid ' + theme.colors.blue,\n        }}>\n          <span style={{ fontSize: '8px', color: theme.colors.textMuted }}>bias</span>\n          <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.blue }}>\n            {formatNum(bias)}\n          </div>\n        </div>\n        <div style={{\n          padding: '5px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n        }}>\n          <span style={{ fontSize: '8px', color: theme.colors.textMuted }}>iter</span>\n          <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.primary }}>\n            {iteration}\n          </div>\n        </div>\n        <div style={{\n          padding: '5px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n          border: '1px solid ' + theme.colors.pink,\n        }}>\n          <span style={{ fontSize: '8px', color: theme.colors.textMuted }}>SVs</span>\n          <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.pink }}>\n            {alphas.filter(a => Math.abs(a) > 0.01).length}\n          </div>\n        </div>\n        {step >= 2 && step <= 3 && (\n          <div style={{\n            padding: '5px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n            border: '1px solid ' + theme.colors.yellow,\n          }}>\n            <span style={{ fontSize: '8px', color: theme.colors.textMuted }}>violations</span>\n            <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.yellow }}>\n              {violations.length}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Alpha Values */}\n      <div style={{\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        padding: '8px',\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginBottom: '6px' }}>\n          Alpha values {step >= 2 ? '(yellow ring = updated this iteration)' : ''}\n        </div>\n        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', justifyContent: 'center' }}>\n          {alphas.map((a, i) => (\n            <div key={i} style={{\n              padding: '4px 8px',\n              background: Math.abs(a) > 0.01 \n                ? (labels[i] === 1 ? theme.colors.positive : theme.colors.negative) + '30' \n                : theme.colors.surfaceAlt,\n              border: `2px solid ${\n                violations.includes(i) && step >= 2 && step <= 3\n                  ? theme.colors.yellow\n                  : Math.abs(a) > 0.01 \n                    ? (labels[i] === 1 ? theme.colors.positive : theme.colors.negative) \n                    : theme.colors.border\n              }`,\n              borderRadius: '4px',\n              fontSize: '10px',\n              color: Math.abs(a) > 0.01 ? theme.colors.text : theme.colors.textMuted,\n              minWidth: '45px',\n              textAlign: 'center',\n            }}>\n              {formatNum(a)}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0 || playing}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps || playing || iterating}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps || iterating ? 0.5 : 1,\n          }}\n        >\n          {step === 0 ? 'Start Training' : \n           step === 1 ? 'Run Iteration 1' :\n           step === 2 ? 'Run Iteration 2' :\n           step === 3 ? 'Train to 50' :\n           iterating ? `Training... (${iteration}/50)` : 'Complete!'}\n        </button>\n        <button\n          onClick={auto}\n          disabled={playing || step >= totalSteps || iterating}\n          style={{\n            padding: '8px 12px',\n            background: playing ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: playing ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: playing ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {playing || iterating ? '...' : '>>'}\n        </button>\n        <button\n          onClick={reset}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        Only support vectors (glowing points) determine the boundary. The RBF kernel enables non-linear separation by measuring Gaussian similarity.\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}