{
  "problem_id": 20,
  "title": "Decision Tree Learning",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst examples = [\n  {\n    name: 'Play Tennis',\n    data: [\n      { Outlook: 'Sunny', Wind: 'Weak', PlayTennis: 'No' },\n      { Outlook: 'Overcast', Wind: 'Strong', PlayTennis: 'Yes' },\n      { Outlook: 'Rain', Wind: 'Weak', PlayTennis: 'Yes' },\n      { Outlook: 'Sunny', Wind: 'Strong', PlayTennis: 'No' },\n      { Outlook: 'Sunny', Wind: 'Weak', PlayTennis: 'Yes' },\n      { Outlook: 'Overcast', Wind: 'Weak', PlayTennis: 'Yes' },\n      { Outlook: 'Rain', Wind: 'Strong', PlayTennis: 'No' },\n      { Outlook: 'Rain', Wind: 'Weak', PlayTennis: 'Yes' },\n    ],\n    attributes: ['Outlook', 'Wind'],\n    target: 'PlayTennis',\n  },\n  {\n    name: 'Simple',\n    data: [\n      { Color: 'Red', Size: 'Big', Buy: 'No' },\n      { Color: 'Red', Size: 'Small', Buy: 'No' },\n      { Color: 'Blue', Size: 'Big', Buy: 'Yes' },\n      { Color: 'Blue', Size: 'Small', Buy: 'Yes' },\n      { Color: 'Green', Size: 'Big', Buy: 'Yes' },\n      { Color: 'Green', Size: 'Small', Buy: 'No' },\n    ],\n    attributes: ['Color', 'Size'],\n    target: 'Buy',\n  },\n];\n\nconst stepInfo = [\n  {\n    title: 'Dataset Overview',\n    desc: 'We have examples with attributes and a target label. Our goal: build a tree that predicts the target by asking questions about attributes.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'Step 1: Calculate Entropy of Target',\n    desc: 'Entropy measures uncertainty. High entropy means mixed labels (hard to predict). Low entropy means mostly one class (easy to predict).',\n    color: theme.colors.yellow,\n  },\n  {\n    title: 'Step 2: Calculate Information Gain',\n    desc: 'For each attribute, calculate how much splitting reduces entropy. Higher gain = better attribute for splitting. We pick the best one.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 3: Split on Best Attribute',\n    desc: 'Create a node for the attribute with highest information gain. Each unique value becomes a branch. Data flows down based on attribute values.',\n    color: theme.colors.pink,\n  },\n  {\n    title: 'Step 4: Recurse on Subsets',\n    desc: 'For each branch, repeat the process on the subset of data. Stop when all examples have the same label (pure leaf) or no attributes remain.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Complete Decision Tree',\n    desc: 'The tree is built! To classify a new example, start at the root and follow branches based on attribute values until reaching a leaf (prediction).',\n    color: theme.colors.positive,\n  },\n];\n\nexport default function App() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [tree, setTree] = useState(null);\n  const [buildStage, setBuildStage] = useState(0);\n\n  const totalSteps = 5;\n  const ex = examples[exampleIdx];\n\n  // Entropy calculation\n  const calcEntropy = (data, target) => {\n    if (data.length === 0) return 0;\n    const counts = {};\n    data.forEach(d => { counts[d[target]] = (counts[d[target]] || 0) + 1; });\n    let entropy = 0;\n    Object.values(counts).forEach(c => {\n      const p = c / data.length;\n      if (p > 0) entropy -= p * Math.log2(p);\n    });\n    return entropy;\n  };\n\n  // Information gain\n  const calcInfoGain = (data, attr, target) => {\n    const totalEntropy = calcEntropy(data, target);\n    const values = [...new Set(data.map(d => d[attr]))];\n    let remainder = 0;\n    values.forEach(v => {\n      const subset = data.filter(d => d[attr] === v);\n      remainder += (subset.length / data.length) * calcEntropy(subset, target);\n    });\n    return totalEntropy - remainder;\n  };\n\n  // Build decision tree\n  const buildTree = (data, attrs, target, depth = 0) => {\n    if (data.length === 0) return { label: '?' };\n    \n    const labels = data.map(d => d[target]);\n    const uniqueLabels = [...new Set(labels)];\n    \n    if (uniqueLabels.length === 1) {\n      return { label: uniqueLabels[0] };\n    }\n    \n    if (attrs.length === 0) {\n      const counts = {};\n      labels.forEach(l => { counts[l] = (counts[l] || 0) + 1; });\n      const majority = Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];\n      return { label: majority };\n    }\n    \n    // Find best attribute\n    let bestAttr = attrs[0];\n    let bestGain = -1;\n    attrs.forEach(attr => {\n      const gain = calcInfoGain(data, attr, target);\n      if (gain > bestGain) {\n        bestGain = gain;\n        bestAttr = attr;\n      }\n    });\n    \n    const values = [...new Set(data.map(d => d[bestAttr]))];\n    const children = {};\n    values.forEach(v => {\n      const subset = data.filter(d => d[bestAttr] === v);\n      const remainingAttrs = attrs.filter(a => a !== bestAttr);\n      children[v] = buildTree(subset, remainingAttrs, target, depth + 1);\n    });\n    \n    return { attr: bestAttr, children, gain: bestGain };\n  };\n\n  // Build tree when example changes\n  useEffect(() => {\n    const fullTree = buildTree(ex.data, ex.attributes, ex.target);\n    setTree(fullTree);\n    setStep(0);\n    setBuildStage(0);\n  }, [exampleIdx]);\n\n  const reset = () => {\n    setStep(0);\n    setBuildStage(0);\n    setPlaying(false);\n  };\n\n  const next = () => {\n    if (step < totalSteps) {\n      const newStep = step + 1;\n      setStep(newStep);\n      if (newStep >= 3) {\n        setBuildStage(Math.min(newStep - 2, 3));\n      }\n    }\n  };\n\n  const prev = () => {\n    if (step > 0) {\n      const newStep = step - 1;\n      setStep(newStep);\n      if (newStep >= 3) {\n        setBuildStage(Math.max(newStep - 2, 0));\n      } else {\n        setBuildStage(0);\n      }\n    }\n  };\n\n  const auto = async () => {\n    setPlaying(true);\n    for (let s = step; s <= totalSteps; s++) {\n      setStep(s);\n      if (s >= 3) setBuildStage(Math.min(s - 2, 3));\n      await new Promise(r => setTimeout(r, 1500));\n    }\n    setPlaying(false);\n  };\n\n  // Calculate stats for display\n  const totalEntropy = calcEntropy(ex.data, ex.target);\n  const gains = ex.attributes.map(attr => ({\n    attr,\n    gain: calcInfoGain(ex.data, attr, ex.target),\n  })).sort((a, b) => b.gain - a.gain);\n\n  // Tree component with SVG lines\n  const TreeVisualization = ({ tree, maxDepth }) => {\n    if (!tree) return null;\n    \n    const nodeWidth = 70;\n    const nodeHeight = 32;\n    const levelHeight = 80;\n    const padding = 20;\n    \n    // Calculate positions for each node\n    const positionTree = (node, depth = 0, left = 0, right = 400) => {\n      if (!node || depth > maxDepth) return null;\n      \n      const x = (left + right) / 2;\n      const y = padding + depth * levelHeight;\n      const isLeaf = node.label !== undefined;\n      \n      const positioned = {\n        ...node,\n        x,\n        y,\n        isLeaf,\n        children: {},\n      };\n      \n      if (!isLeaf && node.children && depth < maxDepth) {\n        const childEntries = Object.entries(node.children);\n        const childWidth = (right - left) / childEntries.length;\n        \n        childEntries.forEach(([value, child], i) => {\n          const childLeft = left + i * childWidth;\n          const childRight = childLeft + childWidth;\n          positioned.children[value] = positionTree(child, depth + 1, childLeft, childRight);\n        });\n      }\n      \n      return positioned;\n    };\n    \n    const positionedTree = positionTree(tree);\n    \n    // Collect all nodes and edges for rendering\n    const collectNodes = (node, edges = [], nodes = []) => {\n      if (!node) return { nodes, edges };\n      \n      nodes.push(node);\n      \n      if (!node.isLeaf && node.children) {\n        Object.entries(node.children).forEach(([value, child]) => {\n          if (child) {\n            edges.push({\n              from: { x: node.x, y: node.y + nodeHeight / 2 },\n              to: { x: child.x, y: child.y - nodeHeight / 2 },\n              label: value,\n            });\n            collectNodes(child, edges, nodes);\n          }\n        });\n      }\n      \n      return { nodes, edges };\n    };\n    \n    const { nodes, edges } = collectNodes(positionedTree);\n    const treeDepth = Math.max(...nodes.map(n => n.y)) + nodeHeight + padding;\n    \n    return (\n      <svg width=\"100%\" height={treeDepth} viewBox={`0 0 400 ${treeDepth}`} style={{ minHeight: '150px' }}>\n        {/* Draw edges first (behind nodes) */}\n        {edges.map((edge, i) => {\n          const midY = (edge.from.y + edge.to.y) / 2;\n          return (\n            <g key={i}>\n              {/* Curved line */}\n              <path\n                d={`M ${edge.from.x} ${edge.from.y} \n                    C ${edge.from.x} ${midY}, \n                      ${edge.to.x} ${midY}, \n                      ${edge.to.x} ${edge.to.y}`}\n                fill=\"none\"\n                stroke={theme.colors.border}\n                strokeWidth=\"2\"\n              />\n              {/* Edge label */}\n              <rect\n                x={(edge.from.x + edge.to.x) / 2 - 20}\n                y={midY - 8}\n                width=\"40\"\n                height=\"16\"\n                fill={theme.colors.surface}\n                rx=\"4\"\n              />\n              <text\n                x={(edge.from.x + edge.to.x) / 2}\n                y={midY + 4}\n                textAnchor=\"middle\"\n                fill={theme.colors.textSecondary}\n                fontSize=\"10\"\n                fontFamily={theme.font}\n              >\n                {edge.label}\n              </text>\n            </g>\n          );\n        })}\n        \n        {/* Draw nodes */}\n        {nodes.map((node, i) => {\n          const nodeColor = node.isLeaf \n            ? (node.label === 'Yes' ? theme.colors.positive : theme.colors.negative)\n            : theme.colors.primary;\n          \n          return (\n            <g key={i}>\n              {/* Node background */}\n              <rect\n                x={node.x - nodeWidth / 2}\n                y={node.y - nodeHeight / 2}\n                width={nodeWidth}\n                height={nodeHeight}\n                fill={node.isLeaf ? nodeColor + '30' : theme.colors.surfaceAlt}\n                stroke={nodeColor}\n                strokeWidth=\"2\"\n                rx={node.isLeaf ? 16 : 6}\n              />\n              {/* Node text */}\n              <text\n                x={node.x}\n                y={node.y + 4}\n                textAnchor=\"middle\"\n                fill={node.isLeaf ? nodeColor : theme.colors.text}\n                fontSize=\"11\"\n                fontWeight=\"600\"\n                fontFamily={theme.font}\n              >\n                {node.isLeaf ? node.label : node.attr + '?'}\n              </text>\n            </g>\n          );\n        })}\n      </svg>\n    );\n  };\n\n  const formatNum = (n) => n.toFixed(3);\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          Decision Tree Learning\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          Build a classifier using entropy and information gain\n        </div>\n      </div>\n\n      {/* Example Tabs */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '12px' }}>\n        {examples.map((e, idx) => (\n          <button\n            key={idx}\n            onClick={() => setExampleIdx(idx)}\n            style={{\n              padding: '6px 12px',\n              background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n              border: 'none',\n              borderRadius: '6px',\n              color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n            }}\n          >\n            {e.name}\n          </button>\n        ))}\n      </div>\n\n      {/* Data Table */}\n      <div style={{\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        padding: '10px',\n        marginBottom: '12px',\n        overflowX: 'auto',\n      }}>\n        <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '6px' }}>\n          Training Data ({ex.data.length} examples)\n        </div>\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>\n          {/* Header */}\n          <div style={{ display: 'flex', gap: '4px' }}>\n            {[...ex.attributes, ex.target].map(attr => (\n              <div key={attr} style={{\n                flex: 1,\n                padding: '4px 6px',\n                background: attr === ex.target ? theme.colors.yellow + '30' : theme.colors.surfaceAlt,\n                borderRadius: '4px',\n                fontSize: '9px',\n                fontWeight: '600',\n                textAlign: 'center',\n                color: attr === ex.target ? theme.colors.yellow : theme.colors.text,\n                minWidth: '60px',\n              }}>\n                {attr}\n              </div>\n            ))}\n          </div>\n          {/* Rows */}\n          {ex.data.map((row, i) => (\n            <div key={i} style={{ display: 'flex', gap: '4px' }}>\n              {[...ex.attributes, ex.target].map(attr => (\n                <div key={attr} style={{\n                  flex: 1,\n                  padding: '3px 6px',\n                  background: theme.colors.background,\n                  borderRadius: '3px',\n                  fontSize: '9px',\n                  textAlign: 'center',\n                  color: attr === ex.target \n                    ? (row[attr] === 'Yes' ? theme.colors.positive : theme.colors.negative)\n                    : theme.colors.textSecondary,\n                  minWidth: '60px',\n                }}>\n                  {row[attr]}\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Entropy & Info Gain Display */}\n      {step >= 1 && (\n        <div style={{\n          background: theme.colors.surface,\n          borderRadius: '8px',\n          padding: '10px',\n          marginBottom: '12px',\n        }}>\n          {step >= 1 && (\n            <div style={{ marginBottom: step >= 2 ? '10px' : 0 }}>\n              <div style={{ fontSize: '10px', color: theme.colors.yellow, fontWeight: '600', marginBottom: '4px' }}>\n                Target Entropy ({ex.target})\n              </div>\n              <div style={{\n                display: 'flex',\n                alignItems: 'center',\n                gap: '8px',\n              }}>\n                <div style={{\n                  flex: 1,\n                  height: '8px',\n                  background: theme.colors.surfaceAlt,\n                  borderRadius: '4px',\n                  overflow: 'hidden',\n                }}>\n                  <div style={{\n                    width: `${totalEntropy * 100}%`,\n                    height: '100%',\n                    background: theme.colors.yellow,\n                    transition: 'width 0.5s',\n                  }} />\n                </div>\n                <span style={{ fontSize: '11px', color: theme.colors.yellow, fontWeight: '600' }}>\n                  {formatNum(totalEntropy)}\n                </span>\n              </div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                {totalEntropy > 0.9 ? 'High entropy: mixed labels, hard to predict' :\n                 totalEntropy > 0.5 ? 'Medium entropy: some mixing' :\n                 'Low entropy: mostly pure'}\n              </div>\n            </div>\n          )}\n\n          {step >= 2 && (\n            <div>\n              <div style={{ fontSize: '10px', color: theme.colors.blue, fontWeight: '600', marginBottom: '6px' }}>\n                Information Gain per Attribute\n              </div>\n              {gains.map((g, i) => (\n                <div key={g.attr} style={{ marginBottom: '6px' }}>\n                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n                    <span style={{ \n                      fontSize: '10px', \n                      color: i === 0 ? theme.colors.pink : theme.colors.textSecondary,\n                      fontWeight: i === 0 ? '600' : '400',\n                      minWidth: '60px',\n                    }}>\n                      {g.attr} {i === 0 && '(best)'}\n                    </span>\n                    <div style={{\n                      flex: 1,\n                      height: '6px',\n                      background: theme.colors.surfaceAlt,\n                      borderRadius: '3px',\n                      overflow: 'hidden',\n                    }}>\n                      <div style={{\n                        width: `${(g.gain / Math.max(...gains.map(x => x.gain))) * 100}%`,\n                        height: '100%',\n                        background: i === 0 ? theme.colors.pink : theme.colors.blue,\n                        transition: 'width 0.5s',\n                      }} />\n                    </div>\n                    <span style={{ fontSize: '10px', color: theme.colors.blue }}>\n                      {formatNum(g.gain)}\n                    </span>\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Decision Tree Visualization */}\n      {step >= 3 && tree && (\n        <div style={{\n          background: theme.colors.surface,\n          borderRadius: '8px',\n          padding: '12px',\n          marginBottom: '12px',\n        }}>\n          <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '8px', textAlign: 'center' }}>\n            Decision Tree\n          </div>\n          <TreeVisualization tree={tree} maxDepth={buildStage} />\n        </div>\n      )}\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            onClick={() => {\n              setStep(i);\n              if (i >= 3) setBuildStage(Math.min(i - 2, 3));\n              else setBuildStage(0);\n            }}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              cursor: 'pointer',\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0 || playing}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps || playing}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps ? 0.5 : 1,\n          }}\n        >\n          {step === 0 ? 'Start' : step < totalSteps ? 'Next Step' : 'Complete!'}\n        </button>\n        <button\n          onClick={auto}\n          disabled={playing || step >= totalSteps}\n          style={{\n            padding: '8px 12px',\n            background: playing ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: playing ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: playing ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {playing ? '...' : '>>'}\n        </button>\n        <button\n          onClick={reset}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Algorithm Details */}\n      {step >= 1 && (\n        <div style={{\n          padding: '10px',\n          background: theme.colors.surfaceAlt,\n          borderRadius: '8px',\n          marginBottom: '12px',\n        }}>\n          {step === 1 && (\n            <div>\n              <div style={{ fontSize: '10px', color: theme.colors.yellow, fontWeight: '600', marginBottom: '4px' }}>\n                Entropy Formula\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                H = -sum(p * log2(p)) for each class proportion p\n              </div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                Entropy ranges from 0 (pure) to 1 (50/50 split for binary)\n              </div>\n            </div>\n          )}\n\n          {step === 2 && (\n            <div>\n              <div style={{ fontSize: '10px', color: theme.colors.blue, fontWeight: '600', marginBottom: '4px' }}>\n                Information Gain Formula\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                IG = H(parent) - weighted_avg(H(children))\n              </div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                Higher gain means better split - reduces uncertainty more\n              </div>\n            </div>\n          )}\n\n          {step >= 3 && step < 5 && (\n            <div>\n              <div style={{ fontSize: '10px', color: theme.colors.pink, fontWeight: '600', marginBottom: '4px' }}>\n                Building the Tree\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                Root splits on \"{gains[0]?.attr}\" (gain = {formatNum(gains[0]?.gain || 0)})\n              </div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                Each branch recursively finds the next best attribute to split on\n              </div>\n            </div>\n          )}\n\n          {step === 5 && (\n            <div>\n              <div style={{ fontSize: '10px', color: theme.colors.positive, fontWeight: '600', marginBottom: '4px' }}>\n                Tree Complete\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                Leaves show predictions. Follow branches to classify new examples.\n              </div>\n              <div style={{ fontSize: '9px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                This tree perfectly classifies all training examples\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        Decision trees greedily select attributes that maximize information gain, splitting data until leaves are pure or no attributes remain.\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}