{
  "problem_id": 40,
  "title": "Implementing a Custom Dense Layer in Python",
  "category": "Deep Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n    red: '#f87171',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nexport default function App() {\n  const [inputs, setInputs] = useState([2.0, 1.0]);\n  const [W, setW] = useState([[0.5, -0.3], [0.2, 0.8]]);\n  const [b, setB] = useState([0.1, -0.1]);\n  const [mode, setMode] = useState('forward');\n  const [hoveredConn, setHoveredConn] = useState(null);\n  const [dragging, setDragging] = useState(null);\n\n  // Forward pass: y = Wx + b\n  const Y = [\n    inputs[0] * W[0][0] + inputs[1] * W[1][0] + b[0],\n    inputs[0] * W[0][1] + inputs[1] * W[1][1] + b[1],\n  ];\n\n  // Backward pass\n  const dL_dY = [0.5, -0.4];\n  const dL_dW = [\n    [inputs[0] * dL_dY[0], inputs[0] * dL_dY[1]],\n    [inputs[1] * dL_dY[0], inputs[1] * dL_dY[1]],\n  ];\n  const dL_dX = [\n    W[0][0] * dL_dY[0] + W[0][1] * dL_dY[1],\n    W[1][0] * dL_dY[0] + W[1][1] * dL_dY[1],\n  ];\n\n  const lr = 0.1;\n\n  const updateWeight = (i, j, delta) => {\n    const newW = W.map(row => [...row]);\n    newW[i][j] = Math.round((newW[i][j] + delta) * 10) / 10;\n    newW[i][j] = Math.max(-1, Math.min(1, newW[i][j]));\n    setW(newW);\n  };\n\n  const applyGradient = () => {\n    setW(W.map((row, i) => row.map((w, j) => \n      Math.round((w - lr * dL_dW[i][j]) * 100) / 100\n    )));\n  };\n\n  // Layout - more spread out\n  const svgW = 360, svgH = 200;\n  const inX = 55, outX = 305;\n  const yPos = [55, 145];\n  const r = 28;\n\n  // Weight positions - well separated\n  const getWPos = (i, j) => {\n    const t = [[0.28, 0.72], [0.72, 0.28]][i][j];\n    return {\n      x: inX + r + (outX - r - inX - r) * t,\n      y: yPos[i] + (yPos[j] - yPos[i]) * t,\n    };\n  };\n\n  const handleDrag = (e) => {\n    if (dragging === null) return;\n    const rect = e.currentTarget.getBoundingClientRect();\n    const y = e.clientY - rect.top;\n    const val = Math.round((1 - (y - 20) / (svgH - 40)) * 6 - 1) / 2;\n    const newInputs = [...inputs];\n    newInputs[dragging] = Math.max(-1, Math.min(3, val));\n    setInputs(newInputs);\n  };\n\n  return (\n    <div style={{ background: theme.colors.background, minHeight: '100vh', padding: '12px', fontFamily: theme.font, color: theme.colors.text, maxWidth: '440px' }}>\n      \n      {/* Header */}\n      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px' }}>\n        <div>\n          <div style={{ fontSize: '18px', fontWeight: '700' }}>Dense Layer</div>\n          <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>Drag inputs • Click weights</div>\n        </div>\n        <div style={{ display: 'flex', gap: '6px' }}>\n          <button onClick={() => setMode('forward')}\n            style={{ padding: '6px 12px', borderRadius: '6px', border: 'none', cursor: 'pointer',\n              background: mode === 'forward' ? theme.colors.blue : theme.colors.surface,\n              color: mode === 'forward' ? theme.colors.background : theme.colors.textSecondary,\n              fontSize: '12px', fontWeight: '600' }}>\n            Forward\n          </button>\n          <button onClick={() => setMode('backward')}\n            style={{ padding: '6px 12px', borderRadius: '6px', border: 'none', cursor: 'pointer',\n              background: mode === 'backward' ? theme.colors.orange : theme.colors.surface,\n              color: mode === 'backward' ? theme.colors.background : theme.colors.textSecondary,\n              fontSize: '12px', fontWeight: '600' }}>\n            Backward\n          </button>\n        </div>\n      </div>\n\n      {/* Network visualization */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '12px', marginBottom: '12px' }}>\n        <svg width={svgW} height={svgH}\n          onMouseMove={handleDrag}\n          onMouseUp={() => setDragging(null)}\n          onMouseLeave={() => setDragging(null)}>\n          \n          {/* Connections with weights */}\n          {[0, 1].map(i => [0, 1].map(j => {\n            const w = W[i][j];\n            const pos = getWPos(i, j);\n            const isHovered = hoveredConn?.i === i && hoveredConn?.j === j;\n            const contribution = inputs[i] * w;\n            const grad = dL_dW[i][j];\n            const isBackward = mode === 'backward';\n            \n            return (\n              <g key={`${i}-${j}`}>\n                {/* Thick invisible line for easier hover */}\n                <line x1={inX + r} y1={yPos[i]} x2={outX - r} y2={yPos[j]}\n                  stroke=\"transparent\"\n                  strokeWidth=\"20\"\n                  style={{ cursor: 'pointer' }}\n                  onMouseEnter={() => setHoveredConn({ i, j })}\n                  onMouseLeave={() => setHoveredConn(null)}\n                  onClick={() => updateWeight(i, j, 0.1)}\n                  onContextMenu={(e) => { e.preventDefault(); updateWeight(i, j, -0.1); }}\n                />\n                \n                {/* Visible line */}\n                <line x1={inX + r} y1={yPos[i]} x2={outX - r} y2={yPos[j]}\n                  stroke={isHovered ? theme.colors.yellow : (isBackward ? theme.colors.orange : theme.colors.textMuted)}\n                  strokeWidth={isHovered ? 6 : 4}\n                  opacity={isHovered ? 0.9 : 0.5}\n                  style={{ pointerEvents: 'none', transition: 'all 0.15s' }}\n                />\n                \n                {/* Weight box - larger */}\n                <g style={{ cursor: 'pointer' }}\n                  onClick={() => updateWeight(i, j, 0.1)}\n                  onContextMenu={(e) => { e.preventDefault(); updateWeight(i, j, -0.1); }}\n                  onMouseEnter={() => setHoveredConn({ i, j })}\n                  onMouseLeave={() => setHoveredConn(null)}>\n                  <rect x={pos.x - 28} y={pos.y - 14} width=\"56\" height=\"28\" rx=\"6\"\n                    fill={isBackward \n                      ? (grad > 0 ? theme.colors.red + '60' : theme.colors.green + '60')\n                      : (w >= 0 ? theme.colors.green + '50' : theme.colors.red + '50')}\n                    stroke={isHovered ? theme.colors.yellow : (isBackward ? theme.colors.orange : (w >= 0 ? theme.colors.green : theme.colors.red))}\n                    strokeWidth={isHovered ? 3 : 2}\n                    style={{ transition: 'all 0.15s' }}\n                  />\n                  <text x={pos.x} y={pos.y + 5} textAnchor=\"middle\" fontSize=\"15\" fontWeight=\"bold\"\n                    fill={isBackward ? theme.colors.orange : (w >= 0 ? theme.colors.green : theme.colors.red)}>\n                    {isBackward ? (grad >= 0 ? '+' : '') + grad.toFixed(2) : w.toFixed(2)}\n                  </text>\n                </g>\n                \n                {/* Hover tooltip - larger and more visible */}\n                {isHovered && !isBackward && (\n                  <g style={{ pointerEvents: 'none' }}>\n                    <rect x={pos.x - 60} y={pos.y - 42} width=\"120\" height=\"24\" rx=\"6\" \n                      fill={theme.colors.yellow} />\n                    <text x={pos.x} y={pos.y - 25} textAnchor=\"middle\" fontSize=\"13\" fontWeight=\"bold\" \n                      fill={theme.colors.background}>\n                      {inputs[i].toFixed(1)} × {w.toFixed(2)} = {contribution.toFixed(2)}\n                    </text>\n                  </g>\n                )}\n              </g>\n            );\n          }))}\n          \n          {/* Input neurons */}\n          {inputs.map((x, i) => (\n            <g key={`in-${i}`} style={{ cursor: 'ns-resize' }} onMouseDown={() => setDragging(i)}>\n              <circle cx={inX} cy={yPos[i]} r={r}\n                fill={mode === 'backward' ? theme.colors.pink + '30' : theme.colors.blue + '30'}\n                stroke={mode === 'backward' ? theme.colors.pink : theme.colors.blue}\n                strokeWidth={dragging === i ? 4 : 3} />\n              <text x={inX} y={yPos[i] + 6} textAnchor=\"middle\" fontSize=\"17\" fontWeight=\"bold\"\n                fill={mode === 'backward' ? theme.colors.pink : theme.colors.blue}>\n                {mode === 'backward' ? dL_dX[i].toFixed(2) : x.toFixed(1)}\n              </text>\n              <text x={14} y={yPos[i] + 5} fontSize=\"13\" fill={theme.colors.textMuted}>x{i}</text>\n            </g>\n          ))}\n          \n          {/* Output neurons */}\n          {Y.map((y, j) => (\n            <g key={`out-${j}`}>\n              <circle cx={outX} cy={yPos[j]} r={r}\n                fill={mode === 'backward' ? theme.colors.orange + '30' : theme.colors.green + '30'}\n                stroke={mode === 'backward' ? theme.colors.orange : theme.colors.green}\n                strokeWidth=\"3\" />\n              <text x={outX} y={yPos[j] + 6} textAnchor=\"middle\" fontSize=\"16\" fontWeight=\"bold\"\n                fill={mode === 'backward' ? theme.colors.orange : theme.colors.green}>\n                {mode === 'backward' ? dL_dY[j].toFixed(1) : y.toFixed(2)}\n              </text>\n              <text x={outX + 32} y={yPos[j] + 5} fontSize=\"13\" fill={theme.colors.textMuted}>y{j}</text>\n            </g>\n          ))}\n        </svg>\n      </div>\n\n      {/* Info panel below network */}\n      {mode === 'forward' ? (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n          \n          {/* Computation breakdown */}\n          <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '12px' }}>\n            <div style={{ fontSize: '12px', color: theme.colors.green, fontWeight: '600', marginBottom: '10px' }}>\n              y = W·x + b\n            </div>\n            {Y.map((y, j) => (\n              <div key={j} style={{ padding: '10px 12px', background: theme.colors.surfaceAlt, borderRadius: '8px', marginBottom: '8px', fontSize: '14px' }}>\n                <span style={{ color: theme.colors.green, fontWeight: '600' }}>y{j}</span>\n                <span style={{ color: theme.colors.textMuted }}> = </span>\n                <span style={{ color: theme.colors.blue }}>{inputs[0].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}>×</span>\n                <span style={{ color: W[0][j] >= 0 ? theme.colors.green : theme.colors.red }}>{W[0][j].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}> + </span>\n                <span style={{ color: theme.colors.blue }}>{inputs[1].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}>×</span>\n                <span style={{ color: W[1][j] >= 0 ? theme.colors.green : theme.colors.red }}>{W[1][j].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}> + </span>\n                <span style={{ color: theme.colors.orange }}>{b[j].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}> = </span>\n                <span style={{ color: theme.colors.green, fontWeight: '700', fontSize: '15px' }}>{y.toFixed(2)}</span>\n              </div>\n            ))}\n          </div>\n\n          {/* Bias controls */}\n          <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '12px', display: 'flex', gap: '20px', alignItems: 'center' }}>\n            <div style={{ fontSize: '12px', color: theme.colors.orange, fontWeight: '600' }}>Bias:</div>\n            {b.map((bias, j) => (\n              <div key={j} style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n                <span style={{ fontSize: '12px', color: theme.colors.textMuted }}>b{j}</span>\n                <button onClick={() => setB(b.map((v, k) => k === j ? Math.round((v - 0.1) * 10) / 10 : v))}\n                  style={{ width: '28px', height: '28px', background: theme.colors.surfaceAlt, border: 'none', borderRadius: '6px', color: theme.colors.text, cursor: 'pointer', fontSize: '16px' }}>−</button>\n                <span style={{ fontSize: '16px', fontWeight: '700', color: theme.colors.orange, minWidth: '40px', textAlign: 'center' }}>{bias.toFixed(1)}</span>\n                <button onClick={() => setB(b.map((v, k) => k === j ? Math.round((v + 0.1) * 10) / 10 : v))}\n                  style={{ width: '28px', height: '28px', background: theme.colors.surfaceAlt, border: 'none', borderRadius: '6px', color: theme.colors.text, cursor: 'pointer', fontSize: '16px' }}>+</button>\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n          \n          {/* Gradient info */}\n          <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '12px' }}>\n            <div style={{ fontSize: '12px', color: theme.colors.orange, fontWeight: '600', marginBottom: '10px' }}>\n              ∂L/∂y from loss: [{dL_dY.map(g => g.toFixed(1)).join(', ')}]\n            </div>\n            <div style={{ fontSize: '12px', color: theme.colors.textMuted, marginBottom: '10px' }}>\n              ∂L/∂W[i][j] = x[i] × ∂L/∂y[j]\n            </div>\n            {[0, 1].map(i => (\n              <div key={i} style={{ padding: '8px 12px', background: theme.colors.surfaceAlt, borderRadius: '8px', marginBottom: '6px', fontSize: '13px' }}>\n                <span style={{ color: theme.colors.blue }}>x{i}={inputs[i].toFixed(1)}</span>\n                <span style={{ color: theme.colors.textMuted }}> × [{dL_dY.join(', ')}] = </span>\n                <span style={{ color: theme.colors.orange, fontWeight: '700' }}>[{dL_dW[i].map(g => g.toFixed(2)).join(', ')}]</span>\n              </div>\n            ))}\n          </div>\n\n          {/* Apply button */}\n          <button onClick={applyGradient}\n            style={{ padding: '14px', borderRadius: '10px', border: 'none', cursor: 'pointer',\n              background: `linear-gradient(135deg, ${theme.colors.pink}, ${theme.colors.primary})`,\n              color: theme.colors.text, fontSize: '14px', fontWeight: '700' }}>\n            Apply: W = W − 0.1 × ∂L/∂W\n          </button>\n\n          {/* Input gradient */}\n          <div style={{ background: theme.colors.surface, borderRadius: '10px', padding: '12px' }}>\n            <div style={{ fontSize: '12px', color: theme.colors.pink, marginBottom: '8px' }}>\n              ∂L/∂x = Wᵀ · ∂L/∂y (pass to previous layer)\n            </div>\n            <div style={{ fontSize: '15px', color: theme.colors.pink, fontWeight: '700' }}>\n              [{dL_dX.map(g => g.toFixed(2)).join(', ')}]\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Hint */}\n      <div style={{ marginTop: '10px', padding: '10px 12px', background: theme.colors.surfaceAlt, borderRadius: '8px',\n        fontSize: '12px', color: theme.colors.textMuted, textAlign: 'center' }}>\n        {mode === 'forward' \n          ? 'Drag inputs ↕ • Click weight +0.1 • Right-click −0.1 • Hover to see math'\n          : 'Boxes show gradients • Red = decrease weight • Click Apply to update'}\n      </div>\n    </div>\n  );\n}",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}