{
  "problem_id": 22,
  "title": "Sigmoid Activation Function Understanding",
  "category": "Deep Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst sigmoid = (z) => 1 / (1 + Math.exp(-z));\nconst sigmoidDerivative = (z) => {\n  const s = sigmoid(z);\n  return s * (1 - s);\n};\n\nconst stepInfo = [\n  {\n    title: 'Explore the Sigmoid Function',\n    desc: 'Drag the point along the x-axis to see how sigmoid maps any real number to a value between 0 and 1. This makes it perfect for modeling probabilities.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'The S-Curve Shape',\n    desc: 'Sigmoid creates a smooth \"S\" curve. Near z=0, the output changes rapidly. For extreme values, it saturates near 0 or 1.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'The Gradient (Derivative)',\n    desc: 'The green curve shows the gradient. Its highest at z=0 (gradient=0.25) and approaches 0 for extreme inputs. This causes the \"vanishing gradient\" problem in deep networks.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Binary Classification',\n    desc: 'Sigmoid outputs are often interpreted as probabilities. Values > 0.5 predict class 1, values < 0.5 predict class 0. The decision boundary is at z=0.',\n    color: theme.colors.yellow,\n  },\n];\n\nexport default function App() {\n  const [z, setZ] = useState(0);\n  const [step, setStep] = useState(0);\n  const [dragging, setDragging] = useState(false);\n  const [showGradient, setShowGradient] = useState(false);\n  const canvasRef = useRef(null);\n\n  const totalSteps = 3;\n  const size = 320;\n  const padding = 40;\n  const plotSize = size - 2 * padding;\n\n  // Update gradient visibility based on step\n  useEffect(() => {\n    setShowGradient(step >= 2);\n  }, [step]);\n\n  const output = sigmoid(z);\n  const gradient = sigmoidDerivative(z);\n\n  // Canvas drawing\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    const xMin = -6, xMax = 6;\n    const yMin = -0.1, yMax = 1.1;\n\n    const scaleX = (x) => padding + ((x - xMin) / (xMax - xMin)) * plotSize;\n    const scaleY = (y) => size - padding - ((y - yMin) / (yMax - yMin)) * plotSize;\n\n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let x = -6; x <= 6; x += 2) {\n      ctx.beginPath();\n      ctx.moveTo(scaleX(x), padding);\n      ctx.lineTo(scaleX(x), size - padding);\n      ctx.stroke();\n    }\n    for (let y = 0; y <= 1; y += 0.25) {\n      ctx.beginPath();\n      ctx.moveTo(padding, scaleY(y));\n      ctx.lineTo(size - padding, scaleY(y));\n      ctx.stroke();\n    }\n\n    // Axes\n    ctx.strokeStyle = theme.colors.textMuted;\n    ctx.lineWidth = 2;\n    // X-axis\n    ctx.beginPath();\n    ctx.moveTo(padding, scaleY(0));\n    ctx.lineTo(size - padding, scaleY(0));\n    ctx.stroke();\n    // Y-axis\n    ctx.beginPath();\n    ctx.moveTo(scaleX(0), padding);\n    ctx.lineTo(scaleX(0), size - padding);\n    ctx.stroke();\n\n    // Axis labels\n    ctx.fillStyle = theme.colors.textMuted;\n    ctx.font = '10px JetBrains Mono, monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('z (input)', size / 2, size - 8);\n    ctx.save();\n    ctx.translate(12, size / 2);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText('output', 0, 0);\n    ctx.restore();\n\n    // Key values on axes\n    ctx.fillStyle = theme.colors.textMuted;\n    ctx.font = '9px JetBrains Mono, monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('-4', scaleX(-4), scaleY(0) + 12);\n    ctx.fillText('-2', scaleX(-2), scaleY(0) + 12);\n    ctx.fillText('0', scaleX(0), scaleY(0) + 12);\n    ctx.fillText('2', scaleX(2), scaleY(0) + 12);\n    ctx.fillText('4', scaleX(4), scaleY(0) + 12);\n    \n    ctx.textAlign = 'right';\n    ctx.fillText('0', scaleX(0) - 6, scaleY(0) + 3);\n    ctx.fillText('0.5', scaleX(0) - 6, scaleY(0.5) + 3);\n    ctx.fillText('1', scaleX(0) - 6, scaleY(1) + 3);\n\n    // Decision boundary line at y=0.5 (step 3)\n    if (step >= 3) {\n      ctx.strokeStyle = theme.colors.yellow + '60';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([6, 4]);\n      ctx.beginPath();\n      ctx.moveTo(padding, scaleY(0.5));\n      ctx.lineTo(size - padding, scaleY(0.5));\n      ctx.stroke();\n      ctx.setLineDash([]);\n      \n      ctx.fillStyle = theme.colors.yellow;\n      ctx.font = '9px JetBrains Mono, monospace';\n      ctx.textAlign = 'left';\n      ctx.fillText('threshold = 0.5', size - padding - 70, scaleY(0.5) - 6);\n    }\n\n    // Gradient curve (step 2+)\n    if (showGradient) {\n      ctx.strokeStyle = theme.colors.green;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      for (let px = padding; px <= size - padding; px++) {\n        const x = xMin + ((px - padding) / plotSize) * (xMax - xMin);\n        const y = sigmoidDerivative(x);\n        if (px === padding) ctx.moveTo(px, scaleY(y));\n        else ctx.lineTo(px, scaleY(y));\n      }\n      ctx.stroke();\n    }\n\n    // Sigmoid curve\n    ctx.strokeStyle = theme.colors.pink;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    for (let px = padding; px <= size - padding; px++) {\n      const x = xMin + ((px - padding) / plotSize) * (xMax - xMin);\n      const y = sigmoid(x);\n      if (px === padding) ctx.moveTo(px, scaleY(y));\n      else ctx.lineTo(px, scaleY(y));\n    }\n    ctx.stroke();\n\n    // Vertical line from x-axis to curve\n    ctx.strokeStyle = theme.colors.blue + '80';\n    ctx.lineWidth = 2;\n    ctx.setLineDash([4, 4]);\n    ctx.beginPath();\n    ctx.moveTo(scaleX(z), scaleY(0));\n    ctx.lineTo(scaleX(z), scaleY(output));\n    ctx.stroke();\n    \n    // Horizontal line from curve to y-axis\n    ctx.strokeStyle = theme.colors.primary + '80';\n    ctx.beginPath();\n    ctx.moveTo(scaleX(z), scaleY(output));\n    ctx.lineTo(scaleX(0), scaleY(output));\n    ctx.stroke();\n    ctx.setLineDash([]);\n\n    // Point on curve\n    ctx.fillStyle = theme.colors.primary + '40';\n    ctx.beginPath();\n    ctx.arc(scaleX(z), scaleY(output), 16, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = theme.colors.primary;\n    ctx.beginPath();\n    ctx.arc(scaleX(z), scaleY(output), 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = theme.colors.text;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Draggable indicator on x-axis\n    ctx.fillStyle = theme.colors.blue;\n    ctx.beginPath();\n    ctx.moveTo(scaleX(z), scaleY(0) - 8);\n    ctx.lineTo(scaleX(z) - 6, scaleY(0) + 4);\n    ctx.lineTo(scaleX(z) + 6, scaleY(0) + 4);\n    ctx.closePath();\n    ctx.fill();\n\n    // Legend\n    ctx.font = '9px JetBrains Mono, monospace';\n    ctx.fillStyle = theme.colors.pink;\n    ctx.fillText('sigmoid', padding + 10, padding + 15);\n    if (showGradient) {\n      ctx.fillStyle = theme.colors.green;\n      ctx.fillText('gradient', padding + 10, padding + 28);\n    }\n\n  }, [z, output, step, showGradient]);\n\n  // Mouse handlers\n  const getMouseZ = (e) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const xMin = -6, xMax = 6;\n    const z = xMin + ((x - padding) / plotSize) * (xMax - xMin);\n    return Math.max(-5.5, Math.min(5.5, z));\n  };\n\n  const handleMouseDown = (e) => {\n    setDragging(true);\n    setZ(getMouseZ(e));\n  };\n\n  const handleMouseMove = (e) => {\n    if (!dragging) return;\n    setZ(getMouseZ(e));\n  };\n\n  const handleMouseUp = () => setDragging(false);\n\n  const next = () => step < totalSteps && setStep(step + 1);\n  const prev = () => step > 0 && setStep(step - 1);\n\n  const formatNum = (n, decimals = 4) => n.toFixed(decimals);\n\n  // Preset z values\n  const presets = [\n    { label: '-4', value: -4 },\n    { label: '-1', value: -1 },\n    { label: '0', value: 0 },\n    { label: '1', value: 1 },\n    { label: '4', value: 4 },\n  ];\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          Sigmoid Activation Function\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          Maps any real number to (0, 1)\n        </div>\n      </div>\n\n      {/* Preset buttons */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '12px' }}>\n        <span style={{ fontSize: '10px', color: theme.colors.textMuted, alignSelf: 'center' }}>z =</span>\n        {presets.map(p => (\n          <button\n            key={p.label}\n            onClick={() => setZ(p.value)}\n            style={{\n              padding: '4px 10px',\n              background: Math.abs(z - p.value) < 0.1 ? theme.colors.primary : theme.colors.surface,\n              border: 'none',\n              borderRadius: '4px',\n              color: Math.abs(z - p.value) < 0.1 ? '#fff' : theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n            }}\n          >\n            {p.label}\n          </button>\n        ))}\n      </div>\n\n      {/* Visualization */}\n      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '12px' }}>\n        <canvas\n          ref={canvasRef}\n          width={size}\n          height={size}\n          style={{\n            borderRadius: '8px',\n            border: '1px solid ' + theme.colors.border,\n            cursor: 'ew-resize',\n          }}\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n        />\n      </div>\n\n      {/* Values Display */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        gap: '12px',\n        marginBottom: '12px',\n        flexWrap: 'wrap',\n      }}>\n        <div style={{\n          padding: '8px 14px',\n          background: theme.colors.surface,\n          borderRadius: '8px',\n          border: '2px solid ' + theme.colors.blue,\n          textAlign: 'center',\n        }}>\n          <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>input (z)</div>\n          <div style={{ fontSize: '18px', fontWeight: '700', color: theme.colors.blue }}>\n            {formatNum(z, 2)}\n          </div>\n        </div>\n        <div style={{\n          padding: '8px 14px',\n          background: theme.colors.surface,\n          borderRadius: '8px',\n          border: '2px solid ' + theme.colors.pink,\n          textAlign: 'center',\n        }}>\n          <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>sigmoid(z)</div>\n          <div style={{ fontSize: '18px', fontWeight: '700', color: theme.colors.pink }}>\n            {formatNum(output)}\n          </div>\n        </div>\n        {showGradient && (\n          <div style={{\n            padding: '8px 14px',\n            background: theme.colors.surface,\n            borderRadius: '8px',\n            border: '2px solid ' + theme.colors.green,\n            textAlign: 'center',\n          }}>\n            <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>gradient</div>\n            <div style={{ fontSize: '18px', fontWeight: '700', color: theme.colors.green }}>\n              {formatNum(gradient)}\n            </div>\n          </div>\n        )}\n        {step >= 3 && (\n          <div style={{\n            padding: '8px 14px',\n            background: output >= 0.5 ? theme.colors.positive + '20' : theme.colors.negative + '20',\n            borderRadius: '8px',\n            border: '2px solid ' + (output >= 0.5 ? theme.colors.positive : theme.colors.negative),\n            textAlign: 'center',\n          }}>\n            <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>prediction</div>\n            <div style={{ fontSize: '18px', fontWeight: '700', color: output >= 0.5 ? theme.colors.positive : theme.colors.negative }}>\n              {output >= 0.5 ? 'Class 1' : 'Class 0'}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Formula */}\n      <div style={{\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        padding: '10px',\n        marginBottom: '12px',\n        textAlign: 'center',\n      }}>\n        <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '4px' }}>\n          Formula\n        </div>\n        <div style={{ fontSize: '13px', color: theme.colors.text }}>\n          <span style={{ color: theme.colors.pink }}>sigmoid</span>(z) = 1 / (1 + e<sup>-z</sup>) = 1 / (1 + e<sup>-({formatNum(z, 2)})</sup>) = <span style={{ color: theme.colors.pink, fontWeight: '600' }}>{formatNum(output)}</span>\n        </div>\n        {showGradient && (\n          <div style={{ fontSize: '11px', color: theme.colors.textSecondary, marginTop: '6px' }}>\n            <span style={{ color: theme.colors.green }}>gradient</span> = sigmoid(z) * (1 - sigmoid(z)) = {formatNum(output)} * {formatNum(1 - output)} = <span style={{ color: theme.colors.green, fontWeight: '600' }}>{formatNum(gradient)}</span>\n          </div>\n        )}\n      </div>\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            onClick={() => setStep(i)}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              cursor: 'pointer',\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps ? 0.5 : 1,\n          }}\n        >\n          {step < totalSteps ? 'Next' : 'Complete!'}\n        </button>\n        <button\n          onClick={() => { setStep(0); setZ(0); setShowGradient(false); }}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        Sigmoid squashes any input to (0,1), ideal for probabilities. But the vanishing gradient at extreme values makes ReLU preferred in deep networks.\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}