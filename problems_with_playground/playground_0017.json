{
  "problem_id": 17,
  "title": "K-Means Clustering",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst clusterColors = ['#f472b6', '#38bdf8', '#a3e635', '#fbbf24'];\n\nconst examples = [\n  {\n    name: '2 Clusters',\n    points: [[1,2],[1,4],[1,0],[2,3],[2,1],[10,2],[10,4],[10,0],[9,3],[11,1]],\n    k: 2,\n    initialCentroids: [[0,0],[8,8]],\n  },\n  {\n    name: '3 Clusters',\n    points: [[1,1],[2,1],[1,2],[8,1],[9,1],[8,2],[5,8],[5,9],[6,8]],\n    k: 3,\n    initialCentroids: [[0,0],[10,0],[5,10]],\n  },\n  {\n    name: '4 Corners',\n    points: [[0,0],[1,0],[0,1],[1,1],[9,0],[10,0],[9,1],[10,1],[0,9],[1,9],[0,10],[1,10],[9,9],[10,9],[9,10],[10,10]],\n    k: 4,\n    initialCentroids: [[2,2],[8,2],[2,8],[8,8]],\n  },\n];\n\nconst stepInfo = [\n  {\n    title: 'Explore: Place Your Centroids',\n    desc: 'Drag the colored squares to position the initial centroids. Try placing them near where you think cluster centers should be, or far away to see how K-Means recovers.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'Step 1: Assign Points to Nearest Centroid',\n    desc: 'Each point is assigned to its closest centroid. Points are colored by their cluster. Notice how the initial centroid positions affect assignments.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 2: Update Centroids',\n    desc: 'Each centroid moves to the mean (average position) of all points assigned to it. Watch the centroids shift toward the center of their clusters.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Step 3: Re-assign Points',\n    desc: 'With centroids in new positions, we reassign points. Some points may switch clusters as centroid positions have changed.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 4: Update Centroids Again',\n    desc: 'Centroids move again to the new cluster means. The movements get smaller as we approach convergence.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Converging to Final Clusters',\n    desc: 'Watch K-Means iterate until centroids stop moving. The algorithm has converged when assignments no longer change.',\n    color: theme.colors.primary,\n  },\n];\n\nexport default function App() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [iteration, setIteration] = useState(0);\n  const [centroids, setCentroids] = useState(() => examples[0].initialCentroids.map(c => [...c]));\n  const [assignments, setAssignments] = useState([]);\n  const [prevCentroids, setPrevCentroids] = useState([]);\n  const [iterating, setIterating] = useState(false);\n  const [dragging, setDragging] = useState(null);\n  const [converged, setConverged] = useState(false);\n  const canvasRef = useRef(null);\n  const iterRef = useRef(null);\n\n  const totalSteps = 5;\n  const ex = examples[exampleIdx];\n  const size = 320;\n  const padding = 30;\n  const plotSize = size - 2 * padding;\n\n  // Full reset function\n  const fullReset = (idx) => {\n    const newEx = examples[idx];\n    if (iterRef.current) {\n      clearInterval(iterRef.current);\n      iterRef.current = null;\n    }\n    setCentroids(newEx.initialCentroids.map(c => [...c]));\n    setAssignments([]);\n    setPrevCentroids([]);\n    setStep(0);\n    setPlaying(false);\n    setIteration(0);\n    setIterating(false);\n    setConverged(false);\n    setDragging(null);\n  };\n\n  // Handle example change\n  const handleExampleChange = (idx) => {\n    fullReset(idx);\n    setExampleIdx(idx);\n  };\n\n  const euclidean = (a, b) => Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2);\n\n  const assignPoints = (cents, points) => {\n    return points.map(p => {\n      let minDist = Infinity, minIdx = 0;\n      cents.forEach((c, i) => {\n        const d = euclidean(p, c);\n        if (d < minDist) { minDist = d; minIdx = i; }\n      });\n      return minIdx;\n    });\n  };\n\n  const updateCentroids = (assigns, cents, points) => {\n    const newCents = cents.map((c, i) => {\n      const clusterPts = points.filter((_, pi) => assigns[pi] === i);\n      if (clusterPts.length === 0) return [...c];\n      const meanX = clusterPts.reduce((s, p) => s + p[0], 0) / clusterPts.length;\n      const meanY = clusterPts.reduce((s, p) => s + p[1], 0) / clusterPts.length;\n      return [Math.round(meanX * 10000) / 10000, Math.round(meanY * 10000) / 10000];\n    });\n    return newCents;\n  };\n\n  const centroidsEqual = (a, b) => {\n    if (a.length !== b.length) return false;\n    return a.every((c, i) => Math.abs(c[0] - b[i][0]) < 0.0001 && Math.abs(c[1] - b[i][1]) < 0.0001);\n  };\n\n  const reset = () => fullReset(exampleIdx);\n\n  const next = () => {\n    if (step >= totalSteps) return;\n    const nextStep = step + 1;\n    setStep(nextStep);\n\n    if (nextStep === 1) {\n      setAssignments(assignPoints(centroids, ex.points));\n    } else if (nextStep === 2) {\n      setPrevCentroids(centroids.map(c => [...c]));\n      const newCents = updateCentroids(assignments, centroids, ex.points);\n      setCentroids(newCents);\n      setIteration(1);\n    } else if (nextStep === 3) {\n      setAssignments(assignPoints(centroids, ex.points));\n    } else if (nextStep === 4) {\n      setPrevCentroids(centroids.map(c => [...c]));\n      const newCents = updateCentroids(assignments, centroids, ex.points);\n      setCentroids(newCents);\n      setIteration(2);\n    } else if (nextStep === 5) {\n      setIterating(true);\n    }\n  };\n\n  const prev = () => step > 0 && setStep(step - 1);\n\n  const auto = async () => {\n    setPlaying(true);\n    let curCents = centroids.map(c => [...c]);\n    let curAssigns = [...assignments];\n    let curIter = iteration;\n\n    for (let s = step; s <= totalSteps; s++) {\n      setStep(s);\n      if (s === 1) {\n        curAssigns = assignPoints(curCents, ex.points);\n        setAssignments(curAssigns);\n      } else if (s === 2) {\n        setPrevCentroids(curCents.map(c => [...c]));\n        curCents = updateCentroids(curAssigns, curCents, ex.points);\n        setCentroids(curCents);\n        curIter = 1;\n        setIteration(1);\n      } else if (s === 3) {\n        curAssigns = assignPoints(curCents, ex.points);\n        setAssignments(curAssigns);\n      } else if (s === 4) {\n        setPrevCentroids(curCents.map(c => [...c]));\n        curCents = updateCentroids(curAssigns, curCents, ex.points);\n        setCentroids(curCents);\n        curIter = 2;\n        setIteration(2);\n      } else if (s === 5) {\n        setIterating(true);\n      }\n      await new Promise(r => setTimeout(r, 800));\n    }\n    setPlaying(false);\n  };\n\n  // Auto iteration loop\n  useEffect(() => {\n    if (!iterating || converged || iteration >= 20) {\n      if (iterRef.current) {\n        clearInterval(iterRef.current);\n        iterRef.current = null;\n      }\n      return;\n    }\n\n    iterRef.current = setInterval(() => {\n      setCentroids(prevCents => {\n        const assigns = assignPoints(prevCents, ex.points);\n        setAssignments(assigns);\n        const newCents = updateCentroids(assigns, prevCents, ex.points);\n        \n        if (centroidsEqual(prevCents, newCents)) {\n          setConverged(true);\n          if (iterRef.current) {\n            clearInterval(iterRef.current);\n            iterRef.current = null;\n          }\n          return prevCents;\n        }\n        \n        setPrevCentroids(prevCents.map(c => [...c]));\n        setIteration(prev => prev + 1);\n        return newCents;\n      });\n    }, 400);\n\n    return () => { \n      if (iterRef.current) {\n        clearInterval(iterRef.current);\n        iterRef.current = null;\n      }\n    };\n  }, [iterating, converged, exampleIdx, ex.points]);\n\n  // Mouse handlers for dragging centroids\n  const getMousePos = (e) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    const bounds = { min: 0, max: 12 };\n    const px = bounds.min + ((x - padding) / plotSize) * (bounds.max - bounds.min);\n    const py = bounds.max - ((y - padding) / plotSize) * (bounds.max - bounds.min);\n    \n    return [\n      Math.max(bounds.min, Math.min(bounds.max, px)),\n      Math.max(bounds.min, Math.min(bounds.max, py)),\n    ];\n  };\n\n  const handleMouseDown = (e) => {\n    if (step > 0) return;\n    const pos = getMousePos(e);\n    \n    let closest = null;\n    let minDist = 1.5;\n    centroids.forEach((c, i) => {\n      const d = euclidean(pos, c);\n      if (d < minDist) {\n        minDist = d;\n        closest = i;\n      }\n    });\n    \n    if (closest !== null) {\n      setDragging(closest);\n    }\n  };\n\n  const handleMouseMove = (e) => {\n    if (dragging === null || step > 0) return;\n    const pos = getMousePos(e);\n    setCentroids(prev => {\n      const newCents = [...prev];\n      newCents[dragging] = pos;\n      return newCents;\n    });\n  };\n\n  const handleMouseUp = () => {\n    setDragging(null);\n  };\n\n  // Canvas drawing\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    const bounds = { min: 0, max: 12 };\n    const scaleX = (x) => padding + ((x - bounds.min) / (bounds.max - bounds.min)) * plotSize;\n    const scaleY = (y) => size - padding - ((y - bounds.min) / (bounds.max - bounds.min)) * plotSize;\n\n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let i = 0; i <= 6; i++) {\n      const x = padding + (i / 6) * plotSize;\n      const y = padding + (i / 6) * plotSize;\n      ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, size - padding); ctx.stroke();\n      ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(size - padding, y); ctx.stroke();\n    }\n\n    // Assignment lines (during assignment steps) - with safety check\n    if ((step === 1 || step === 3 || step >= 5) && assignments.length === ex.points.length) {\n      ex.points.forEach((p, i) => {\n        const ci = assignments[i];\n        // Safety check: make sure centroid exists\n        if (ci >= 0 && ci < centroids.length && centroids[ci]) {\n          ctx.strokeStyle = clusterColors[ci % clusterColors.length] + '60';\n          ctx.lineWidth = 1;\n          ctx.setLineDash([4, 4]);\n          ctx.beginPath();\n          ctx.moveTo(scaleX(p[0]), scaleY(p[1]));\n          ctx.lineTo(scaleX(centroids[ci][0]), scaleY(centroids[ci][1]));\n          ctx.stroke();\n        }\n      });\n      ctx.setLineDash([]);\n    }\n\n    // Centroid movement arrows (during update steps)\n    if ((step === 2 || step === 4) && prevCentroids.length === centroids.length) {\n      centroids.forEach((c, i) => {\n        const prev = prevCentroids[i];\n        if (prev && euclidean(c, prev) > 0.01) {\n          ctx.strokeStyle = clusterColors[i % clusterColors.length];\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(scaleX(prev[0]), scaleY(prev[1]));\n          ctx.lineTo(scaleX(c[0]), scaleY(c[1]));\n          ctx.stroke();\n          \n          const angle = Math.atan2(scaleY(c[1]) - scaleY(prev[1]), scaleX(c[0]) - scaleX(prev[0]));\n          const ax = scaleX(c[0]);\n          const ay = scaleY(c[1]);\n          ctx.beginPath();\n          ctx.moveTo(ax, ay);\n          ctx.lineTo(ax - 8 * Math.cos(angle - 0.4), ay - 8 * Math.sin(angle - 0.4));\n          ctx.lineTo(ax - 8 * Math.cos(angle + 0.4), ay - 8 * Math.sin(angle + 0.4));\n          ctx.closePath();\n          ctx.fillStyle = clusterColors[i % clusterColors.length];\n          ctx.fill();\n        }\n      });\n    }\n\n    // Data points\n    ex.points.forEach((p, i) => {\n      let color = theme.colors.textMuted;\n      if (step >= 1 && assignments.length === ex.points.length) {\n        const ci = assignments[i];\n        if (ci >= 0 && ci < centroids.length) {\n          color = clusterColors[ci % clusterColors.length];\n        }\n      }\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(scaleX(p[0]), scaleY(p[1]), 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = theme.colors.surface;\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    });\n\n    // Centroids (as squares)\n    centroids.forEach((c, i) => {\n      if (!c) return;\n      const cx = scaleX(c[0]);\n      const cy = scaleY(c[1]);\n      const s = step === 0 ? 14 : 12;\n      \n      if (step === 0) {\n        ctx.fillStyle = clusterColors[i % clusterColors.length] + '40';\n        ctx.fillRect(cx - s - 4, cy - s - 4, (s + 4) * 2, (s + 4) * 2);\n      }\n      \n      ctx.fillStyle = clusterColors[i % clusterColors.length];\n      ctx.fillRect(cx - s, cy - s, s * 2, s * 2);\n      ctx.strokeStyle = theme.colors.text;\n      ctx.lineWidth = 2;\n      ctx.strokeRect(cx - s, cy - s, s * 2, s * 2);\n      \n      ctx.fillStyle = theme.colors.text;\n      ctx.font = 'bold 10px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText('C' + (i + 1), cx, cy);\n    });\n\n    if (step === 0) {\n      ctx.fillStyle = theme.colors.textSecondary;\n      ctx.font = '10px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText('Drag squares to move centroids', size / 2, size - 10);\n    }\n\n  }, [step, centroids, assignments, prevCentroids, exampleIdx, iteration, dragging, ex.points]);\n\n  const formatNum = (n) => n.toFixed(2);\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          K-Means Clustering\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          {step === 0 ? 'Position centroids, then click Start' : 'Watch points cluster around centroids'}\n        </div>\n      </div>\n\n      {/* Example Tabs */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '12px' }}>\n        {examples.map((e, idx) => (\n          <button\n            key={idx}\n            onClick={() => handleExampleChange(idx)}\n            style={{\n              padding: '6px 12px',\n              background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n              border: 'none',\n              borderRadius: '6px',\n              color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n            }}\n          >\n            {e.name}\n          </button>\n        ))}\n      </div>\n\n      {/* Visualization */}\n      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '12px' }}>\n        <canvas\n          ref={canvasRef}\n          width={size}\n          height={size}\n          style={{\n            borderRadius: '8px',\n            border: '1px solid ' + (step === 0 ? theme.colors.primary : theme.colors.border),\n            cursor: step === 0 ? 'grab' : 'default',\n          }}\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n        />\n      </div>\n\n      {/* Centroid Stats */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        gap: '8px',\n        marginBottom: '12px',\n        flexWrap: 'wrap',\n      }}>\n        {centroids.map((c, i) => (\n          <div key={i} style={{\n            padding: '6px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n            border: '2px solid ' + clusterColors[i % clusterColors.length],\n          }}>\n            <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>C{i + 1}</span>\n            <div style={{ fontSize: '12px', fontWeight: '600', color: clusterColors[i % clusterColors.length] }}>\n              ({formatNum(c[0])}, {formatNum(c[1])})\n            </div>\n          </div>\n        ))}\n        {iteration > 0 && (\n          <div style={{\n            padding: '6px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n          }}>\n            <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>iter</span>\n            <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.primary }}>\n              {iteration}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0 || playing}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps || playing}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps ? 0.5 : 1,\n          }}\n        >\n          {step === 0 ? 'Start' : step < totalSteps ? 'Next Step' : 'Complete!'}\n        </button>\n        <button\n          onClick={auto}\n          disabled={playing || step >= totalSteps}\n          style={{\n            padding: '8px 12px',\n            background: playing ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: playing ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: playing ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {playing ? '...' : '>>'}\n        </button>\n        <button\n          onClick={reset}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Math Details */}\n      {step >= 1 && (\n        <div style={{\n          padding: '10px',\n          background: theme.colors.surfaceAlt,\n          borderRadius: '8px',\n          marginBottom: '12px',\n        }}>\n          {(step === 1 || step === 3) && assignments.length === ex.points.length && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.blue, marginBottom: '6px', fontWeight: '600' }}>\n                Assignment: each point to nearest centroid\n              </div>\n              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>\n                {centroids.map((_, ci) => {\n                  const count = assignments.filter(a => a === ci).length;\n                  return (\n                    <div key={ci} style={{\n                      padding: '4px 8px',\n                      background: theme.colors.surface,\n                      borderRadius: '4px',\n                      fontSize: '10px',\n                      border: '1px solid ' + clusterColors[ci % clusterColors.length],\n                    }}>\n                      <span style={{ color: clusterColors[ci % clusterColors.length] }}>C{ci + 1}: {count} points</span>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          )}\n\n          {(step === 2 || step === 4) && prevCentroids.length === centroids.length && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.green, marginBottom: '6px', fontWeight: '600' }}>\n                Update: centroid = mean of cluster points\n              </div>\n              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>\n                {centroids.map((c, ci) => {\n                  const prev = prevCentroids[ci] || c;\n                  const moved = euclidean(c, prev) > 0.01;\n                  return (\n                    <div key={ci} style={{\n                      padding: '4px 8px',\n                      background: theme.colors.surface,\n                      borderRadius: '4px',\n                      fontSize: '10px',\n                      border: '1px solid ' + clusterColors[ci % clusterColors.length],\n                    }}>\n                      <span style={{ color: clusterColors[ci % clusterColors.length] }}>\n                        C{ci + 1}: ({formatNum(prev[0])}, {formatNum(prev[1])}) \n                        {moved ? ' -> ' : ' = '}\n                        ({formatNum(c[0])}, {formatNum(c[1])})\n                      </span>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          )}\n\n          {step === 5 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.primary, marginBottom: '6px', fontWeight: '600' }}>\n                {converged ? 'Converged!' : 'Running K-Means...'}\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                {converged \n                  ? 'Centroids stopped moving - clusters are stable'\n                  : 'Iterating: assign points, update centroids, repeat...'}\n              </div>\n              {converged && (\n                <div style={{ marginTop: '8px' }}>\n                  <div style={{ fontSize: '10px', color: theme.colors.positive }}>\n                    Final centroids after {iteration} iterations:\n                  </div>\n                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', marginTop: '4px' }}>\n                    {centroids.map((c, ci) => (\n                      <span key={ci} style={{ color: clusterColors[ci % clusterColors.length], fontSize: '10px' }}>\n                        C{ci + 1}: ({formatNum(c[0])}, {formatNum(c[1])})\n                      </span>\n                    ))}\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        K-Means alternates between assigning points and moving centroids until convergence. Initial positions affect final clusters!\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}