{
  "problem_id": 15,
  "title": "Linear Regression Using Gradient Descent",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst examples = [\n  {\n    name: 'Simple Line',\n    X: [[1, 1], [1, 2], [1, 3]],\n    y: [1, 2, 3],\n    alpha: 0.1,\n    t0Range: [-1, 2],\n    t1Range: [-0.5, 2],\n  },\n  {\n    name: 'With Intercept',\n    X: [[1, 1], [1, 2], [1, 3], [1, 4]],\n    y: [3, 5, 7, 9],\n    alpha: 0.1,\n    t0Range: [-1, 3],\n    t1Range: [0, 3],\n  },\n  {\n    name: 'Scattered',\n    X: [[1, 0], [1, 1], [1, 2], [1, 3]],\n    y: [1, 2.5, 2, 4],\n    alpha: 0.1,\n    t0Range: [-1, 3],\n    t1Range: [-0.5, 2],\n  },\n];\n\nconst stepInfo = [\n  {\n    title: 'Explore the Loss Landscape',\n    desc: 'Drag the green ball on the contour plot to explore! Darker = lower loss. Watch how the fit line changes. Find the minimum, then click Start.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'Step 1: Make Predictions',\n    desc: 'Multiply data X by current weights theta. Each prediction is theta0 + theta1 * x.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 2: Calculate Errors',\n    desc: 'Error = prediction minus actual (y). Loss = mean squared error. The higher up on the landscape, the larger the loss.',\n    color: theme.colors.negative,\n  },\n  {\n    title: 'Step 3: Compute the Gradient',\n    desc: 'The gradient (orange arrow) points uphill. We move opposite (green dashed) to descend toward lower loss.',\n    color: theme.colors.orange,\n  },\n  {\n    title: 'Step 4: First Update',\n    desc: 'Move theta opposite to gradient, scaled by alpha. Watch the ball take its first step downhill!',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Step 5: Second Update',\n    desc: 'One more manual step. Notice how the gradient changes direction as we move through the landscape.',\n    color: theme.colors.green,\n  },\n  {\n    title: 'Converging to Minimum',\n    desc: 'Now watch gradient descent run to completion. The path traces our descent through the loss landscape.',\n    color: theme.colors.primary,\n  },\n];\n\nexport default function App() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [iteration, setIteration] = useState(0);\n  const [theta, setTheta] = useState([0, 0]);\n  const [predictions, setPredictions] = useState([]);\n  const [errors, setErrors] = useState([]);\n  const [gradient, setGradient] = useState([0, 0]);\n  const [iterating, setIterating] = useState(false);\n  const [path, setPath] = useState([[0, 0]]);\n  const [dragging, setDragging] = useState(false);\n  const scatterRef = useRef(null);\n  const contourRef = useRef(null);\n  const iterRef = useRef(null);\n\n  const totalSteps = 6;\n  const ex = examples[exampleIdx];\n  const size = 200;\n  const padding = 28;\n  const plotSize = size - 2 * padding;\n\n  const computePredictions = (th, data) => data.X.map(row => row[0] * th[0] + row[1] * th[1]);\n  const computeErrors = (preds, data) => preds.map((p, i) => p - data.y[i]);\n  const computeGradient = (errs, data) => {\n    const len = data.X.length;\n    const g0 = errs.reduce((sum, e, i) => sum + e * data.X[i][0], 0) / len;\n    const g1 = errs.reduce((sum, e, i) => sum + e * data.X[i][1], 0) / len;\n    return [g0, g1];\n  };\n  const computeLoss = (th, data) => {\n    const preds = computePredictions(th, data);\n    const errs = computeErrors(preds, data);\n    return errs.reduce((sum, e) => sum + e * e, 0) / data.X.length;\n  };\n\n  const reset = () => {\n    setStep(0);\n    setPlaying(false);\n    setIteration(0);\n    setTheta([0, 0]);\n    setPredictions([]);\n    setErrors([]);\n    setGradient([0, 0]);\n    setIterating(false);\n    setPath([[0, 0]]);\n    if (iterRef.current) clearInterval(iterRef.current);\n  };\n\n  const doOneIteration = (currentTheta, currentPath) => {\n    const preds = computePredictions(currentTheta, ex);\n    const errs = computeErrors(preds, ex);\n    const grad = computeGradient(errs, ex);\n    const newTheta = [\n      currentTheta[0] - ex.alpha * grad[0],\n      currentTheta[1] - ex.alpha * grad[1],\n    ];\n    const newPath = [...currentPath, newTheta];\n    return { newTheta, newPath, grad };\n  };\n\n  const next = () => {\n    if (step < totalSteps) {\n      const nextStep = step + 1;\n      setStep(nextStep);\n      \n      if (nextStep === 1) {\n        setPredictions(computePredictions(theta, ex));\n      } else if (nextStep === 2) {\n        const preds = computePredictions(theta, ex);\n        setPredictions(preds);\n        setErrors(computeErrors(preds, ex));\n      } else if (nextStep === 3) {\n        const preds = computePredictions(theta, ex);\n        const errs = computeErrors(preds, ex);\n        setGradient(computeGradient(errs, ex));\n      } else if (nextStep === 4) {\n        const { newTheta, newPath, grad } = doOneIteration(theta, path);\n        setTheta(newTheta);\n        setPath(newPath);\n        setGradient(grad);\n        setIteration(1);\n      } else if (nextStep === 5) {\n        const { newTheta, newPath, grad } = doOneIteration(theta, path);\n        setTheta(newTheta);\n        setPath(newPath);\n        setGradient(grad);\n        setIteration(2);\n      } else if (nextStep === 6) {\n        setIterating(true);\n      }\n    }\n  };\n\n  const prev = () => step > 0 && setStep(step - 1);\n\n  const auto = async () => {\n    setPlaying(true);\n    let currentTheta = [...theta];\n    let currentGradient = [...gradient];\n    let currentPath = [...path];\n    let currentIter = iteration;\n    \n    for (let s = step; s <= totalSteps; s++) {\n      setStep(s);\n      if (s === 1) {\n        setPredictions(computePredictions(currentTheta, ex));\n      } else if (s === 2) {\n        const preds = computePredictions(currentTheta, ex);\n        setPredictions(preds);\n        setErrors(computeErrors(preds, ex));\n      } else if (s === 3) {\n        const preds = computePredictions(currentTheta, ex);\n        const errs = computeErrors(preds, ex);\n        currentGradient = computeGradient(errs, ex);\n        setGradient(currentGradient);\n      } else if (s === 4) {\n        const result = doOneIteration(currentTheta, currentPath);\n        currentTheta = result.newTheta;\n        currentPath = result.newPath;\n        currentGradient = result.grad;\n        setTheta(currentTheta);\n        setPath(currentPath);\n        setGradient(currentGradient);\n        currentIter = 1;\n        setIteration(1);\n      } else if (s === 5) {\n        const result = doOneIteration(currentTheta, currentPath);\n        currentTheta = result.newTheta;\n        currentPath = result.newPath;\n        currentGradient = result.grad;\n        setTheta(currentTheta);\n        setPath(currentPath);\n        setGradient(currentGradient);\n        currentIter = 2;\n        setIteration(2);\n      } else if (s === 6) {\n        setIterating(true);\n      }\n      await new Promise(r => setTimeout(r, 1000));\n    }\n    setPlaying(false);\n  };\n\n  // Auto iteration loop\n  useEffect(() => {\n    if (!iterating || iteration >= 50) {\n      if (iterRef.current) clearInterval(iterRef.current);\n      return;\n    }\n    \n    iterRef.current = setInterval(() => {\n      setTheta(prevTheta => {\n        const preds = computePredictions(prevTheta, ex);\n        const errs = computeErrors(preds, ex);\n        const grad = computeGradient(errs, ex);\n        const newTheta = [\n          prevTheta[0] - ex.alpha * grad[0],\n          prevTheta[1] - ex.alpha * grad[1],\n        ];\n        setPath(prev => [...prev, newTheta]);\n        setGradient(grad);\n        return newTheta;\n      });\n      setIteration(prev => {\n        if (prev >= 49) clearInterval(iterRef.current);\n        return prev + 1;\n      });\n    }, 80);\n\n    return () => { if (iterRef.current) clearInterval(iterRef.current); };\n  }, [iterating, exampleIdx]);\n\n  // Mouse handlers for dragging\n  const getMouseTheta = (e) => {\n    const canvas = contourRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    const [t0Min, t0Max] = ex.t0Range;\n    const [t1Min, t1Max] = ex.t1Range;\n    \n    const t0 = t0Min + ((x - padding) / plotSize) * (t0Max - t0Min);\n    const t1 = t1Max - ((y - padding) / plotSize) * (t1Max - t1Min);\n    \n    return [\n      Math.max(t0Min, Math.min(t0Max, t0)),\n      Math.max(t1Min, Math.min(t1Max, t1)),\n    ];\n  };\n\n  const handleMouseDown = (e) => {\n    if (step > 0) return;\n    setDragging(true);\n    const newTheta = getMouseTheta(e);\n    setTheta(newTheta);\n    setPath([newTheta]);\n  };\n\n  const handleMouseMove = (e) => {\n    if (!dragging || step > 0) return;\n    const newTheta = getMouseTheta(e);\n    setTheta(newTheta);\n    setPath([newTheta]);\n  };\n\n  const handleMouseUp = () => {\n    setDragging(false);\n  };\n\n  // Scatter plot\n  useEffect(() => {\n    const canvas = scatterRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    const xVals = ex.X.map(row => row[1]);\n    const yVals = ex.y;\n    const xMin = Math.min(...xVals) - 0.5;\n    const xMax = Math.max(...xVals) + 0.5;\n    const yMin = Math.min(...yVals, 0) - 0.5;\n    const yMax = Math.max(...yVals) + 1.5;\n\n    const scaleX = (x) => padding + ((x - xMin) / (xMax - xMin)) * plotSize;\n    const scaleY = (y) => size - padding - ((y - yMin) / (yMax - yMin)) * plotSize;\n\n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let i = 0; i <= 4; i++) {\n      const x = padding + (i / 4) * plotSize;\n      const y = padding + (i / 4) * plotSize;\n      ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, size - padding); ctx.stroke();\n      ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(size - padding, y); ctx.stroke();\n    }\n\n    ctx.fillStyle = theme.colors.textMuted;\n    ctx.font = '9px JetBrains Mono, monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('x', size - 12, size - padding + 4);\n    ctx.fillText('y', padding - 4, 16);\n\n    // Regression line (always show when exploring or after step 1)\n    const showLine = step >= 1 || step === 0;\n    if (showLine) {\n      ctx.strokeStyle = step >= 4 ? theme.colors.green : theme.colors.blue;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(scaleX(xMin), scaleY(theta[0] + theta[1] * xMin));\n      ctx.lineTo(scaleX(xMax), scaleY(theta[0] + theta[1] * xMax));\n      ctx.stroke();\n    }\n\n    // Error lines\n    if (step >= 2 && step < 6 && errors.length > 0) {\n      ctx.strokeStyle = theme.colors.negative;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([4, 4]);\n      ex.X.forEach((row, i) => {\n        const x = row[1];\n        const pred = theta[0] + theta[1] * x;\n        ctx.beginPath();\n        ctx.moveTo(scaleX(x), scaleY(ex.y[i]));\n        ctx.lineTo(scaleX(x), scaleY(pred));\n        ctx.stroke();\n      });\n      ctx.setLineDash([]);\n    }\n\n    // Data points\n    ex.X.forEach((row, i) => {\n      ctx.fillStyle = theme.colors.pink;\n      ctx.beginPath();\n      ctx.arc(scaleX(row[1]), scaleY(ex.y[i]), 5, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Predictions\n    if (step >= 1) {\n      ex.X.forEach((row) => {\n        ctx.fillStyle = theme.colors.blue;\n        ctx.beginPath();\n        ctx.arc(scaleX(row[1]), scaleY(theta[0] + theta[1] * row[1]), 3, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n  }, [step, theta, errors, exampleIdx, iteration]);\n\n  // Contour plot\n  useEffect(() => {\n    const canvas = contourRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    const [t0Min, t0Max] = ex.t0Range;\n    const [t1Min, t1Max] = ex.t1Range;\n\n    const scaleX = (t0) => padding + ((t0 - t0Min) / (t0Max - t0Min)) * plotSize;\n    const scaleY = (t1) => size - padding - ((t1 - t1Min) / (t1Max - t1Min)) * plotSize;\n\n    // Compute loss grid\n    const resolution = 50;\n    const lossGrid = [];\n    let minLoss = Infinity, maxLoss = 0;\n    \n    for (let i = 0; i < resolution; i++) {\n      lossGrid[i] = [];\n      for (let j = 0; j < resolution; j++) {\n        const t0 = t0Min + (i / (resolution - 1)) * (t0Max - t0Min);\n        const t1 = t1Min + (j / (resolution - 1)) * (t1Max - t1Min);\n        const loss = computeLoss([t0, t1], ex);\n        lossGrid[i][j] = loss;\n        minLoss = Math.min(minLoss, loss);\n        maxLoss = Math.max(maxLoss, loss);\n      }\n    }\n\n    // Draw heatmap\n    const cellW = plotSize / resolution;\n    const cellH = plotSize / resolution;\n    \n    for (let i = 0; i < resolution; i++) {\n      for (let j = 0; j < resolution; j++) {\n        const loss = lossGrid[i][j];\n        const normalized = Math.pow((loss - minLoss) / (maxLoss - minLoss + 0.001), 0.5);\n        const hue = 260 - normalized * 60;\n        const lightness = 15 + (1 - normalized) * 25;\n        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;\n        ctx.fillRect(\n          padding + i * cellW,\n          size - padding - (j + 1) * cellH,\n          cellW + 1,\n          cellH + 1\n        );\n      }\n    }\n\n    // Contour lines\n    ctx.strokeStyle = 'rgba(255,255,255,0.15)';\n    ctx.lineWidth = 1;\n    const contourLevels = [0.1, 0.5, 1, 2, 4, 8].filter(l => l >= minLoss && l <= maxLoss);\n    contourLevels.forEach(level => {\n      for (let i = 0; i < resolution - 1; i++) {\n        for (let j = 0; j < resolution - 1; j++) {\n          const corners = [lossGrid[i][j], lossGrid[i+1][j], lossGrid[i+1][j+1], lossGrid[i][j+1]];\n          const above = corners.map(c => c > level);\n          if (above.some(a => a) && above.some(a => !a)) {\n            const t0 = t0Min + ((i + 0.5) / (resolution - 1)) * (t0Max - t0Min);\n            const t1 = t1Min + ((j + 0.5) / (resolution - 1)) * (t1Max - t1Min);\n            ctx.beginPath();\n            ctx.arc(scaleX(t0), scaleY(t1), 1, 0, Math.PI * 2);\n            ctx.stroke();\n          }\n        }\n      }\n    });\n\n    // Axes\n    ctx.fillStyle = theme.colors.textMuted;\n    ctx.font = '9px JetBrains Mono, monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('theta0', size / 2, size - 8);\n    ctx.save();\n    ctx.translate(10, size / 2);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText('theta1', 0, 0);\n    ctx.restore();\n\n    // Path\n    if (path.length > 1) {\n      ctx.strokeStyle = theme.colors.green;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      path.forEach((p, i) => {\n        const x = scaleX(p[0]);\n        const y = scaleY(p[1]);\n        if (i === 0) ctx.moveTo(x, y);\n        else ctx.lineTo(x, y);\n      });\n      ctx.stroke();\n\n      path.forEach((p, i) => {\n        if (i < path.length - 1 && i % 5 !== 0 && i !== 0) return;\n        ctx.fillStyle = i === path.length - 1 ? theme.colors.green : 'rgba(163, 230, 53, 0.5)';\n        ctx.beginPath();\n        ctx.arc(scaleX(p[0]), scaleY(p[1]), i === path.length - 1 ? 6 : 3, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n\n    // Current position\n    const cx = scaleX(theta[0]);\n    const cy = scaleY(theta[1]);\n    \n    ctx.fillStyle = theme.colors.green + '40';\n    ctx.beginPath();\n    ctx.arc(cx, cy, 14, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = theme.colors.green;\n    ctx.beginPath();\n    ctx.arc(cx, cy, 7, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Drag hint at step 0\n    if (step === 0) {\n      ctx.fillStyle = theme.colors.text;\n      ctx.font = '8px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText('drag me!', cx, cy - 18);\n    }\n\n    // Gradient arrow (steps 3, 4, 5)\n    if ((step === 3 || step === 4 || step === 5) && (gradient[0] !== 0 || gradient[1] !== 0)) {\n      const gradMag = Math.sqrt(gradient[0] ** 2 + gradient[1] ** 2);\n      const scale = 35 / Math.max(gradMag, 0.5);\n      const gx = gradient[0] * scale;\n      const gy = -gradient[1] * scale;\n      \n      ctx.strokeStyle = theme.colors.orange;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(cx, cy);\n      ctx.lineTo(cx + gx, cy + gy);\n      ctx.stroke();\n      \n      const angle = Math.atan2(gy, gx);\n      ctx.beginPath();\n      ctx.moveTo(cx + gx, cy + gy);\n      ctx.lineTo(cx + gx - 8 * Math.cos(angle - 0.4), cy + gy - 8 * Math.sin(angle - 0.4));\n      ctx.lineTo(cx + gx - 8 * Math.cos(angle + 0.4), cy + gy - 8 * Math.sin(angle + 0.4));\n      ctx.closePath();\n      ctx.fillStyle = theme.colors.orange;\n      ctx.fill();\n\n      if (step === 3) {\n        ctx.strokeStyle = theme.colors.green;\n        ctx.lineWidth = 2;\n        ctx.setLineDash([4, 4]);\n        ctx.beginPath();\n        ctx.moveTo(cx, cy);\n        ctx.lineTo(cx - gx * 0.5, cy - gy * 0.5);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n    }\n\n    // Start marker\n    if (path.length > 0 && step > 0) {\n      const startX = scaleX(path[0][0]);\n      const startY = scaleY(path[0][1]);\n      ctx.strokeStyle = theme.colors.textMuted;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(startX, startY, 8, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.fillStyle = theme.colors.textMuted;\n      ctx.font = '8px JetBrains Mono, monospace';\n      ctx.fillText('start', startX, startY - 12);\n    }\n\n  }, [step, theta, path, gradient, exampleIdx, iteration, dragging]);\n\n  const formatNum = (n) => n.toFixed(3);\n  const currentLoss = computeLoss(theta, ex);\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          Gradient Descent for Linear Regression\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          {step === 0 ? 'Drag the ball to explore, then click Start' : 'Watch the descent through the loss landscape'}\n        </div>\n      </div>\n\n      {/* Example Tabs */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '12px' }}>\n        {examples.map((e, idx) => (\n          <button\n            key={idx}\n            onClick={() => { setExampleIdx(idx); reset(); }}\n            style={{\n              padding: '6px 12px',\n              background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n              border: 'none',\n              borderRadius: '6px',\n              color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n            }}\n          >\n            {e.name}\n          </button>\n        ))}\n      </div>\n\n      {/* Dual Visualization */}\n      <div style={{ \n        display: 'flex', \n        gap: '12px', \n        justifyContent: 'center', \n        marginBottom: '12px',\n        flexWrap: 'wrap',\n      }}>\n        <div style={{ textAlign: 'center' }}>\n          <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '4px' }}>\n            Data + Fit Line\n          </div>\n          <canvas\n            ref={scatterRef}\n            width={size}\n            height={size}\n            style={{ borderRadius: '8px', border: '1px solid ' + theme.colors.border }}\n          />\n        </div>\n\n        <div style={{ textAlign: 'center' }}>\n          <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginBottom: '4px' }}>\n            Loss Landscape (darker = lower)\n          </div>\n          <canvas\n            ref={contourRef}\n            width={size}\n            height={size}\n            style={{ \n              borderRadius: '8px', \n              border: '1px solid ' + (step === 0 ? theme.colors.primary : theme.colors.border),\n              cursor: step === 0 ? 'grab' : 'default',\n            }}\n            onMouseDown={handleMouseDown}\n            onMouseMove={handleMouseMove}\n            onMouseUp={handleMouseUp}\n            onMouseLeave={handleMouseUp}\n          />\n        </div>\n      </div>\n\n      {/* Stats Display */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        gap: '10px',\n        marginBottom: '12px',\n        flexWrap: 'wrap',\n      }}>\n        <div style={{\n          padding: '6px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n          border: '1px solid ' + (step >= 4 ? theme.colors.green : theme.colors.border),\n        }}>\n          <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>theta0</span>\n          <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.green }}>\n            {formatNum(theta[0])}\n          </div>\n        </div>\n        <div style={{\n          padding: '6px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n          border: '1px solid ' + (step >= 4 ? theme.colors.green : theme.colors.border),\n        }}>\n          <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>theta1</span>\n          <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.green }}>\n            {formatNum(theta[1])}\n          </div>\n        </div>\n        <div style={{\n          padding: '6px 10px',\n          background: theme.colors.surface,\n          borderRadius: '6px',\n          border: '1px solid ' + theme.colors.yellow,\n        }}>\n          <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>loss</span>\n          <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.yellow }}>\n            {formatNum(currentLoss)}\n          </div>\n        </div>\n        {iteration > 0 && (\n          <div style={{\n            padding: '6px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n          }}>\n            <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>iter</span>\n            <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.primary }}>\n              {iteration}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0 || playing}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps || playing}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps ? 0.5 : 1,\n          }}\n        >\n          {step === 0 ? 'Start' : step < totalSteps ? 'Next Step' : 'Complete!'}\n        </button>\n        <button\n          onClick={auto}\n          disabled={playing || step >= totalSteps}\n          style={{\n            padding: '8px 12px',\n            background: playing ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: playing ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: playing ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {playing ? '...' : '>>'}\n        </button>\n        <button\n          onClick={reset}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Math Details */}\n      {step >= 1 && (\n        <div style={{\n          padding: '10px',\n          background: theme.colors.surfaceAlt,\n          borderRadius: '8px',\n          marginBottom: '12px',\n        }}>\n          {step === 1 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.blue, marginBottom: '6px', fontWeight: '600' }}>\n                Predictions = theta0 + theta1 * x\n              </div>\n              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>\n                {ex.X.map((row, i) => (\n                  <div key={i} style={{\n                    padding: '4px 8px',\n                    background: theme.colors.surface,\n                    borderRadius: '4px',\n                    fontSize: '10px',\n                  }}>\n                    <span style={{ color: theme.colors.textMuted }}>x={row[1]}: </span>\n                    <span style={{ color: theme.colors.blue }}>\n                      {formatNum(theta[0] + theta[1] * row[1])}\n                    </span>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {step === 2 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.negative, marginBottom: '6px', fontWeight: '600' }}>\n                Errors = prediction - actual\n              </div>\n              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>\n                {errors.map((err, i) => (\n                  <div key={i} style={{\n                    padding: '4px 8px',\n                    background: theme.colors.surface,\n                    borderRadius: '4px',\n                    fontSize: '10px',\n                  }}>\n                    <span style={{ color: theme.colors.negative }}>{formatNum(err)}</span>\n                  </div>\n                ))}\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '6px' }}>\n                Loss = mean(errors squared) = {formatNum(currentLoss)}\n              </div>\n            </div>\n          )}\n\n          {step === 3 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.orange, marginBottom: '6px', fontWeight: '600' }}>\n                Gradient points uphill (orange arrow)\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary, marginBottom: '6px' }}>\n                We move opposite (green dashed) to decrease loss\n              </div>\n              <div style={{ display: 'flex', gap: '12px' }}>\n                <div style={{ padding: '6px 10px', background: theme.colors.surface, borderRadius: '4px' }}>\n                  <span style={{ color: theme.colors.textMuted, fontSize: '9px' }}>grad[0]: </span>\n                  <span style={{ color: theme.colors.orange, fontSize: '12px' }}>{formatNum(gradient[0])}</span>\n                </div>\n                <div style={{ padding: '6px 10px', background: theme.colors.surface, borderRadius: '4px' }}>\n                  <span style={{ color: theme.colors.textMuted, fontSize: '9px' }}>grad[1]: </span>\n                  <span style={{ color: theme.colors.orange, fontSize: '12px' }}>{formatNum(gradient[1])}</span>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {(step === 4 || step === 5) && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.green, marginBottom: '6px', fontWeight: '600' }}>\n                theta = theta - alpha * gradient (iteration {iteration})\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                alpha = {ex.alpha} (learning rate)\n              </div>\n              <div style={{ marginTop: '6px', fontSize: '10px' }}>\n                <span style={{ color: theme.colors.textMuted }}>New position: </span>\n                <span style={{ color: theme.colors.green }}>[{formatNum(theta[0])}, {formatNum(theta[1])}]</span>\n                <span style={{ color: theme.colors.textMuted, marginLeft: '8px' }}>Loss: </span>\n                <span style={{ color: theme.colors.yellow }}>{formatNum(currentLoss)}</span>\n              </div>\n            </div>\n          )}\n\n          {step === 6 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.primary, marginBottom: '6px', fontWeight: '600' }}>\n                Running gradient descent...\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                Watch the path trace through the loss landscape\n              </div>\n              {iteration >= 50 && (\n                <div style={{ marginTop: '8px', fontSize: '11px', color: theme.colors.positive }}>\n                  Converged at [{formatNum(theta[0])}, {formatNum(theta[1])}] with loss {formatNum(currentLoss)}\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        The gradient always points uphill. By moving opposite to it, we descend into the valley where loss is minimized.\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}