{
  "problem_id": 43,
  "title": "Implement Ridge Regression Loss Function",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "\nimport React, { useState, useMemo } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    orange: '#fb923c',\n    trueLine: '#22c55e',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// True relationship is simple linear!\nconst trueFunction = (x) => 0.5 * x + 1;\n\n// Seeded random\nconst seededRandom = (seed) => {\n  const x = Math.sin(seed * 9999) * 10000;\n  return x - Math.floor(x);\n};\n\n// Polynomial features: [1, x, x¬≤, x¬≥, ...]\nconst polyFeatures = (x, degree) => {\n  const features = [];\n  for (let i = 0; i <= degree; i++) {\n    features.push(Math.pow(x, i));\n  }\n  return features;\n};\n\n// Matrix operations for polynomial regression\nconst fitPolynomial = (data, degree, alpha = 0) => {\n  const n = data.length;\n  const numFeatures = degree + 1;\n  \n  // Build X matrix and y vector\n  const X = data.map(p => polyFeatures(p.x, degree));\n  const y = data.map(p => p.y);\n  \n  // X'X\n  const XtX = [];\n  for (let i = 0; i < numFeatures; i++) {\n    XtX[i] = [];\n    for (let j = 0; j < numFeatures; j++) {\n      let sum = 0;\n      for (let k = 0; k < n; k++) {\n        sum += X[k][i] * X[k][j];\n      }\n      // Add ridge penalty to diagonal\n      if (i === j && alpha > 0) {\n        sum += alpha * n;\n      }\n      XtX[i][j] = sum;\n    }\n  }\n  \n  // X'y\n  const Xty = [];\n  for (let i = 0; i < numFeatures; i++) {\n    let sum = 0;\n    for (let k = 0; k < n; k++) {\n      sum += X[k][i] * y[k];\n    }\n    Xty[i] = sum;\n  }\n  \n  // Solve using Gaussian elimination (simple for small matrices)\n  const augmented = XtX.map((row, i) => [...row, Xty[i]]);\n  \n  // Forward elimination\n  for (let i = 0; i < numFeatures; i++) {\n    // Find pivot\n    let maxRow = i;\n    for (let k = i + 1; k < numFeatures; k++) {\n      if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {\n        maxRow = k;\n      }\n    }\n    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];\n    \n    // Eliminate column\n    for (let k = i + 1; k < numFeatures; k++) {\n      const factor = augmented[k][i] / augmented[i][i];\n      for (let j = i; j <= numFeatures; j++) {\n        augmented[k][j] -= factor * augmented[i][j];\n      }\n    }\n  }\n  \n  // Back substitution\n  const weights = new Array(numFeatures).fill(0);\n  for (let i = numFeatures - 1; i >= 0; i--) {\n    weights[i] = augmented[i][numFeatures];\n    for (let j = i + 1; j < numFeatures; j++) {\n      weights[i] -= augmented[i][j] * weights[j];\n    }\n    weights[i] /= augmented[i][i];\n  }\n  \n  return weights;\n};\n\n// Evaluate polynomial at x\nconst evalPoly = (weights, x) => {\n  let result = 0;\n  for (let i = 0; i < weights.length; i++) {\n    result += weights[i] * Math.pow(x, i);\n  }\n  return result;\n};\n\nexport default function RidgePlayground() {\n  const [step, setStep] = useState(0);\n  const [seed, setSeed] = useState(42);\n  const [noise, setNoise] = useState(0.6);\n  const [alpha, setAlpha] = useState(0.1);\n  const [showTest, setShowTest] = useState(false);\n  const [revealed, setRevealed] = useState(false);\n  \n  const DEGREE = 5; // High degree polynomial = many parameters = overfitting!\n\n  // Generate noisy training data\n  const trainData = useMemo(() => {\n    const points = [];\n    for (let i = 0; i < 8; i++) {\n      const x = 1 + i * 0.7; // Range from 1 to 5.9\n      const trueY = trueFunction(x);\n      const noiseVal = (seededRandom(seed + i * 7) - 0.5) * 2 * noise;\n      points.push({ x, y: trueY + noiseVal });\n    }\n    return points;\n  }, [seed, noise]);\n\n  // Generate test data - WITHIN training range (no extrapolation)\n  const testData = useMemo(() => {\n    const points = [];\n    const testXs = [1.3, 2.1, 3.2, 4.3, 5.1]; // Between training points\n    testXs.forEach((x, i) => {\n      const trueY = trueFunction(x);\n      const noiseVal = (seededRandom(seed + 100 + i * 13) - 0.5) * 0.2;\n      points.push({ x, y: trueY + noiseVal });\n    });\n    return points;\n  }, [seed]);\n\n  // Fit models\n  const mseWeights = useMemo(() => fitPolynomial(trainData, DEGREE, 0), [trainData]);\n  const ridgeWeights = useMemo(() => fitPolynomial(trainData, DEGREE, alpha), [trainData, alpha]);\n\n  // Calculate errors with safety for extreme values\n  const calcError = (weights, data) => {\n    let totalError = 0;\n    data.forEach(p => {\n      const pred = evalPoly(weights, p.x);\n      const error = Math.pow(p.y - pred, 2);\n      // Cap individual errors to avoid Infinity display\n      totalError += Math.min(error, 1000);\n    });\n    return totalError / data.length;\n  };\n\n  const mseTrainError = calcError(mseWeights, trainData);\n  const ridgeTrainError = calcError(ridgeWeights, trainData);\n  const mseTestError = calcError(mseWeights, testData);\n  const ridgeTestError = calcError(ridgeWeights, testData);\n\n  // SVG setup\n  const width = 360;\n  const height = 260;\n  const pad = 35;\n  const xMin = 0.5, xMax = 6.5;\n  const yMin = 0, yMax = 5.5;\n  const xScale = (x) => pad + ((x - xMin) / (xMax - xMin)) * (width - 2 * pad);\n  const yScale = (y) => height - pad - ((y - yMin) / (yMax - yMin)) * (height - 2 * pad);\n\n  // Generate curve points with proper clamping\n  const generateCurve = (weights) => {\n    const points = [];\n    for (let x = xMin + 0.1; x <= xMax - 0.1; x += 0.05) {\n      const y = evalPoly(weights, x);\n      // Skip NaN or Infinity\n      if (!isFinite(y)) continue;\n      // Only include points in reasonable range\n      if (y >= yMin - 2 && y <= yMax + 2) {\n        points.push({ x, y: Math.max(yMin - 0.5, Math.min(yMax + 0.5, y)) });\n      } else {\n        // Break the line if value goes crazy\n        if (points.length > 0) {\n          points.push({ x, y: y > yMax ? yMax + 0.5 : yMin - 0.5, break: true });\n        }\n      }\n    }\n    return points;\n  };\n\n  // Convert points to SVG path with breaks\n  const pointsToPath = (points) => {\n    if (points.length === 0) return '';\n    let path = '';\n    let needsMove = true;\n    points.forEach((p, i) => {\n      if (p.break || needsMove) {\n        path += ` M ${xScale(p.x)} ${yScale(p.y)}`;\n        needsMove = false;\n      } else {\n        path += ` L ${xScale(p.x)} ${yScale(p.y)}`;\n      }\n    });\n    return path;\n  };\n\n  const mseCurve = useMemo(() => generateCurve(mseWeights), [mseWeights]);\n  const ridgeCurve = useMemo(() => generateCurve(ridgeWeights), [ridgeWeights]);\n\n  const regenerate = () => {\n    setSeed(s => s + 1);\n    setShowTest(false);\n    setRevealed(false);\n    setStep(0);\n  };\n\n  const nextStep = () => {\n    if (step === 0) setStep(1);\n    else if (step === 1) setStep(2);\n    else if (step === 2) { setShowTest(true); setStep(3); }\n    else if (step === 3) { setRevealed(true); setStep(4); }\n  };\n\n  const ridgeWins = ridgeTestError < mseTestError;\n\n  const stepMessages = [\n    { \n      title: \"üìä Training data (with noise)\", \n      sub: \"The true pattern is simple, but our data is noisy. Can we recover it?\" \n    },\n    { \n      title: \"üìà Standard regression (MSE)\", \n      sub: `Fits a degree-${DEGREE} polynomial. Look how wiggly it is! It's chasing the noise.`\n    },\n    { \n      title: \"üõ°Ô∏è Ridge regression\", \n      sub: \"Same polynomial, but penalizes large coefficients. Much smoother!\"\n    },\n    { \n      title: \"üÜï New data arrives!\", \n      sub: \"Let's see which model predicts better on data it's never seen...\"\n    },\n    { \n      title: ridgeWins ? \"üèÜ Ridge wins!\" : \"üìä MSE got lucky!\", \n      sub: ridgeWins \n        ? `Ridge error: ${ridgeTestError.toFixed(3)} vs MSE: ${mseTestError.toFixed(3)}. Simpler = better!`\n        : `Try increasing noise or clicking üé≤ ‚Äî Ridge usually wins with noisy data.`\n    },\n  ];\n\n  return (\n    <div style={{ minHeight: '100vh', background: theme.colors.background, padding: '16px', fontFamily: theme.font, color: theme.colors.text }}>\n      \n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '16px' }}>\n        <div style={{ fontSize: '22px', fontWeight: '700', marginBottom: '4px' }}>\n          Why Ridge Regression?\n        </div>\n        <div style={{ fontSize: '13px', color: theme.colors.textSecondary }}>\n          Fitting a degree-{DEGREE} polynomial ({DEGREE + 1} parameters!) to {trainData.length} noisy points\n        </div>\n      </div>\n\n      {/* Progress dots */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '16px' }}>\n        {[0,1,2,3,4].map(i => (\n          <div key={i} style={{\n            width: i === step ? '24px' : '10px',\n            height: '10px',\n            borderRadius: '5px',\n            background: i <= step ? theme.colors.primary : theme.colors.border,\n            transition: 'all 0.3s',\n            cursor: 'pointer'\n          }} onClick={() => {\n            setStep(i);\n            if (i >= 3) setShowTest(true);\n            if (i >= 4) setRevealed(true);\n            if (i < 3) setShowTest(false);\n            if (i < 4) setRevealed(false);\n          }} />\n        ))}\n      </div>\n\n      {/* Message box */}\n      <div style={{ \n        padding: '14px 18px', \n        background: theme.colors.surface, \n        borderRadius: '12px', \n        marginBottom: '16px',\n        borderLeft: `4px solid ${step >= 4 && ridgeWins ? theme.colors.yellow : theme.colors.primary}`\n      }}>\n        <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '4px' }}>\n          {stepMessages[step].title}\n        </div>\n        <div style={{ fontSize: '13px', color: theme.colors.textSecondary }}>\n          {stepMessages[step].sub}\n        </div>\n      </div>\n\n      {/* Main visualization */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '16px', marginBottom: '16px' }}>\n        <svg width={width} height={height} style={{ display: 'block', margin: '0 auto', background: theme.colors.surfaceAlt, borderRadius: '10px' }}>\n          <defs>\n            <clipPath id=\"plotClip\">\n              <rect x={pad} y={10} width={width - 2*pad} height={height - pad - 10} />\n            </clipPath>\n          </defs>\n          \n          {/* Grid */}\n          {[1,2,3,4,5,6].map(v => (\n            <line key={`gx-${v}`} x1={xScale(v)} y1={15} x2={xScale(v)} y2={height-pad} stroke={theme.colors.border} strokeWidth=\"1\" />\n          ))}\n          {[1,2,3,4,5].map(v => (\n            <line key={`gy-${v}`} x1={pad} y1={yScale(v)} x2={width-pad} y2={yScale(v)} stroke={theme.colors.border} strokeWidth=\"1\" />\n          ))}\n\n          <g clipPath=\"url(#plotClip)\">\n            {/* True line (shown at end) */}\n            {revealed && (\n              <line \n                x1={xScale(0.5)} y1={yScale(trueFunction(0.5))}\n                x2={xScale(6.5)} y2={yScale(trueFunction(6.5))}\n                stroke={theme.colors.trueLine} strokeWidth=\"3\" strokeDasharray=\"8 4\" opacity=\"0.8\"\n              />\n            )}\n            \n            {/* MSE polynomial curve */}\n            {step >= 1 && (\n              <path\n                d={pointsToPath(mseCurve)}\n                fill=\"none\"\n                stroke={theme.colors.blue}\n                strokeWidth=\"3\"\n              />\n            )}\n            \n            {/* Ridge polynomial curve */}\n            {step >= 2 && (\n              <path\n                d={pointsToPath(ridgeCurve)}\n                fill=\"none\"\n                stroke={theme.colors.yellow}\n                strokeWidth=\"3\"\n              />\n            )}\n          </g>\n          \n          {/* Training points */}\n          {trainData.map((p, i) => (\n            <circle key={`train-${i}`} cx={xScale(p.x)} cy={yScale(p.y)} r=\"8\" fill={theme.colors.text} stroke={theme.colors.background} strokeWidth=\"2\" />\n          ))}\n          \n          {/* Test points */}\n          {showTest && testData.map((p, i) => (\n            <g key={`test-${i}`}>\n              <circle cx={xScale(p.x)} cy={yScale(p.y)} r=\"8\" fill={theme.colors.orange} stroke={theme.colors.background} strokeWidth=\"2\" />\n              <text x={xScale(p.x)} y={yScale(p.y) - 12} fill={theme.colors.orange} fontSize=\"9\" textAnchor=\"middle\">new</text>\n            </g>\n          ))}\n        </svg>\n\n        {/* Legend */}\n        <div style={{ display: 'flex', gap: '16px', justifyContent: 'center', marginTop: '12px', fontSize: '11px', flexWrap: 'wrap' }}>\n          <span>‚óè Train</span>\n          {showTest && <span style={{ color: theme.colors.orange }}>‚óè Test</span>}\n          {step >= 1 && <span><span style={{ color: theme.colors.blue }}>‚îÅ</span> MSE (wiggly!)</span>}\n          {step >= 2 && <span><span style={{ color: theme.colors.yellow }}>‚îÅ</span> Ridge (smooth)</span>}\n          {revealed && <span><span style={{ color: theme.colors.trueLine }}>‚îÖ</span> True pattern</span>}\n        </div>\n      </div>\n\n      {/* Results comparison */}\n      {revealed && (\n        <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', flexWrap: 'wrap', justifyContent: 'center' }}>\n          <div style={{ \n            padding: '12px 16px', \n            background: !ridgeWins ? `${theme.colors.blue}20` : theme.colors.surface, \n            borderRadius: '10px', \n            border: `2px solid ${theme.colors.blue}`,\n            minWidth: '140px',\n            textAlign: 'center'\n          }}>\n            <div style={{ fontSize: '11px', color: theme.colors.blue, marginBottom: '4px' }}>MSE (overfits)</div>\n            <div style={{ fontSize: '10px', color: theme.colors.textMuted }}>Train: {mseTrainError.toFixed(3)}</div>\n            <div style={{ fontSize: '16px', fontWeight: '600' }}>Test: {mseTestError.toFixed(3)}</div>\n          </div>\n          <div style={{ \n            padding: '12px 16px', \n            background: ridgeWins ? `${theme.colors.yellow}20` : theme.colors.surface, \n            borderRadius: '10px', \n            border: `2px solid ${theme.colors.yellow}`,\n            minWidth: '140px',\n            textAlign: 'center'\n          }}>\n            <div style={{ fontSize: '11px', color: theme.colors.yellow, marginBottom: '4px' }}>Ridge (constrained)</div>\n            <div style={{ fontSize: '10px', color: theme.colors.textMuted }}>Train: {ridgeTrainError.toFixed(3)}</div>\n            <div style={{ fontSize: '16px', fontWeight: '600' }}>Test: {ridgeTestError.toFixed(3)}</div>\n          </div>\n        </div>\n      )}\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '16px', flexWrap: 'wrap', justifyContent: 'center' }}>\n        <button \n          onClick={nextStep} \n          disabled={step >= 4}\n          style={{ \n            padding: '12px 24px',\n            background: step >= 4 ? theme.colors.positive : theme.colors.primary,\n            border: 'none',\n            borderRadius: '10px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '14px',\n            fontWeight: '600',\n            cursor: step >= 4 ? 'default' : 'pointer',\n            flex: '1',\n            maxWidth: '220px'\n          }}\n        >\n          {step === 0 ? \"Fit MSE ‚Üí\" : \n           step === 1 ? \"Fit Ridge ‚Üí\" : \n           step === 2 ? \"Test on new data ‚Üí\" : \n           step === 3 ? \"See results ‚Üí\" : \n           \"‚úì Done\"}\n        </button>\n        <button onClick={regenerate} style={{ \n          padding: '12px 16px',\n          background: theme.colors.surface,\n          border: `2px solid ${theme.colors.border}`,\n          borderRadius: '10px',\n          color: theme.colors.text,\n          fontFamily: theme.font,\n          fontSize: '14px',\n          cursor: 'pointer',\n        }}>\n          üé≤ New Data\n        </button>\n      </div>\n\n      {/* Sliders */}\n      <div style={{ background: theme.colors.surface, borderRadius: '12px', padding: '16px', marginBottom: '16px' }}>\n        <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap' }}>\n          <div style={{ flex: 1, minWidth: '140px' }}>\n            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}>\n              <span style={{ fontSize: '12px', color: theme.colors.negative }}>Noise</span>\n              <span style={{ fontSize: '12px' }}>{noise.toFixed(1)}</span>\n            </div>\n            <input type=\"range\" min=\"0.2\" max=\"1.2\" step=\"0.1\" value={noise} \n              onChange={e => { setNoise(parseFloat(e.target.value)); regenerate(); }}\n              style={{ width: '100%', accentColor: theme.colors.negative }} />\n          </div>\n          <div style={{ flex: 1, minWidth: '140px' }}>\n            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}>\n              <span style={{ fontSize: '12px', color: theme.colors.yellow }}>Ridge Œ±</span>\n              <span style={{ fontSize: '12px' }}>{alpha.toFixed(2)}</span>\n            </div>\n            <input type=\"range\" min=\"0.01\" max=\"0.5\" step=\"0.01\" value={alpha} \n              onChange={e => setAlpha(parseFloat(e.target.value))}\n              style={{ width: '100%', accentColor: theme.colors.yellow }} />\n          </div>\n        </div>\n      </div>\n\n      {/* Key insight */}\n      <div style={{ padding: '14px 16px', background: theme.colors.surface, borderRadius: '10px' }}>\n        <div style={{ fontSize: '13px', color: theme.colors.textSecondary, lineHeight: 1.7, textAlign: 'center' }}>\n          <strong style={{ color: theme.colors.text }}>The problem:</strong> With {DEGREE + 1} parameters for just {trainData.length} points, \n          MSE can make the curve pass through every point ‚Äî but it's \n          <span style={{ color: theme.colors.blue }}> memorizing noise</span>, not learning the pattern.\n          <br/><br/>\n          <strong style={{ color: theme.colors.yellow }}>Ridge's solution:</strong> Penalize large coefficients ‚Üí smoother curves ‚Üí better predictions on new data.\n        </div>\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}