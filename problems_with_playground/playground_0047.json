{
  "problem_id": 47,
  "title": "Implement Gradient Descent Variants with MSE Loss",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useMemo, useRef } from 'react';\n\n// --- THEME ---\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#050505',\n    surface: '#121212',\n    surfaceAlt: '#1E1E1E',\n    border: '#333333',\n    text: '#ffffff',\n    textSecondary: '#a0a0a0',\n    accent: '#38bdf8', // Blue for Batch\n    stochastic: '#f43f5e', // Red for SGD\n    minibatch: '#fbbf24', // Yellow for Mini-Batch\n    grid: '#2a2a2a',\n    success: '#4ade80'\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// --- SYNTHETIC DATA ---\nconst TRUE_W = 2.0;\nconst TRUE_B = 1.0;\nconst X_DATA = [1, 2, 3, 4, 5, 6, 7, 8];\nconst NOISE = [0.1, -0.2, 0.05, 0.3, -0.1, 0.15, -0.3, 0.0];\nconst Y_DATA = X_DATA.map((x, i) => (TRUE_W * x + TRUE_B) + NOISE[i]); \n\nconst calculateMSE = (w, b) => {\n  let sumError = 0;\n  for (let i = 0; i < X_DATA.length; i++) {\n    const pred = w * X_DATA[i] + b;\n    const error = pred - Y_DATA[i];\n    sumError += error * error;\n  }\n  return sumError / X_DATA.length;\n};\n\nexport default function GradientDescentPlayground() {\n  // State\n  const [method, setMethod] = useState('batch'); \n  const [learningRate, setLearningRate] = useState(0.01);\n  const [batchSize, setBatchSize] = useState(2);\n  const [path, setPath] = useState([]); \n  const [currentStep, setCurrentStep] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  \n  const timerRef = useRef(null);\n\n  // --- SIMULATION ENGINE ---\n  useEffect(() => {\n    const newPath = [];\n    // Start at (0.5, 0)\n    let w = 0.5; \n    let b = 0.0;\n    \n    const iterations = 50; \n    const m = X_DATA.length;\n    \n    // Initial state\n    newPath.push({ w, b, loss: calculateMSE(w, b), dataIndices: [] });\n\n    for (let iter = 0; iter < iterations; iter++) {\n      if (method === 'batch') {\n        let grad_w = 0, grad_b = 0;\n        const allIndices = Array.from({length: m}, (_, i) => i);\n        for(let i=0; i<m; i++) {\n          const pred = w * X_DATA[i] + b;\n          const err = pred - Y_DATA[i];\n          grad_w += err * X_DATA[i];\n          grad_b += err;\n        }\n        w = w - learningRate * (2/m) * grad_w;\n        b = b - learningRate * (2/m) * grad_b;\n        newPath.push({ w, b, loss: calculateMSE(w, b), dataIndices: allIndices });\n      }\n      else if (method === 'stochastic') {\n        for(let i=0; i<m; i++) {\n          const pred = w * X_DATA[i] + b;\n          const err = pred - Y_DATA[i];\n          const grad_w = err * X_DATA[i];\n          const grad_b = err;\n          w = w - learningRate * 2 * grad_w;\n          b = b - learningRate * 2 * grad_b;\n          newPath.push({ w, b, loss: calculateMSE(w, b), dataIndices: [i] });\n        }\n      }\n      else if (method === 'mini_batch') {\n         for(let i=0; i<m; i+=batchSize) {\n            let grad_w = 0, grad_b = 0;\n            let currentBatchSize = 0;\n            const currentIndices = [];\n            for(let j=i; j<Math.min(i+batchSize, m); j++) {\n               const pred = w * X_DATA[j] + b;\n               const err = pred - Y_DATA[j];\n               grad_w += err * X_DATA[j];\n               grad_b += err;\n               currentBatchSize++;\n               currentIndices.push(j);\n            }\n            w = w - learningRate * (2/currentBatchSize) * grad_w;\n            b = b - learningRate * (2/currentBatchSize) * grad_b;\n            newPath.push({ w, b, loss: calculateMSE(w, b), dataIndices: currentIndices });\n         }\n      }\n    }\n    \n    setPath(newPath);\n    setCurrentStep(0);\n    setIsPlaying(true);\n  }, [method, learningRate, batchSize]);\n\n  // Animation Loop\n  useEffect(() => {\n    if (isPlaying) {\n      const speed = method === 'stochastic' ? 80 : 150;\n      timerRef.current = setInterval(() => {\n        setCurrentStep(prev => {\n          if (prev >= path.length - 1) {\n            setIsPlaying(false);\n            return prev;\n          }\n          return prev + 1;\n        });\n      }, speed);\n    }\n    return () => clearInterval(timerRef.current);\n  }, [isPlaying, path, method]);\n\n  const reset = () => {\n    setCurrentStep(0);\n    setIsPlaying(false);\n  };\n  \n  const stepForward = () => {\n    setIsPlaying(false);\n    setCurrentStep(prev => Math.min(prev + 1, path.length - 1));\n  };\n\n  const currentPoint = path[currentStep] || { w: 0, b: 0, loss: 0, dataIndices: [] };\n\n  return (\n    <div style={styles.container}>\n      {/* HEADER */}\n      <header style={styles.header}>\n        <div>\n          <h1 style={styles.title}>Gradient Descent Visualizer</h1>\n        </div>\n        <div style={styles.statusBox}>\n           <div style={{fontSize: 12, color:theme.colors.textMuted, letterSpacing: 1}}>CURRENT MSE LOSS</div>\n           <div style={{fontSize: 32, fontWeight:'bold', color: currentPoint.loss < 0.1 ? theme.colors.success : theme.colors.text, marginTop: 4}}>\n             {currentPoint.loss.toFixed(4)}\n           </div>\n        </div>\n      </header>\n\n      <div style={styles.mainLayout}>\n        \n        {/* SECTION 1: THE VISUALIZATION (Top) */}\n        <div style={styles.vizContainer}>\n           <div style={styles.overlayLabel}>Optimization Landscape (Loss)</div>\n           <ContourPlot \n             path={path} \n             currentStep={currentStep} \n             trueW={TRUE_W} \n             trueB={TRUE_B}\n             method={method}\n           />\n           \n           {/* INTEGRATED PLAYBACK CONTROLS */}\n           <div style={styles.controlsBar}>\n              <button style={styles.btn} onClick={reset}>Reset</button>\n              <button style={styles.btn} onClick={stepForward}>Step ➔</button>\n              <button \n                style={styles.btnPlay(method === 'batch' ? theme.colors.accent : method === 'stochastic' ? theme.colors.stochastic : theme.colors.minibatch)} \n                onClick={() => setIsPlaying(!isPlaying)}\n              >\n                {isPlaying ? 'Pause' : 'Play ▶'}\n              </button>\n           </div>\n        </div>\n\n        {/* SECTION 2: STRATEGY SELECTION (Grid Below Graph) */}\n        <div style={styles.strategyGrid}>\n           <MethodButton \n             active={method === 'batch'} \n             onClick={() => setMethod('batch')}\n             color={theme.colors.accent}\n             title=\"Batch\"\n             desc=\"Stable & Slow\"\n           />\n           <MethodButton \n             active={method === 'stochastic'} \n             onClick={() => setMethod('stochastic')}\n             color={theme.colors.stochastic}\n             title=\"SGD\"\n             desc=\"Fast & Noisy\"\n           />\n           <MethodButton \n             active={method === 'mini_batch'} \n             onClick={() => setMethod('mini_batch')}\n             color={theme.colors.minibatch}\n             title=\"Mini-Batch\"\n             desc=\"Balanced\"\n           />\n        </div>\n\n        {/* SECTION 3: HYPERPARAMETERS & DATA SCANNER */}\n        <div style={{display:'grid', gridTemplateColumns: '1fr 1fr', gap: 20}}>\n           {/* Hyperparams */}\n           <div style={styles.card}>\n              <div style={styles.cardHeader}>Hyperparameters</div>\n              <div style={styles.controlGroup}>\n                 <div style={styles.labelRow}>\n                   <span>Learning Rate (α)</span>\n                   <span style={{color: theme.colors.accent}}>{learningRate}</span>\n                 </div>\n                 <input \n                   type=\"range\" min=\"0.001\" max=\"0.05\" step=\"0.001\" \n                   value={learningRate} onChange={(e) => setLearningRate(parseFloat(e.target.value))} \n                   style={{width:'100%', accentColor: theme.colors.primary, height: 6}}\n                 />\n              </div>\n              {method === 'mini_batch' && (\n                <div style={styles.controlGroup}>\n                  <div style={styles.labelRow}>\n                    <span>Batch Size</span>\n                    <span style={{color: theme.colors.minibatch}}>{batchSize}</span>\n                  </div>\n                  <input \n                    type=\"range\" min=\"2\" max=\"6\" step=\"1\" \n                    value={batchSize} onChange={(e) => setBatchSize(parseInt(e.target.value))} \n                    style={{width:'100%', accentColor: theme.colors.minibatch, height: 6}}\n                  />\n                </div>\n              )}\n           </div>\n\n           {/* Data Scanner */}\n           <div style={styles.card}>\n              <div style={styles.cardHeader}>Data Scanner (Active Points)</div>\n              <div style={{display:'flex', gap: 4, marginTop: 12}}>\n                 {X_DATA.map((val, idx) => {\n                    const isActive = currentPoint.dataIndices.includes(idx);\n                    const activeColor = method==='batch'?theme.colors.accent:method==='stochastic'?theme.colors.stochastic:theme.colors.minibatch;\n                    return (\n                       <div key={idx} style={{\n                          flex: 1, height: 32,\n                          background: isActive ? activeColor : theme.colors.surfaceAlt,\n                          border: `1px solid ${isActive ? activeColor : theme.colors.border}`,\n                          borderRadius: 4,\n                          display:'flex', alignItems:'center', justifyContent:'center',\n                          color: isActive ? '#000' : theme.colors.textMuted,\n                          fontSize: 12, fontWeight: 'bold',\n                          transition: 'all 0.1s',\n                          transform: isActive ? 'scale(1.1)' : 'scale(1)',\n                          boxShadow: isActive ? `0 0 10px ${activeColor}40` : 'none'\n                       }}>\n                          {val}\n                       </div>\n                    )\n                 })}\n              </div>\n              <div style={{fontSize: 10, color: theme.colors.textSecondary, marginTop: 12}}>\n                 {method === 'batch' && \"Using ALL data per step.\"}\n                 {method === 'stochastic' && \"Using 1 random point.\"}\n                 {method === 'mini_batch' && `Using groups of ${batchSize}.`}\n              </div>\n           </div>\n        </div>\n\n      </div>\n    </div>\n  );\n}\n\n// --- CONTOUR PLOT COMPONENT ---\nconst ContourPlot = ({ path, currentStep, trueW, trueB, method }) => {\n  const width = 600;\n  const height = 400;\n  \n  const wRange = [0.0, 2.5]; \n  const bRange = [-0.5, 1.5];\n  \n  const toX = (w) => ((w - wRange[0]) / (wRange[1] - wRange[0])) * width;\n  const toY = (b) => height - ((b - bRange[0]) / (bRange[1] - bRange[0])) * height;\n\n  const contours = [0.15, 0.4, 0.8, 1.4, 2.2, 3.5];\n  const pathColor = method === 'batch' ? theme.colors.accent \n                 : method === 'stochastic' ? theme.colors.stochastic \n                 : theme.colors.minibatch;\n\n  const cxPct = toX(trueW) / width * 100;\n  const cyPct = toY(trueB) / height * 100;\n\n  return (\n    <svg width=\"100%\" height=\"100%\" viewBox={`0 0 ${width} ${height}`} style={{background: theme.colors.surfaceAlt}}>\n      <defs>\n        <pattern id=\"grid\" width=\"40\" height=\"40\" patternUnits=\"userSpaceOnUse\">\n          <path d=\"M 40 0 L 0 0 0 40\" fill=\"none\" stroke={theme.colors.grid} strokeWidth=\"2\"/>\n        </pattern>\n        <radialGradient id=\"lossGradient\" cx={`${cxPct}%`} cy={`${cyPct}%`} r=\"60%\" fx={`${cxPct}%`} fy={`${cyPct}%`}>\n           <stop offset=\"0%\" stopColor={theme.colors.success} stopOpacity=\"0.15\" />\n           <stop offset=\"40%\" stopColor={theme.colors.success} stopOpacity=\"0.05\" />\n           <stop offset=\"100%\" stopColor={theme.colors.surfaceAlt} stopOpacity=\"0\" />\n        </radialGradient>\n      </defs>\n\n      <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n      <rect width=\"100%\" height=\"100%\" fill=\"url(#lossGradient)\" />\n\n      {contours.reverse().map((val, i) => (\n        <ellipse \n          key={i}\n          cx={toX(trueW)} cy={toY(trueB)} rx={val * 50} ry={val * 70} \n          fill=\"transparent\" stroke={theme.colors.textMuted}\n          strokeWidth={1.5} strokeOpacity={Math.max(0.05, 0.3 - (val * 0.05))}\n        />\n      ))}\n\n      <circle cx={toX(trueW)} cy={toY(trueB)} r=\"6\" fill={theme.colors.success} />\n      <text x={toX(trueW) + 15} y={toY(trueB)} fill={theme.colors.success} fontSize=\"16\" fontWeight=\"bold\" dominantBaseline=\"middle\">Target (2, 1)</text>\n\n      <circle cx={toX(0.5)} cy={toY(0.0)} r=\"6\" fill={theme.colors.textSecondary} />\n      <text x={toX(0.5) - 15} y={toY(0.0)} fill={theme.colors.textSecondary} fontSize=\"16\" fontWeight=\"bold\" textAnchor=\"end\" dominantBaseline=\"middle\">Start (0.5, 0)</text>\n\n      <polyline \n        points={path.slice(0, currentStep+1).map(p => `${toX(p.w)},${toY(p.b)}`).join(' ')}\n        fill=\"none\" stroke={pathColor} strokeWidth=\"4\" strokeLinecap=\"round\" strokeLinejoin=\"round\"\n      />\n\n      {path[currentStep] && (\n        <g>\n           <circle cx={toX(path[currentStep].w)} cy={toY(path[currentStep].b)} r=\"16\" fill={pathColor} fillOpacity=\"0.3\"/>\n           <circle cx={toX(path[currentStep].w)} cy={toY(path[currentStep].b)} r=\"8\" fill={pathColor} stroke=\"#fff\" strokeWidth=\"3\" style={{transition: 'cx 0.05s, cy 0.05s'}}/>\n        </g>\n      )}\n    </svg>\n  );\n};\n\n// --- SUBCOMPONENTS ---\nconst MethodButton = ({ active, onClick, color, title, desc }) => (\n  <div \n    onClick={onClick}\n    style={{\n      padding: 12,\n      background: active ? `${color}15` : theme.colors.surfaceAlt,\n      border: `2px solid ${active ? color : theme.colors.border}`,\n      borderRadius: 8,\n      cursor: 'pointer',\n      transition: 'all 0.2s',\n      textAlign: 'center'\n    }}\n  >\n    <div style={{fontWeight:'bold', fontSize: 16, color: active ? color : theme.colors.text}}>{title}</div>\n    <div style={{fontSize: 12, color: theme.colors.textSecondary, marginTop: 4}}>{desc}</div>\n  </div>\n);\n\n// --- STYLES ---\nconst styles = {\n  container: {\n    fontFamily: theme.font,\n    background: theme.colors.background,\n    color: theme.colors.text,\n    minHeight: '100vh',\n    padding: 20,\n    display: 'flex', flexDirection: 'column',\n  },\n  header: {\n    display: 'flex', justifyContent: 'space-between', alignItems: 'center',\n    borderBottom: `1px solid ${theme.colors.border}`, paddingBottom: 16, marginBottom: 20\n  },\n  title: {\n    margin: 0, fontSize: 24, fontWeight: '800', letterSpacing: '-1px',\n    color: theme.colors.accent\n  },\n  statusBox: {\n    background: theme.colors.surfaceAlt, border: `1px solid ${theme.colors.border}`,\n    borderRadius: 8, padding: '8px 16px', textAlign: 'right', minWidth: 150\n  },\n  mainLayout: {\n    display: 'flex', flexDirection: 'column', gap: 20, flex: 1\n  },\n  vizContainer: {\n    position: 'relative', background: theme.colors.surface,\n    borderRadius: 16, border: `1px solid ${theme.colors.border}`,\n    overflow: 'hidden', boxShadow: '0 4px 30px rgba(0,0,0,0.5)',\n    height: 400, display: 'flex', flexDirection: 'column'\n  },\n  strategyGrid: {\n    display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 12\n  },\n  card: {\n    background: theme.colors.surface, borderRadius: 16,\n    border: `1px solid ${theme.colors.border}`, padding: 16,\n    display: 'flex', flexDirection: 'column', justifyContent: 'center'\n  },\n  cardHeader: {\n    fontSize: 12, fontWeight: 'bold', color: theme.colors.textSecondary,\n    textTransform: 'uppercase', letterSpacing: 1.5, marginBottom: 12\n  },\n  controlGroup: {\n    marginBottom: 0\n  },\n  labelRow: { display:'flex', justifyContent:'space-between', marginBottom: 8, fontSize: 13, fontWeight:'bold' },\n  controlsBar: {\n    padding: 16, borderTop: `1px solid ${theme.colors.border}`, background: theme.colors.surfaceAlt,\n    display: 'flex', gap: 12, justifyContent: 'flex-end'\n  },\n  btn: {\n    padding: '10px 20px', background: theme.colors.surface, border: `1px solid ${theme.colors.border}`,\n    color: theme.colors.text, borderRadius: 8, cursor:'pointer', fontSize: 14, fontWeight: 'bold'\n  },\n  btnPlay: (color) => ({\n    padding: '10px 28px', background: color, border: 'none',\n    color: '#000', borderRadius: 8, cursor:'pointer', fontSize: 14, fontWeight: '800'\n  }),\n  overlayLabel: {\n    position: 'absolute', top: 16, left: 16, \n    fontSize: 14, fontWeight: 'bold', color: theme.colors.textSecondary,\n    background: 'rgba(0,0,0,0.8)', padding: '6px 12px', borderRadius: 6\n  }\n};\n",
  "settings": {
    "editorHeight": 600,
    "theme": "auto",
    "showEditor": false,
    "showPreview": true,
    "editorWidthPercentage": 35
  },
  "dependencies": {}
}