{
  "problem_id": 54,
  "title": "Implementing a Simple RNN",
  "category": "Deep Learning",
  "enabled": true,
  "type": "react",
  "code": "\nimport React, { useState, useEffect, useMemo } from 'react';\n\nconst theme = {\n  bg: '#0f172a',\n  surface: '#1e293b',\n  card: '#334155',\n  border: '#475569',\n  text: '#f8fafc',\n  muted: '#94a3b8',\n  dim: '#64748b',\n  input: '#38bdf8',\n  memory: '#a78bfa',\n  output: '#4ade80',\n  orange: '#fb923c',\n  pink: '#f472b6',\n};\n\n// Simple word embeddings (pretend these came from training)\nconst vocabulary = {\n  'The': 0.8,\n  'A': 0.7,\n  'cat': 0.3,\n  'dog': 0.4,\n  'sat': -0.2,\n  'ran': -0.3,\n  'on': 0.1,\n  'the': 0.6,\n  'mat': 0.5,\n  'floor': 0.4,\n};\n\nconst wordList = Object.keys(vocabulary);\n\n// Predictions based on context (simplified)\nconst predictions = {\n  'default': { 'mat': 0.15, 'floor': 0.12, 'dog': 0.10, 'cat': 0.10, 'the': 0.08 },\n  'The': { 'cat': 0.25, 'dog': 0.22, 'mat': 0.08, 'floor': 0.06, 'the': 0.04 },\n  'The cat': { 'sat': 0.35, 'ran': 0.28, 'on': 0.12, 'the': 0.05, 'mat': 0.03 },\n  'The cat sat': { 'on': 0.45, 'the': 0.15, 'mat': 0.08, 'floor': 0.06, 'cat': 0.02 },\n  'The dog': { 'ran': 0.32, 'sat': 0.25, 'on': 0.10, 'the': 0.06, 'mat': 0.04 },\n  'The dog ran': { 'on': 0.38, 'the': 0.18, 'floor': 0.10, 'mat': 0.06, 'cat': 0.02 },\n  'A cat': { 'sat': 0.30, 'ran': 0.25, 'on': 0.12, 'the': 0.06, 'mat': 0.04 },\n  'A dog': { 'ran': 0.30, 'sat': 0.22, 'on': 0.12, 'the': 0.06, 'mat': 0.04 },\n};\n\nconst tanh = x => Math.tanh(x);\n\nexport default function App() {\n  const [words, setWords] = useState(['The', 'cat', 'sat']);\n  const [Wx, setWx] = useState(0.6);\n  const [Wh, setWh] = useState(0.7);\n  const [expandedStep, setExpandedStep] = useState(null);\n  const [flowPhase, setFlowPhase] = useState(0);\n\n  // Compute hidden states\n  const states = useMemo(() => {\n    const h = [0.0];\n    for (let i = 0; i < words.length; i++) {\n      const embedding = vocabulary[words[i]] || 0;\n      h.push(tanh(Wx * embedding + Wh * h[i]));\n    }\n    return h;\n  }, [words, Wx, Wh]);\n\n  // Get current predictions\n  const currentContext = words.join(' ');\n  const currentPreds = predictions[currentContext] || predictions['default'];\n  const topPreds = Object.entries(currentPreds).sort((a, b) => b[1] - a[1]).slice(0, 4);\n\n  useEffect(() => {\n    const interval = setInterval(() => setFlowPhase(p => (p + 1) % 100), 40);\n    return () => clearInterval(interval);\n  }, []);\n\n  const cycleWord = (idx) => {\n    const newWords = [...words];\n    const currentIdx = wordList.indexOf(words[idx]);\n    newWords[idx] = wordList[(currentIdx + 1) % wordList.length];\n    setWords(newWords);\n  };\n\n  // Layout\n  const hNodeW = 50, hNodeH = 50;\n  const cellW = 70, cellH = 65;\n  const arrowLen = 30;\n  const inputH = 55;\n  const gapY = 25;\n  const startX = 15;\n  const cellY = inputH + gapY + 25;\n  const unitW = arrowLen + cellW + arrowLen + hNodeW;\n  const svgWidth = startX + hNodeW + words.length * unitW + 10;\n  const svgHeight = cellY + cellH + 15;\n\n  return (\n    <div style={styles.container}>\n      <div style={styles.header}>\n        <h1 style={styles.title}>RNN: Next Word Prediction</h1>\n        <p style={styles.subtitle}>\n          Watch how the network builds <span style={{color: theme.memory}}>context</span> as it reads each word\n        </p>\n      </div>\n\n      {/* Main Flow Diagram */}\n      <div style={styles.flowSection}>\n        <svg width=\"100%\" viewBox={`0 0 ${svgWidth} ${svgHeight}`} style={{display: 'block'}}>\n          \n          {/* h0 - initial state */}\n          <g transform={`translate(${startX}, ${cellY})`}>\n            <rect x=\"0\" y=\"0\" width={hNodeW} height={hNodeH} rx=\"10\" \n              fill={theme.surface} stroke={theme.memory} strokeWidth=\"2\"/>\n            <text x={hNodeW/2} y=\"15\" textAnchor=\"middle\" fill={theme.muted} fontSize=\"9\">context</text>\n            <text x={hNodeW/2} y=\"32\" textAnchor=\"middle\" fill={theme.memory} fontSize=\"13\" fontWeight=\"700\">\n              {states[0].toFixed(2)}\n            </text>\n            <text x={hNodeW/2} y=\"44\" textAnchor=\"middle\" fill={theme.dim} fontSize=\"8\">empty</text>\n          </g>\n\n          {words.map((word, i) => {\n            const prevH = states[i];\n            const nextH = states[i + 1];\n            const embedding = vocabulary[word] || 0;\n            const isLast = i === words.length - 1;\n            const isExpanded = expandedStep === i;\n            \n            const cellX = startX + hNodeW + i * unitW + arrowLen;\n            const hX = cellX + cellW + arrowLen;\n\n            return (\n              <g key={i}>\n                {/* Word input above */}\n                <g transform={`translate(${cellX + cellW/2 - 35}, 5)`}>\n                  <rect x=\"0\" y=\"0\" width=\"70\" height={inputH - 5} rx=\"8\" \n                    fill={theme.card} stroke={theme.input} strokeWidth=\"2\"/>\n                  <text x=\"35\" y=\"18\" textAnchor=\"middle\" fill={theme.input} fontSize=\"15\" fontWeight=\"700\">\n                    \"{word}\"\n                  </text>\n                  <text x=\"35\" y=\"34\" textAnchor=\"middle\" fill={theme.dim} fontSize=\"9\">\n                    embed: {embedding.toFixed(1)}\n                  </text>\n                  <text x=\"35\" y=\"46\" textAnchor=\"middle\" fill={theme.muted} fontSize=\"8\">\n                    (click to change)\n                  </text>\n                </g>\n\n                {/* Arrow from word down to cell */}\n                <line \n                  x1={cellX + cellW/2} y1={inputH + 2} \n                  x2={cellX + cellW/2} y2={cellY - 3} \n                  stroke={theme.input} strokeWidth=\"2\"\n                />\n                <polygon \n                  points={`${cellX + cellW/2 - 5},${cellY - 6} ${cellX + cellW/2},${cellY} ${cellX + cellW/2 + 5},${cellY - 6}`} \n                  fill={theme.input}\n                />\n                {[0,1].map(p => {\n                  const progress = ((flowPhase + p * 50) % 100) / 100;\n                  return (\n                    <circle key={p} cx={cellX + cellW/2} cy={inputH + 2 + (cellY - inputH - 5) * progress} \n                      r=\"3\" fill={theme.input} opacity=\"0.8\"/>\n                  );\n                })}\n\n                {/* Arrow from previous context */}\n                <line \n                  x1={i === 0 ? startX + hNodeW : hX - unitW + hNodeW} \n                  y1={cellY + hNodeH/2} \n                  x2={cellX - 3} \n                  y2={cellY + cellH/2} \n                  stroke={theme.memory} strokeWidth=\"2\"\n                />\n                <polygon \n                  points={`${cellX - 6},${cellY + cellH/2 - 5} ${cellX},${cellY + cellH/2} ${cellX - 6},${cellY + cellH/2 + 5}`} \n                  fill={theme.memory}\n                />\n                {[0,1,2].map(p => {\n                  const progress = ((flowPhase + p * 33) % 100) / 100;\n                  const startPx = i === 0 ? startX + hNodeW : hX - unitW + hNodeW;\n                  return (\n                    <circle key={p} cx={startPx + (cellX - startPx - 5) * progress} cy={cellY + cellH/2} \n                      r=\"3\" fill={theme.memory} opacity=\"0.7\"/>\n                  );\n                })}\n\n                {/* RNN Cell */}\n                <g \n                  transform={`translate(${cellX}, ${cellY})`}\n                  onClick={() => setExpandedStep(isExpanded ? null : i)}\n                  style={{cursor: 'pointer'}}\n                >\n                  <rect x=\"0\" y=\"0\" width={cellW} height={cellH} rx=\"10\" \n                    fill={theme.card} stroke={isExpanded ? theme.output : theme.border} strokeWidth=\"2\"/>\n                  <text x={cellW/2} y=\"18\" textAnchor=\"middle\" fill={theme.orange} fontSize=\"13\" fontWeight=\"700\">\n                    RNN\n                  </text>\n                  <text x={cellW/2} y=\"32\" textAnchor=\"middle\" fill={theme.dim} fontSize=\"9\">\n                    tanh(Wx·x + Wh·h)\n                  </text>\n                  <rect x=\"5\" y=\"40\" width={cellW - 10} height=\"20\" rx=\"5\" fill={`${theme.output}30`}/>\n                  <text x={cellW/2} y=\"54\" textAnchor=\"middle\" fill={theme.output} fontSize=\"11\" fontWeight=\"600\">\n                    {nextH.toFixed(3)}\n                  </text>\n                </g>\n\n                {/* Arrow to new context */}\n                <line \n                  x1={cellX + cellW + 3} y1={cellY + cellH/2} \n                  x2={hX - 3} y2={cellY + hNodeH/2} \n                  stroke={theme.output} strokeWidth=\"2\"\n                />\n                <polygon \n                  points={`${hX - 6},${cellY + hNodeH/2 - 5} ${hX},${cellY + hNodeH/2} ${hX - 6},${cellY + hNodeH/2 + 5}`} \n                  fill={theme.output}\n                />\n                {[0,1,2].map(p => {\n                  const progress = ((flowPhase + p * 33) % 100) / 100;\n                  return (\n                    <circle key={p} cx={cellX + cellW + 3 + (hX - cellX - cellW - 6) * progress} cy={cellY + cellH/2} \n                      r=\"3\" fill={theme.output} opacity=\"0.7\"/>\n                  );\n                })}\n\n                {/* New context node */}\n                <g transform={`translate(${hX}, ${cellY})`}>\n                  <rect x=\"0\" y=\"0\" width={hNodeW} height={hNodeH} rx=\"10\" \n                    fill={isLast ? `${theme.output}25` : theme.surface} \n                    stroke={isLast ? theme.output : theme.memory} strokeWidth=\"2\"/>\n                  <text x={hNodeW/2} y=\"15\" textAnchor=\"middle\" fill={theme.muted} fontSize=\"9\">context</text>\n                  <text x={hNodeW/2} y=\"32\" textAnchor=\"middle\" \n                    fill={isLast ? theme.output : theme.memory} fontSize=\"13\" fontWeight=\"700\">\n                    {nextH.toFixed(2)}\n                  </text>\n                  {isLast && (\n                    <text x={hNodeW/2} y=\"44\" textAnchor=\"middle\" fill={theme.output} fontSize=\"8\">final</text>\n                  )}\n                </g>\n              </g>\n            );\n          })}\n        </svg>\n\n        {/* Clickable word overlays */}\n        <div style={styles.wordOverlay}>\n          {words.map((_, i) => {\n            const cellX = startX + hNodeW + i * unitW + arrowLen;\n            const leftPercent = (cellX + cellW/2 - 35) / svgWidth * 100;\n            return (\n              <div key={i} style={{\n                position: 'absolute',\n                left: `${leftPercent}%`,\n                top: 5,\n                width: 70,\n                height: inputH - 5,\n                cursor: 'pointer',\n              }} onClick={() => cycleWord(i)} />\n            );\n          })}\n        </div>\n      </div>\n\n      {/* Context explanation */}\n      <div style={styles.contextBox}>\n        <div style={styles.contextTitle}>What the network \"understands\"</div>\n        <div style={styles.contextFlow}>\n          <span style={styles.contextEmpty}>∅</span>\n          {words.map((word, i) => (\n            <React.Fragment key={i}>\n              <span style={styles.contextArrow}>→</span>\n              <span style={styles.contextWord}>\"{word}\"</span>\n            </React.Fragment>\n          ))}\n          <span style={styles.contextArrow}>→</span>\n          <span style={styles.contextQ}>?</span>\n        </div>\n        <div style={styles.contextDesc}>\n          After reading \"<span style={{color: theme.input}}>{words.join(' ')}</span>\", \n          the context state <span style={{color: theme.memory}}>{states[words.length].toFixed(2)}</span> encodes \n          everything needed to predict the next word.\n        </div>\n      </div>\n\n      {/* Predictions */}\n      <div style={styles.predSection}>\n        <div style={styles.predTitle}>Next Word Predictions</div>\n        <div style={styles.predBars}>\n          {topPreds.map(([word, prob], i) => (\n            <div key={word} style={styles.predRow}>\n              <span style={styles.predWord}>\"{word}\"</span>\n              <div style={styles.predBarBg}>\n                <div style={{\n                  ...styles.predBarFill,\n                  width: `${prob * 200}%`,\n                  background: i === 0 ? theme.output : theme.pink,\n                  opacity: 1 - i * 0.2,\n                }}/>\n              </div>\n              <span style={styles.predProb}>{(prob * 100).toFixed(0)}%</span>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Expanded math */}\n      {expandedStep !== null && (\n        <div style={styles.mathBox}>\n          <div style={styles.mathTitle}>Step {expandedStep + 1}: Processing \"{words[expandedStep]}\"</div>\n          <div style={styles.mathContent}>\n            <div>Word embedding: <span style={{color: theme.input}}>{vocabulary[words[expandedStep]]?.toFixed(1)}</span></div>\n            <div>Previous context: <span style={{color: theme.memory}}>{states[expandedStep].toFixed(3)}</span></div>\n            <div>Wx × embed = {Wx} × {vocabulary[words[expandedStep]]?.toFixed(1)} = {(Wx * vocabulary[words[expandedStep]]).toFixed(3)}</div>\n            <div>Wh × context = {Wh} × {states[expandedStep].toFixed(2)} = {(Wh * states[expandedStep]).toFixed(3)}</div>\n            <div style={{color: theme.output, fontWeight: 600}}>\n              New context = tanh({(Wx * vocabulary[words[expandedStep]] + Wh * states[expandedStep]).toFixed(3)}) = {states[expandedStep + 1].toFixed(4)}\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Params */}\n      <div style={styles.paramsRow}>\n        <div style={styles.param}>\n          <div style={styles.paramTop}>\n            <span style={{color: theme.orange, fontWeight: 700}}>Wx</span>\n            <span style={styles.paramHint}>word weight</span>\n          </div>\n          <input type=\"range\" min=\"0\" max=\"1.5\" step=\"0.1\" value={Wx}\n            onChange={e => setWx(+e.target.value)} style={styles.slider}/>\n          <span style={styles.paramVal}>{Wx.toFixed(1)}</span>\n        </div>\n        <div style={styles.param}>\n          <div style={styles.paramTop}>\n            <span style={{color: theme.orange, fontWeight: 700}}>Wh</span>\n            <span style={styles.paramHint}>context weight</span>\n          </div>\n          <input type=\"range\" min=\"0\" max=\"1.5\" step=\"0.1\" value={Wh}\n            onChange={e => setWh(+e.target.value)} style={styles.slider}/>\n          <span style={styles.paramVal}>{Wh.toFixed(1)}</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    fontFamily: \"'Inter', -apple-system, sans-serif\",\n    background: theme.bg,\n    color: theme.text,\n    padding: 16,\n    maxWidth: 600,\n    margin: '0 auto',\n  },\n  header: { textAlign: 'center', marginBottom: 12 },\n  title: { fontSize: 20, fontWeight: 700, margin: 0 },\n  subtitle: { fontSize: 12, color: theme.muted, margin: '6px 0 0' },\n\n  flowSection: {\n    background: theme.surface, borderRadius: 12, padding: 10, marginBottom: 12,\n    position: 'relative',\n  },\n  wordOverlay: {\n    position: 'absolute', top: 0, left: 10, right: 10, height: 60,\n  },\n\n  contextBox: {\n    background: theme.surface, borderRadius: 10, padding: 14, marginBottom: 12,\n    textAlign: 'center',\n  },\n  contextTitle: { fontSize: 11, color: theme.dim, marginBottom: 10 },\n  contextFlow: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, marginBottom: 10 },\n  contextEmpty: { color: theme.dim, fontSize: 14 },\n  contextArrow: { color: theme.dim, fontSize: 12 },\n  contextWord: { color: theme.input, fontSize: 13, fontWeight: 600 },\n  contextQ: { \n    color: theme.output, fontSize: 16, fontWeight: 700,\n    background: `${theme.output}20`, padding: '2px 8px', borderRadius: 4,\n  },\n  contextDesc: { fontSize: 11, color: theme.muted, lineHeight: 1.5 },\n\n  predSection: {\n    background: theme.surface, borderRadius: 10, padding: 14, marginBottom: 12,\n  },\n  predTitle: { fontSize: 11, color: theme.dim, marginBottom: 10, textAlign: 'center' },\n  predBars: { display: 'flex', flexDirection: 'column', gap: 6 },\n  predRow: { display: 'flex', alignItems: 'center', gap: 8 },\n  predWord: { width: 60, fontSize: 12, color: theme.text, textAlign: 'right' },\n  predBarBg: { flex: 1, height: 16, background: theme.card, borderRadius: 4, overflow: 'hidden' },\n  predBarFill: { height: '100%', borderRadius: 4, transition: 'width 0.3s' },\n  predProb: { width: 36, fontSize: 11, color: theme.muted, textAlign: 'right' },\n\n  mathBox: {\n    background: theme.surface, borderRadius: 10, padding: 14, marginBottom: 12,\n  },\n  mathTitle: { fontSize: 11, color: theme.dim, marginBottom: 8 },\n  mathContent: { fontSize: 11, fontFamily: 'monospace', color: theme.muted, lineHeight: 1.8 },\n\n  paramsRow: { display: 'flex', gap: 16 },\n  param: {\n    flex: 1, background: theme.surface, borderRadius: 10, padding: 12,\n    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 6,\n  },\n  paramTop: { display: 'flex', alignItems: 'center', gap: 8 },\n  paramHint: { fontSize: 10, color: theme.dim },\n  slider: { width: '100%', accentColor: theme.orange },\n  paramVal: { fontSize: 16, fontWeight: 700, color: theme.orange },\n};\n",
  "settings": {
    "editorHeight": 600,
    "showConsole": false,
    "theme": "auto",
    "showEditor": false,
    "showPreview": true,
    "editorWidthPercentage": 35
  },
  "dependencies": {}
}