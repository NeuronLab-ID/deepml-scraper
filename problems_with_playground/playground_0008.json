{
  "problem_id": 8,
  "title": "Calculate 2x2 Matrix Inverse",
  "category": "Linear Algebra",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useMemo, useRef, useEffect } from 'react';\n\n// ============================================\n// Design Tokens\n// ============================================\nconst theme = {\n  colors: {\n    primary: '#6366f1',\n    secondary: '#ffffff',\n    background: '#000000',\n    surface: '#0a0a0a',\n    surfaceAlt: '#111111',\n    border: '#1f1f1f',\n    text: '#ffffff',\n    textSecondary: '#a1a1aa',\n    textMuted: '#71717a',\n    success: '#22c55e',\n    error: '#ef4444',\n    warning: '#f59e0b',\n    matrixA: '#ec4899',\n    matrixInv: '#22c55e',\n    identity: '#3b82f6',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\n// ============================================\n// Icons\n// ============================================\nconst Icons = {\n  Play: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <polygon points=\"5 3 19 12 5 21 5 3\"/>\n    </svg>\n  ),\n  RotateCcw: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <path d=\"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8\"/><path d=\"M3 3v5h5\"/>\n    </svg>\n  ),\n  Shuffle: ({ size = 24, color = 'currentColor' }) => (\n    <svg width={size} height={size} viewBox=\"0 0 24 24\" fill=\"none\" stroke={color} strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n      <path d=\"M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H22\"/><path d=\"m18 2 4 4-4 4\"/><path d=\"M2 6h1.9c1.5 0 2.9.9 3.6 2.2\"/><path d=\"M22 18h-5.9c-1.3 0-2.6-.7-3.3-1.8l-.5-.8\"/><path d=\"m18 14 4 4-4 4\"/>\n    </svg>\n  ),\n};\n\n// ============================================\n// Card Component\n// ============================================\nfunction Card({ children, style = {} }) {\n  return (\n    <div style={{\n      background: theme.colors.surface,\n      border: `1px solid ${theme.colors.border}`,\n      borderRadius: '12px',\n      padding: '20px',\n      ...style,\n    }}>\n      {children}\n    </div>\n  );\n}\n\n// ============================================\n// Matrix Input\n// ============================================\nfunction MatrixInput({ matrix, onChange, label, color }) {\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <div style={{ fontSize: '11px', color, marginBottom: '6px', fontWeight: '600' }}>\n        {label}\n      </div>\n      <div style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(2, 1fr)',\n        gap: '4px',\n        padding: '8px',\n        background: `${color}10`,\n        borderRadius: '8px',\n        border: `1px solid ${color}40`,\n      }}>\n        {matrix.map((row, i) =>\n          row.map((val, j) => (\n            <input\n              key={`${i}-${j}`}\n              type=\"number\"\n              step=\"0.5\"\n              value={val}\n              onChange={(e) => {\n                const newMatrix = matrix.map((r, ri) =>\n                  r.map((c, ci) => (ri === i && ci === j ? parseFloat(e.target.value) || 0 : c))\n                );\n                onChange(newMatrix);\n              }}\n              style={{\n                width: '44px',\n                height: '36px',\n                background: theme.colors.surfaceAlt,\n                border: `1px solid ${theme.colors.border}`,\n                borderRadius: '6px',\n                color: theme.colors.text,\n                fontFamily: theme.font,\n                fontSize: '14px',\n                fontWeight: '600',\n                textAlign: 'center',\n                outline: 'none',\n              }}\n            />\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n\n// ============================================\n// Result Matrix Display\n// ============================================\nfunction ResultMatrix({ matrix, label, color }) {\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <div style={{ fontSize: '11px', color, marginBottom: '6px', fontWeight: '600' }}>\n        {label}\n      </div>\n      <div style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(2, 1fr)',\n        gap: '4px',\n        padding: '8px',\n        background: `${color}15`,\n        borderRadius: '8px',\n        border: `2px solid ${color}`,\n      }}>\n        {matrix ? matrix.map((row, i) =>\n          row.map((val, j) => (\n            <div\n              key={`${i}-${j}`}\n              style={{\n                width: '44px',\n                height: '36px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                background: theme.colors.surfaceAlt,\n                borderRadius: '6px',\n                color,\n                fontFamily: theme.font,\n                fontSize: '12px',\n                fontWeight: '600',\n              }}\n            >\n              {val.toFixed(2)}\n            </div>\n          ))\n        ) : (\n          <div style={{\n            gridColumn: 'span 2',\n            padding: '20px',\n            color: theme.colors.error,\n            fontSize: '14px',\n            fontWeight: '700',\n          }}>\n            None\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// ============================================\n// Animated Transformation Canvas\n// ============================================\nfunction TransformCanvas({ matrix, inverse, animationPhase, animationT }) {\n  const canvasRef = useRef(null);\n  const size = 400;\n  const center = size / 2;\n  \n  const det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n  const isInvertible = Math.abs(det) > 0.0001;\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    ctx.fillStyle = theme.colors.background;\n    ctx.fillRect(0, 0, size, size);\n    \n    // Interpolate between matrices\n    const lerp = (a, b, t) => a + (b - a) * t;\n    const lerpMatrix = (m1, m2, t) => [\n      [lerp(m1[0][0], m2[0][0], t), lerp(m1[0][1], m2[0][1], t)],\n      [lerp(m1[1][0], m2[1][0], t), lerp(m1[1][1], m2[1][1], t)],\n    ];\n    \n    const identity = [[1, 0], [0, 1]];\n    \n    // Determine current transformation matrix based on phase\n    let currentMatrix;\n    let phaseLabel;\n    let phaseColor;\n    \n    if (animationPhase === 0) {\n      // Starting: Identity\n      currentMatrix = identity;\n      phaseLabel = 'Original (I)';\n      phaseColor = theme.colors.identity;\n    } else if (animationPhase === 1) {\n      // Transforming: I → A\n      currentMatrix = lerpMatrix(identity, matrix, animationT);\n      phaseLabel = 'Applying A...';\n      phaseColor = theme.colors.matrixA;\n    } else if (animationPhase === 2) {\n      // Holding at A\n      currentMatrix = matrix;\n      phaseLabel = 'Transformed by A';\n      phaseColor = theme.colors.matrixA;\n    } else if (animationPhase === 3 && isInvertible) {\n      // Transforming: A → I (applying A⁻¹)\n      currentMatrix = lerpMatrix(matrix, identity, animationT);\n      phaseLabel = 'Applying A⁻¹...';\n      phaseColor = theme.colors.matrixInv;\n    } else if (animationPhase === 4) {\n      // Back to identity\n      currentMatrix = identity;\n      phaseLabel = 'Back to Original!';\n      phaseColor = theme.colors.success;\n    } else {\n      currentMatrix = matrix;\n      phaseLabel = isInvertible ? 'Transformed by A' : 'Collapsed! (det=0)';\n      phaseColor = isInvertible ? theme.colors.matrixA : theme.colors.error;\n    }\n    \n    // Calculate scale based on matrix values\n    const corners = [[0, 0], [1, 0], [1, 1], [0, 1]];\n    const transform = (x, y, mat) => [\n      mat[0][0] * x + mat[0][1] * y,\n      mat[1][0] * x + mat[1][1] * y,\n    ];\n    \n    let maxVal = 1;\n    corners.forEach(([x, y]) => {\n      const [tx, ty] = transform(x, y, currentMatrix);\n      maxVal = Math.max(maxVal, Math.abs(tx), Math.abs(ty));\n    });\n    // Also check original matrix for consistent scaling\n    corners.forEach(([x, y]) => {\n      const [tx, ty] = transform(x, y, matrix);\n      maxVal = Math.max(maxVal, Math.abs(tx), Math.abs(ty));\n    });\n    \n    const padding = 1.5;\n    const scale = (size / 2 - 30) / (maxVal * padding);\n    const toCanvas = (x, y) => [center + x * scale, center - y * scale];\n    \n    // Draw grid\n    ctx.strokeStyle = '#1a1a2e';\n    ctx.lineWidth = 1;\n    const gridRange = Math.ceil(maxVal * padding) + 1;\n    for (let i = -gridRange; i <= gridRange; i++) {\n      const [x1, y1] = toCanvas(...transform(i, -gridRange, currentMatrix));\n      const [x2, y2] = toCanvas(...transform(i, gridRange, currentMatrix));\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n      \n      const [x3, y3] = toCanvas(...transform(-gridRange, i, currentMatrix));\n      const [x4, y4] = toCanvas(...transform(gridRange, i, currentMatrix));\n      ctx.beginPath();\n      ctx.moveTo(x3, y3);\n      ctx.lineTo(x4, y4);\n      ctx.stroke();\n    }\n    \n    // Draw axes\n    ctx.strokeStyle = '#444';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(0, center);\n    ctx.lineTo(size, center);\n    ctx.moveTo(center, 0);\n    ctx.lineTo(center, size);\n    ctx.stroke();\n    \n    // Draw reference unit square (faded)\n    if (animationPhase > 0) {\n      ctx.strokeStyle = `${theme.colors.identity}40`;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.beginPath();\n      corners.forEach((corner, idx) => {\n        const [cx, cy] = toCanvas(corner[0], corner[1]);\n        if (idx === 0) ctx.moveTo(cx, cy);\n        else ctx.lineTo(cx, cy);\n      });\n      ctx.closePath();\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n    \n    // Draw current unit square\n    ctx.strokeStyle = phaseColor;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    corners.forEach((corner, idx) => {\n      const [tx, ty] = transform(corner[0], corner[1], currentMatrix);\n      const [cx, cy] = toCanvas(tx, ty);\n      if (idx === 0) ctx.moveTo(cx, cy);\n      else ctx.lineTo(cx, cy);\n    });\n    ctx.closePath();\n    ctx.stroke();\n    \n    // Fill\n    ctx.fillStyle = `${phaseColor}30`;\n    ctx.beginPath();\n    corners.forEach((corner, idx) => {\n      const [tx, ty] = transform(corner[0], corner[1], currentMatrix);\n      const [cx, cy] = toCanvas(tx, ty);\n      if (idx === 0) ctx.moveTo(cx, cy);\n      else ctx.lineTo(cx, cy);\n    });\n    ctx.closePath();\n    ctx.fill();\n    \n    // Draw basis vectors\n    const drawArrow = (toX, toY, color, label) => {\n      const [fx, fy] = toCanvas(0, 0);\n      const [tx, ty] = toCanvas(toX, toY);\n      \n      ctx.strokeStyle = color;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(fx, fy);\n      ctx.lineTo(tx, ty);\n      ctx.stroke();\n      \n      const angle = Math.atan2(fy - ty, fx - tx);\n      const headLen = 12;\n      ctx.beginPath();\n      ctx.moveTo(tx, ty);\n      ctx.lineTo(tx + headLen * Math.cos(angle + 0.4), ty + headLen * Math.sin(angle + 0.4));\n      ctx.lineTo(tx + headLen * Math.cos(angle - 0.4), ty + headLen * Math.sin(angle - 0.4));\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n    };\n    \n    const [e1x, e1y] = transform(1, 0, currentMatrix);\n    const [e2x, e2y] = transform(0, 1, currentMatrix);\n    drawArrow(e1x, e1y, '#ef4444', 'x');\n    drawArrow(e2x, e2y, '#22c55e', 'y');\n    \n    // Draw origin\n    const [ox, oy] = toCanvas(0, 0);\n    ctx.fillStyle = theme.colors.text;\n    ctx.beginPath();\n    ctx.arc(ox, oy, 5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw phase label\n    ctx.fillStyle = phaseColor;\n    ctx.font = 'bold 16px JetBrains Mono';\n    ctx.textAlign = 'center';\n    ctx.fillText(phaseLabel, center, 30);\n    \n    // If not invertible and showing transform, explain why\n    if (!isInvertible && animationPhase >= 2) {\n      ctx.fillStyle = theme.colors.error;\n      ctx.font = '13px JetBrains Mono';\n      ctx.fillText('Shape collapsed to a line!', center, size - 45);\n      ctx.fillText('Information lost - cannot undo', center, size - 25);\n    }\n    \n  }, [matrix, inverse, animationPhase, animationT]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      width={size}\n      height={size}\n      style={{\n        borderRadius: '10px',\n        border: `1px solid ${theme.colors.border}`,\n        display: 'block',\n        margin: '0 auto',\n      }}\n    />\n  );\n}\n\n// ============================================\n// Main Component\n// ============================================\nexport default function MatrixInverse() {\n  const [matrix, setMatrix] = useState([[2, 1], [1, 1]]);\n  const [animationPhase, setAnimationPhase] = useState(0);\n  const [animationT, setAnimationT] = useState(0);\n  const [isAnimating, setIsAnimating] = useState(false);\n  \n  const det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n  const isInvertible = Math.abs(det) > 0.0001;\n  \n  const inverse = useMemo(() => {\n    if (!isInvertible) return null;\n    return [\n      [matrix[1][1] / det, -matrix[0][1] / det],\n      [-matrix[1][0] / det, matrix[0][0] / det],\n    ];\n  }, [matrix, det, isInvertible]);\n  \n  // Animation\n  const animate = async () => {\n    setIsAnimating(true);\n    \n    // Phase 0: Start at identity\n    setAnimationPhase(0);\n    setAnimationT(0);\n    await new Promise(r => setTimeout(r, 800));\n    \n    // Phase 1: Animate I → A\n    setAnimationPhase(1);\n    for (let t = 0; t <= 1; t += 0.02) {\n      setAnimationT(t);\n      await new Promise(r => setTimeout(r, 20));\n    }\n    setAnimationT(1);\n    \n    // Phase 2: Hold at A\n    setAnimationPhase(2);\n    await new Promise(r => setTimeout(r, 1000));\n    \n    if (isInvertible) {\n      // Phase 3: Animate A → I (applying A⁻¹)\n      setAnimationPhase(3);\n      for (let t = 0; t <= 1; t += 0.02) {\n        setAnimationT(t);\n        await new Promise(r => setTimeout(r, 20));\n      }\n      setAnimationT(1);\n      \n      // Phase 4: Back to identity\n      setAnimationPhase(4);\n      await new Promise(r => setTimeout(r, 1500));\n    } else {\n      // Stay at phase 2 showing collapsed state\n      await new Promise(r => setTimeout(r, 2000));\n    }\n    \n    setIsAnimating(false);\n  };\n  \n  const reset = () => {\n    setAnimationPhase(0);\n    setAnimationT(0);\n  };\n  \n  const randomize = () => {\n    const newMatrix = [\n      [Math.floor(Math.random() * 6) - 2, Math.floor(Math.random() * 6) - 2],\n      [Math.floor(Math.random() * 6) - 2, Math.floor(Math.random() * 6) - 2],\n    ];\n    setMatrix(newMatrix);\n    reset();\n  };\n  \n  // Presets\n  const presets = [\n    { name: 'Simple', matrix: [[2, 1], [1, 1]] },\n    { name: 'Rotation', matrix: [[0, -1], [1, 0]] },\n    { name: 'Scale', matrix: [[2, 0], [0, 3]] },\n    { name: 'Shear', matrix: [[1, 2], [0, 1]] },\n    { name: 'Singular', matrix: [[1, 2], [2, 4]] },\n  ];\n\n  return (\n    <div style={{\n      minHeight: '100vh',\n      background: theme.colors.background,\n      color: theme.colors.text,\n      fontFamily: theme.font,\n      padding: '24px',\n    }}>\n      <div style={{ maxWidth: '500px', margin: '0 auto' }}>\n        {/* Header */}\n        <div style={{ marginBottom: '16px', textAlign: 'center' }}>\n          <h1 style={{ fontSize: '20px', fontWeight: '600', margin: '0 0 4px 0' }}>\n            Matrix Inverse: Undo the Transformation\n          </h1>\n          <p style={{ color: theme.colors.textSecondary, fontSize: '12px', margin: 0 }}>\n            A⁻¹ reverses what A does — watch A transform, then A⁻¹ bring it back!\n          </p>\n        </div>\n        \n        {/* Presets */}\n        <div style={{ display: 'flex', gap: '6px', marginBottom: '12px', justifyContent: 'center', flexWrap: 'wrap' }}>\n          {presets.map(({ name, matrix: m }) => (\n            <button\n              key={name}\n              onClick={() => { setMatrix(m); reset(); }}\n              style={{\n                padding: '4px 10px',\n                background: name === 'Singular' ? `${theme.colors.error}20` : theme.colors.surfaceAlt,\n                border: `1px solid ${name === 'Singular' ? theme.colors.error : theme.colors.border}`,\n                borderRadius: '4px',\n                color: name === 'Singular' ? theme.colors.error : theme.colors.textSecondary,\n                fontFamily: theme.font,\n                fontSize: '11px',\n                cursor: 'pointer',\n              }}\n            >\n              {name}\n            </button>\n          ))}\n          <button\n            onClick={randomize}\n            style={{\n              padding: '4px 10px',\n              background: theme.colors.surfaceAlt,\n              border: `1px solid ${theme.colors.border}`,\n              borderRadius: '4px',\n              color: theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n              display: 'flex',\n              alignItems: 'center',\n              gap: '4px',\n            }}\n          >\n            <Icons.Shuffle size={12} /> Random\n          </button>\n        </div>\n        \n        {/* Main Card */}\n        <Card>\n          {/* Matrix Display */}\n          <div style={{\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n            gap: '12px',\n            marginBottom: '16px',\n          }}>\n            <MatrixInput\n              matrix={matrix}\n              onChange={(m) => { setMatrix(m); reset(); }}\n              label=\"Matrix A\"\n              color={theme.colors.matrixA}\n            />\n            \n            <div style={{\n              display: 'flex',\n              flexDirection: 'column',\n              alignItems: 'center',\n              gap: '4px',\n            }}>\n              <div style={{\n                padding: '6px 10px',\n                background: isInvertible ? `${theme.colors.warning}20` : `${theme.colors.error}20`,\n                borderRadius: '6px',\n                border: `1px solid ${isInvertible ? theme.colors.warning : theme.colors.error}`,\n                textAlign: 'center',\n              }}>\n                <div style={{ fontSize: '9px', color: theme.colors.textMuted }}>det</div>\n                <div style={{\n                  fontSize: '14px',\n                  fontWeight: '700',\n                  color: isInvertible ? theme.colors.warning : theme.colors.error,\n                }}>\n                  {det.toFixed(1)}\n                </div>\n              </div>\n              <div style={{ fontSize: '16px', color: theme.colors.textMuted }}>→</div>\n            </div>\n            \n            <ResultMatrix\n              matrix={inverse}\n              label=\"A⁻¹ (Inverse)\"\n              color={theme.colors.matrixInv}\n            />\n          </div>\n          \n          {/* Canvas */}\n          <TransformCanvas\n            matrix={matrix}\n            inverse={inverse}\n            animationPhase={animationPhase}\n            animationT={animationT}\n          />\n          \n          {/* Animation Progress */}\n          <div style={{\n            display: 'flex',\n            justifyContent: 'center',\n            gap: '8px',\n            marginTop: '16px',\n          }}>\n            {['I', 'A', 'A⁻¹', 'I'].map((label, idx) => {\n              const phaseMap = [0, 2, 3, 4];\n              const isActive = animationPhase >= phaseMap[idx];\n              const isCurrent = (idx === 0 && animationPhase === 0) ||\n                               (idx === 1 && (animationPhase === 1 || animationPhase === 2)) ||\n                               (idx === 2 && animationPhase === 3) ||\n                               (idx === 3 && animationPhase === 4);\n              const colors = [theme.colors.identity, theme.colors.matrixA, theme.colors.matrixInv, theme.colors.success];\n              \n              return (\n                <React.Fragment key={idx}>\n                  <div style={{\n                    width: '36px',\n                    height: '36px',\n                    borderRadius: '50%',\n                    background: isActive ? `${colors[idx]}30` : theme.colors.surfaceAlt,\n                    border: `2px solid ${isCurrent ? colors[idx] : isActive ? `${colors[idx]}60` : theme.colors.border}`,\n                    display: 'flex',\n                    alignItems: 'center',\n                    justifyContent: 'center',\n                    fontSize: '11px',\n                    fontWeight: '700',\n                    color: isActive ? colors[idx] : theme.colors.textMuted,\n                    transition: 'all 0.3s ease',\n                    transform: isCurrent ? 'scale(1.1)' : 'scale(1)',\n                  }}>\n                    {label}\n                  </div>\n                  {idx < 3 && (\n                    <div style={{\n                      display: 'flex',\n                      alignItems: 'center',\n                      color: theme.colors.textMuted,\n                      fontSize: '12px',\n                    }}>\n                      →\n                    </div>\n                  )}\n                </React.Fragment>\n              );\n            })}\n          </div>\n          \n          {/* Controls */}\n          <div style={{ display: 'flex', gap: '8px', marginTop: '16px' }}>\n            <button\n              onClick={animate}\n              disabled={isAnimating}\n              style={{\n                flex: 1,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                gap: '6px',\n                padding: '12px',\n                background: theme.colors.primary,\n                border: 'none',\n                borderRadius: '8px',\n                color: theme.colors.secondary,\n                fontFamily: theme.font,\n                fontSize: '13px',\n                fontWeight: '600',\n                cursor: isAnimating ? 'not-allowed' : 'pointer',\n                opacity: isAnimating ? 0.7 : 1,\n              }}\n            >\n              <Icons.Play size={16} />\n              {isAnimating ? 'Animating...' : 'Watch A then A⁻¹'}\n            </button>\n            \n            <button\n              onClick={reset}\n              style={{\n                padding: '12px 16px',\n                background: theme.colors.surfaceAlt,\n                border: `1px solid ${theme.colors.border}`,\n                borderRadius: '8px',\n                color: theme.colors.textSecondary,\n                cursor: 'pointer',\n              }}\n            >\n              <Icons.RotateCcw size={16} />\n            </button>\n          </div>\n        </Card>\n        \n        {/* Key Insight */}\n        <Card style={{ marginTop: '16px' }}>\n          <div style={{\n            fontSize: '12px',\n            color: theme.colors.textMuted,\n            textTransform: 'uppercase',\n            letterSpacing: '0.5px',\n            marginBottom: '12px',\n          }}>\n            Key Insight\n          </div>\n          \n          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>\n            <div style={{\n              padding: '12px',\n              background: theme.colors.surfaceAlt,\n              borderRadius: '6px',\n              border: `1px solid ${theme.colors.border}`,\n            }}>\n              <div style={{ fontSize: '12px', color: theme.colors.matrixInv, fontWeight: '600', marginBottom: '4px' }}>\n                A⁻¹ Undoes A\n              </div>\n              <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n                Whatever A does to space, A⁻¹ reverses it exactly\n              </div>\n            </div>\n            \n            <div style={{\n              padding: '12px',\n              background: theme.colors.surfaceAlt,\n              borderRadius: '6px',\n              border: `1px solid ${theme.colors.border}`,\n            }}>\n              <div style={{ fontSize: '12px', color: theme.colors.error, fontWeight: '600', marginBottom: '4px' }}>\n                det = 0 → No Inverse\n              </div>\n              <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n                If A collapses space to a line, the lost info can't be recovered\n              </div>\n            </div>\n          </div>\n          \n          {/* Formula hint */}\n          <div style={{\n            marginTop: '12px',\n            padding: '10px 14px',\n            background: theme.colors.background,\n            borderRadius: '6px',\n            fontSize: '12px',\n            color: theme.colors.textSecondary,\n            textAlign: 'center',\n          }}>\n            <span style={{ color: theme.colors.textMuted }}>Formula: </span>\n            A⁻¹ = (1/det) × [[d, -b], [-c, a]]\n            <span style={{ color: theme.colors.textMuted }}> where det = ad - bc</span>\n          </div>\n        </Card>\n      </div>\n    </div>\n  );\n}",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}