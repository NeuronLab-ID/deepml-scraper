{
  "problem_id": 19,
  "title": "Principal Component Analysis (PCA) Implementation",
  "category": "Machine Learning",
  "enabled": true,
  "type": "react",
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst theme = {\n  colors: {\n    primary: '#8b5cf6',\n    background: '#0a0a0a',\n    surface: '#111111',\n    surfaceAlt: '#1a1a1a',\n    border: '#2a2a2a',\n    text: '#fafafa',\n    textSecondary: '#a1a1aa',\n    textMuted: '#52525b',\n    positive: '#10b981',\n    negative: '#f43f5e',\n    blue: '#38bdf8',\n    yellow: '#fbbf24',\n    pink: '#f472b6',\n    green: '#a3e635',\n    orange: '#fb923c',\n  },\n  font: \"'JetBrains Mono', monospace\",\n};\n\nconst examples = [\n  {\n    name: 'Diagonal',\n    data: [[1,1],[2,2.2],[3,2.8],[4,4.1],[5,5],[6,5.9],[7,7.2]],\n  },\n  {\n    name: 'Elongated',\n    data: [[1,3],[2,3.5],[3,3.2],[4,3.8],[5,3.1],[6,3.6],[7,3.3],[8,3.7]],\n  },\n  {\n    name: 'Spread',\n    data: [[2,5],[3,2],[5,6],[4,3],[6,4],[3,5],[5,2],[4,5]],\n  },\n];\n\nconst stepInfo = [\n  {\n    title: 'Original Data',\n    desc: 'We start with 2D data points. PCA will find the directions of maximum variance. Drag points to explore how the data shape affects principal components.',\n    color: theme.colors.primary,\n  },\n  {\n    title: 'Step 1: Standardize the Data',\n    desc: 'Subtract the mean and divide by standard deviation. This centers the data at origin and scales features equally. Watch the data shift to center.',\n    color: theme.colors.blue,\n  },\n  {\n    title: 'Step 2: Compute Covariance Matrix',\n    desc: 'The covariance matrix captures how features vary together. High covariance means features are correlated (data stretches diagonally).',\n    color: theme.colors.yellow,\n  },\n  {\n    title: 'Step 3: Find Eigenvectors',\n    desc: 'Eigenvectors of the covariance matrix point in the directions of maximum variance. The pink arrow (PC1) captures the most variance.',\n    color: theme.colors.pink,\n  },\n  {\n    title: 'Step 4: Project onto PC1',\n    desc: 'Projecting data onto PC1 reduces 2D to 1D while keeping maximum variance. The green dots show where each point lands on PC1.',\n    color: theme.colors.green,\n  },\n];\n\nexport default function App() {\n  const [exampleIdx, setExampleIdx] = useState(0);\n  const [step, setStep] = useState(0);\n  const [playing, setPlaying] = useState(false);\n  const [data, setData] = useState([]);\n  const [dragging, setDragging] = useState(null);\n  const canvasRef = useRef(null);\n\n  const totalSteps = 4;\n  const size = 300;\n  const padding = 40;\n  const plotSize = size - 2 * padding;\n\n  // Initialize data\n  useEffect(() => {\n    setData(examples[exampleIdx].data.map(p => [...p]));\n    setStep(0);\n  }, [exampleIdx]);\n\n  // Compute statistics\n  const computeStats = () => {\n    if (data.length === 0) return null;\n    \n    const n = data.length;\n    const meanX = data.reduce((s, p) => s + p[0], 0) / n;\n    const meanY = data.reduce((s, p) => s + p[1], 0) / n;\n    \n    const stdX = Math.sqrt(data.reduce((s, p) => s + (p[0] - meanX) ** 2, 0) / n);\n    const stdY = Math.sqrt(data.reduce((s, p) => s + (p[1] - meanY) ** 2, 0) / n);\n    \n    // Standardized data\n    const standardized = data.map(p => [\n      (p[0] - meanX) / (stdX || 1),\n      (p[1] - meanY) / (stdY || 1),\n    ]);\n    \n    // Covariance matrix (using n-1 for sample covariance)\n    const covXX = standardized.reduce((s, p) => s + p[0] * p[0], 0) / (n - 1);\n    const covYY = standardized.reduce((s, p) => s + p[1] * p[1], 0) / (n - 1);\n    const covXY = standardized.reduce((s, p) => s + p[0] * p[1], 0) / (n - 1);\n    \n    // Eigenvalues for 2x2 matrix\n    const trace = covXX + covYY;\n    const det = covXX * covYY - covXY * covXY;\n    const disc = Math.sqrt(Math.max(0, trace * trace - 4 * det));\n    const lambda1 = (trace + disc) / 2;\n    const lambda2 = (trace - disc) / 2;\n    \n    // Eigenvectors\n    let ev1, ev2;\n    if (Math.abs(covXY) > 0.0001) {\n      ev1 = [covXY, lambda1 - covXX];\n      ev2 = [covXY, lambda2 - covXX];\n    } else {\n      ev1 = covXX >= covYY ? [1, 0] : [0, 1];\n      ev2 = covXX >= covYY ? [0, 1] : [1, 0];\n    }\n    \n    // Normalize\n    const norm1 = Math.sqrt(ev1[0] ** 2 + ev1[1] ** 2);\n    const norm2 = Math.sqrt(ev2[0] ** 2 + ev2[1] ** 2);\n    ev1 = [ev1[0] / norm1, ev1[1] / norm1];\n    ev2 = [ev2[0] / norm2, ev2[1] / norm2];\n    \n    // Variance explained\n    const totalVar = lambda1 + lambda2;\n    const varExplained1 = totalVar > 0 ? lambda1 / totalVar : 0.5;\n    const varExplained2 = totalVar > 0 ? lambda2 / totalVar : 0.5;\n    \n    // Projections onto PC1\n    const projections = standardized.map(p => {\n      const dot = p[0] * ev1[0] + p[1] * ev1[1];\n      return [dot * ev1[0], dot * ev1[1]];\n    });\n    \n    return {\n      mean: [meanX, meanY],\n      std: [stdX, stdY],\n      standardized,\n      cov: [[covXX, covXY], [covXY, covYY]],\n      eigenvalues: [lambda1, lambda2],\n      eigenvectors: [ev1, ev2],\n      varExplained: [varExplained1, varExplained2],\n      projections,\n    };\n  };\n\n  const stats = computeStats();\n\n  const reset = () => {\n    setData(examples[exampleIdx].data.map(p => [...p]));\n    setStep(0);\n    setPlaying(false);\n  };\n\n  const next = () => step < totalSteps && setStep(step + 1);\n  const prev = () => step > 0 && setStep(step - 1);\n\n  const auto = async () => {\n    setPlaying(true);\n    for (let s = step; s <= totalSteps; s++) {\n      setStep(s);\n      await new Promise(r => setTimeout(r, 1200));\n    }\n    setPlaying(false);\n  };\n\n  // Mouse handlers for dragging points\n  const getMousePos = (e) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Convert to data coordinates (original scale)\n    const allX = data.map(p => p[0]);\n    const allY = data.map(p => p[1]);\n    const minX = Math.min(...allX) - 1;\n    const maxX = Math.max(...allX) + 1;\n    const minY = Math.min(...allY) - 1;\n    const maxY = Math.max(...allY) + 1;\n    \n    const dataX = minX + ((x - padding) / plotSize) * (maxX - minX);\n    const dataY = maxY - ((y - padding) / plotSize) * (maxY - minY);\n    \n    return [dataX, dataY];\n  };\n\n  const handleMouseDown = (e) => {\n    if (step > 0) return;\n    const [mx, my] = getMousePos(e);\n    \n    let closest = null;\n    let minDist = 0.8;\n    data.forEach((p, i) => {\n      const d = Math.sqrt((p[0] - mx) ** 2 + (p[1] - my) ** 2);\n      if (d < minDist) {\n        minDist = d;\n        closest = i;\n      }\n    });\n    \n    if (closest !== null) {\n      setDragging(closest);\n    }\n  };\n\n  const handleMouseMove = (e) => {\n    if (dragging === null || step > 0) return;\n    const [mx, my] = getMousePos(e);\n    setData(prev => {\n      const newData = [...prev];\n      newData[dragging] = [mx, my];\n      return newData;\n    });\n  };\n\n  const handleMouseUp = () => {\n    setDragging(null);\n  };\n\n  // Canvas drawing\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !stats) return;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = theme.colors.surface;\n    ctx.fillRect(0, 0, size, size);\n\n    // Determine scale based on step\n    let displayData = data;\n    let bounds;\n    \n    if (step >= 1) {\n      displayData = stats.standardized;\n      bounds = { minX: -3, maxX: 3, minY: -3, maxY: 3 };\n    } else {\n      const allX = data.map(p => p[0]);\n      const allY = data.map(p => p[1]);\n      bounds = {\n        minX: Math.min(...allX) - 1,\n        maxX: Math.max(...allX) + 1,\n        minY: Math.min(...allY) - 1,\n        maxY: Math.max(...allY) + 1,\n      };\n    }\n\n    const scaleX = (x) => padding + ((x - bounds.minX) / (bounds.maxX - bounds.minX)) * plotSize;\n    const scaleY = (y) => size - padding - ((y - bounds.minY) / (bounds.maxY - bounds.minY)) * plotSize;\n\n    // Grid\n    ctx.strokeStyle = theme.colors.border;\n    ctx.lineWidth = 1;\n    for (let i = 0; i <= 4; i++) {\n      const x = padding + (i / 4) * plotSize;\n      const y = padding + (i / 4) * plotSize;\n      ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, size - padding); ctx.stroke();\n      ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(size - padding, y); ctx.stroke();\n    }\n\n    // Axes through origin (for standardized view)\n    if (step >= 1) {\n      ctx.strokeStyle = theme.colors.textMuted;\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(scaleX(0), padding);\n      ctx.lineTo(scaleX(0), size - padding);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(padding, scaleY(0));\n      ctx.lineTo(size - padding, scaleY(0));\n      ctx.stroke();\n    }\n\n    // Mean crosshairs (step 0)\n    if (step === 0) {\n      ctx.strokeStyle = theme.colors.blue + '60';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([4, 4]);\n      ctx.beginPath();\n      ctx.moveTo(scaleX(stats.mean[0]), padding);\n      ctx.lineTo(scaleX(stats.mean[0]), size - padding);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(padding, scaleY(stats.mean[1]));\n      ctx.lineTo(size - padding, scaleY(stats.mean[1]));\n      ctx.stroke();\n      ctx.setLineDash([]);\n      \n      ctx.fillStyle = theme.colors.blue;\n      ctx.font = '9px JetBrains Mono, monospace';\n      ctx.textAlign = 'left';\n      ctx.fillText('mean', scaleX(stats.mean[0]) + 4, scaleY(stats.mean[1]) - 4);\n    }\n\n    // Eigenvector arrows (step 3+)\n    if (step >= 3) {\n      const ev1 = stats.eigenvectors[0];\n      const ev2 = stats.eigenvectors[1];\n      const arrowLen = 2.2;\n      \n      // PC1 (pink, longer)\n      ctx.strokeStyle = theme.colors.pink;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(scaleX(-ev1[0] * arrowLen), scaleY(-ev1[1] * arrowLen));\n      ctx.lineTo(scaleX(ev1[0] * arrowLen), scaleY(ev1[1] * arrowLen));\n      ctx.stroke();\n      \n      // PC1 arrow head\n      const angle1 = Math.atan2(-ev1[1], ev1[0]);\n      const ax1 = scaleX(ev1[0] * arrowLen);\n      const ay1 = scaleY(ev1[1] * arrowLen);\n      ctx.beginPath();\n      ctx.moveTo(ax1, ay1);\n      ctx.lineTo(ax1 - 10 * Math.cos(angle1 - 0.4), ay1 + 10 * Math.sin(angle1 - 0.4));\n      ctx.lineTo(ax1 - 10 * Math.cos(angle1 + 0.4), ay1 + 10 * Math.sin(angle1 + 0.4));\n      ctx.closePath();\n      ctx.fillStyle = theme.colors.pink;\n      ctx.fill();\n      \n      // PC2 (orange, shorter)\n      ctx.strokeStyle = theme.colors.orange;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(scaleX(-ev2[0] * arrowLen * 0.6), scaleY(-ev2[1] * arrowLen * 0.6));\n      ctx.lineTo(scaleX(ev2[0] * arrowLen * 0.6), scaleY(ev2[1] * arrowLen * 0.6));\n      ctx.stroke();\n      \n      // Labels\n      ctx.font = '10px JetBrains Mono, monospace';\n      ctx.fillStyle = theme.colors.pink;\n      ctx.fillText('PC1', scaleX(ev1[0] * arrowLen) + 5, scaleY(ev1[1] * arrowLen));\n      ctx.fillStyle = theme.colors.orange;\n      ctx.fillText('PC2', scaleX(ev2[0] * arrowLen * 0.6) + 5, scaleY(ev2[1] * arrowLen * 0.6));\n    }\n\n    // Projection lines and points (step 4)\n    if (step >= 4) {\n      const ev1 = stats.eigenvectors[0];\n      ctx.strokeStyle = theme.colors.green + '60';\n      ctx.lineWidth = 1;\n      ctx.setLineDash([3, 3]);\n      \n      displayData.forEach((p, i) => {\n        const proj = stats.projections[i];\n        ctx.beginPath();\n        ctx.moveTo(scaleX(p[0]), scaleY(p[1]));\n        ctx.lineTo(scaleX(proj[0]), scaleY(proj[1]));\n        ctx.stroke();\n      });\n      ctx.setLineDash([]);\n      \n      // Projected points\n      stats.projections.forEach(proj => {\n        ctx.fillStyle = theme.colors.green;\n        ctx.beginPath();\n        ctx.arc(scaleX(proj[0]), scaleY(proj[1]), 5, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n\n    // Data points\n    displayData.forEach((p, i) => {\n      const isProjected = step >= 4;\n      ctx.fillStyle = isProjected ? theme.colors.blue : theme.colors.pink;\n      ctx.beginPath();\n      ctx.arc(scaleX(p[0]), scaleY(p[1]), 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = theme.colors.surface;\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    });\n\n    // Drag hint\n    if (step === 0) {\n      ctx.fillStyle = theme.colors.textSecondary;\n      ctx.font = '9px JetBrains Mono, monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText('Drag points to explore', size / 2, size - 10);\n    }\n\n  }, [step, data, stats, dragging]);\n\n  const formatNum = (n) => n.toFixed(4);\n\n  return (\n    <div style={{\n      background: theme.colors.background,\n      padding: '16px',\n      fontFamily: theme.font,\n      color: theme.colors.text,\n      minHeight: '100vh',\n      boxSizing: 'border-box',\n    }}>\n      {/* Header */}\n      <div style={{ textAlign: 'center', marginBottom: '12px' }}>\n        <div style={{ fontSize: '18px', fontWeight: '700' }}>\n          Principal Component Analysis (PCA)\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary }}>\n          Find the directions of maximum variance\n        </div>\n      </div>\n\n      {/* Example Tabs */}\n      <div style={{ display: 'flex', gap: '6px', justifyContent: 'center', marginBottom: '12px' }}>\n        {examples.map((e, idx) => (\n          <button\n            key={idx}\n            onClick={() => { setExampleIdx(idx); }}\n            style={{\n              padding: '6px 12px',\n              background: exampleIdx === idx ? theme.colors.primary : theme.colors.surface,\n              border: 'none',\n              borderRadius: '6px',\n              color: exampleIdx === idx ? '#fff' : theme.colors.textSecondary,\n              fontFamily: theme.font,\n              fontSize: '11px',\n              cursor: 'pointer',\n            }}\n          >\n            {e.name}\n          </button>\n        ))}\n      </div>\n\n      {/* Visualization */}\n      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '12px' }}>\n        <canvas\n          ref={canvasRef}\n          width={size}\n          height={size}\n          style={{\n            borderRadius: '8px',\n            border: '1px solid ' + (step === 0 ? theme.colors.primary : theme.colors.border),\n            cursor: step === 0 ? 'grab' : 'default',\n          }}\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n        />\n      </div>\n\n      {/* Stats Display */}\n      {stats && step >= 3 && (\n        <div style={{\n          display: 'flex',\n          justifyContent: 'center',\n          gap: '10px',\n          marginBottom: '12px',\n          flexWrap: 'wrap',\n        }}>\n          <div style={{\n            padding: '6px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n            border: '2px solid ' + theme.colors.pink,\n          }}>\n            <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>PC1 variance</span>\n            <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.pink }}>\n              {(stats.varExplained[0] * 100).toFixed(1)}%\n            </div>\n          </div>\n          <div style={{\n            padding: '6px 10px',\n            background: theme.colors.surface,\n            borderRadius: '6px',\n            border: '2px solid ' + theme.colors.orange,\n          }}>\n            <span style={{ fontSize: '9px', color: theme.colors.textMuted }}>PC2 variance</span>\n            <div style={{ fontSize: '14px', fontWeight: '600', color: theme.colors.orange }}>\n              {(stats.varExplained[1] * 100).toFixed(1)}%\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Step Explanation */}\n      <div style={{\n        padding: '10px 12px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        borderLeft: '3px solid ' + stepInfo[step].color,\n        marginBottom: '12px',\n      }}>\n        <div style={{ fontSize: '12px', fontWeight: '600', color: theme.colors.text }}>\n          {stepInfo[step].title}\n        </div>\n        <div style={{ fontSize: '11px', color: theme.colors.textSecondary, lineHeight: 1.5 }}>\n          {stepInfo[step].desc}\n        </div>\n      </div>\n\n      {/* Step Dots */}\n      <div style={{ display: 'flex', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>\n        {Array.from({ length: totalSteps + 1 }).map((_, i) => (\n          <div\n            key={i}\n            onClick={() => setStep(i)}\n            style={{\n              width: i === step ? '20px' : '8px',\n              height: '8px',\n              borderRadius: '4px',\n              background: i <= step ? theme.colors.primary : theme.colors.border,\n              cursor: 'pointer',\n              transition: 'all 0.3s',\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Controls */}\n      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>\n        <button\n          onClick={prev}\n          disabled={step <= 0 || playing}\n          style={{\n            padding: '8px 12px',\n            background: step <= 0 ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: step <= 0 ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: step <= 0 ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {'<'}\n        </button>\n        <button\n          onClick={next}\n          disabled={step >= totalSteps || playing}\n          style={{\n            flex: 1,\n            padding: '10px 16px',\n            background: theme.colors.primary,\n            border: 'none',\n            borderRadius: '6px',\n            color: '#fff',\n            fontFamily: theme.font,\n            fontSize: '12px',\n            fontWeight: '600',\n            cursor: step >= totalSteps ? 'not-allowed' : 'pointer',\n            opacity: step >= totalSteps ? 0.5 : 1,\n          }}\n        >\n          {step === 0 ? 'Start' : step < totalSteps ? 'Next Step' : 'Complete!'}\n        </button>\n        <button\n          onClick={auto}\n          disabled={playing || step >= totalSteps}\n          style={{\n            padding: '8px 12px',\n            background: playing ? theme.colors.border : theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: playing ? theme.colors.textMuted : theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: playing ? 'not-allowed' : 'pointer',\n          }}\n        >\n          {playing ? '...' : '>>'}\n        </button>\n        <button\n          onClick={reset}\n          style={{\n            padding: '8px 12px',\n            background: theme.colors.surface,\n            border: 'none',\n            borderRadius: '6px',\n            color: theme.colors.text,\n            fontFamily: theme.font,\n            fontSize: '14px',\n            cursor: 'pointer',\n          }}\n        >\n          {'~'}\n        </button>\n      </div>\n\n      {/* Math Details */}\n      {stats && step >= 1 && (\n        <div style={{\n          padding: '10px',\n          background: theme.colors.surfaceAlt,\n          borderRadius: '8px',\n          marginBottom: '12px',\n        }}>\n          {step === 1 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.blue, marginBottom: '6px', fontWeight: '600' }}>\n                Standardization: (x - mean) / std\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                Mean: ({stats.mean[0].toFixed(2)}, {stats.mean[1].toFixed(2)}) | \n                Std: ({stats.std[0].toFixed(2)}, {stats.std[1].toFixed(2)})\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                Data is now centered at origin with unit variance\n              </div>\n            </div>\n          )}\n\n          {step === 2 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.yellow, marginBottom: '6px', fontWeight: '600' }}>\n                Covariance Matrix\n              </div>\n              <div style={{ \n                display: 'grid', \n                gridTemplateColumns: '1fr 1fr',\n                gap: '4px',\n                maxWidth: '200px',\n                margin: '0 auto',\n              }}>\n                {stats.cov.flat().map((v, i) => (\n                  <div key={i} style={{\n                    padding: '6px',\n                    background: theme.colors.surface,\n                    borderRadius: '4px',\n                    fontSize: '11px',\n                    textAlign: 'center',\n                    color: theme.colors.yellow,\n                  }}>\n                    {v.toFixed(3)}\n                  </div>\n                ))}\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '6px', textAlign: 'center' }}>\n                Off-diagonal values show correlation between x and y\n              </div>\n            </div>\n          )}\n\n          {step === 3 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.pink, marginBottom: '6px', fontWeight: '600' }}>\n                Eigenvectors (Principal Components)\n              </div>\n              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>\n                <div style={{ padding: '6px 10px', background: theme.colors.surface, borderRadius: '4px' }}>\n                  <span style={{ color: theme.colors.pink, fontSize: '10px' }}>PC1: </span>\n                  <span style={{ color: theme.colors.text, fontSize: '10px' }}>\n                    [{formatNum(stats.eigenvectors[0][0])}, {formatNum(stats.eigenvectors[0][1])}]\n                  </span>\n                </div>\n                <div style={{ padding: '6px 10px', background: theme.colors.surface, borderRadius: '4px' }}>\n                  <span style={{ color: theme.colors.orange, fontSize: '10px' }}>PC2: </span>\n                  <span style={{ color: theme.colors.text, fontSize: '10px' }}>\n                    [{formatNum(stats.eigenvectors[1][0])}, {formatNum(stats.eigenvectors[1][1])}]\n                  </span>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {step === 4 && (\n            <div>\n              <div style={{ fontSize: '11px', color: theme.colors.green, marginBottom: '6px', fontWeight: '600' }}>\n                Projection onto PC1 (dimensionality reduction)\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textSecondary }}>\n                Original: 2D ({data.length} points x 2 features)\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.green }}>\n                Reduced: 1D ({data.length} points x 1 component)\n              </div>\n              <div style={{ fontSize: '10px', color: theme.colors.textMuted, marginTop: '4px' }}>\n                PC1 captures {(stats.varExplained[0] * 100).toFixed(1)}% of total variance\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Key Insight */}\n      <div style={{\n        padding: '10px 14px',\n        background: theme.colors.surface,\n        borderRadius: '8px',\n        fontSize: '10px',\n        color: theme.colors.textSecondary,\n        textAlign: 'center',\n      }}>\n        <strong style={{ color: theme.colors.text }}>Key insight:</strong>{' '}\n        PCA finds orthogonal axes that maximize variance. The first principal component captures the most information about the data's spread.\n      </div>\n    </div>\n  );\n}\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showEditor": false,
    "editorWidthPercentage": 35,
    "showConsole": false
  },
  "dependencies": {}
}