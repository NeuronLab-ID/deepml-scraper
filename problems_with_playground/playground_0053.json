{
  "problem_id": 53,
  "title": "Implement Self-Attention Mechanism",
  "category": "Deep Learning",
  "enabled": true,
  "type": "react",
  "code": "\nimport React, { useState, useEffect, useMemo } from 'react';\n\nconst theme = {\n  bg: '#0a0a0a',\n  surface: '#141414',\n  card: '#1a1a1a',\n  border: '#2a2a2a',\n  text: '#fafafa',\n  muted: '#a1a1aa',\n  dim: '#52525b',\n  query: '#c084fc',\n  key: '#38bdf8',\n  value: '#fb923c',\n  output: '#4ade80',\n  attention: '#fbbf24',\n};\n\nconst dot = (a, b) => a.reduce((sum, val, i) => sum + val * b[i], 0);\nconst matMul = (a, b) => a.map(row => b[0].map((_, j) => row.reduce((sum, val, k) => sum + val * b[k][j], 0)));\n\nconst INITIAL_TOKENS = [\n  { label: 'I', vec: [1.0, 0.2] },\n  { label: 'love', vec: [0.8, 0.9] },\n  { label: 'code', vec: [0.3, 1.0] },\n];\n\n// Different weight matrices so Q, K, V are distinct projections\nconst W_Q = [[0.8, 0.3], [0.2, 0.9]];\nconst W_K = [[0.6, 0.7], [0.5, 0.4]];  \nconst W_V = [[1.0, 0.1], [0.2, 0.8]];\n\nexport default function App() {\n  const [tokens, setTokens] = useState(INITIAL_TOKENS);\n  const [selected, setSelected] = useState(0);\n  const [flowPhase, setFlowPhase] = useState(0);\n  const [hovered, setHovered] = useState(null);\n\n  // Computations\n  const X = tokens.map(t => t.vec);\n  const Q = useMemo(() => matMul(X, W_Q), [X]);\n  const K = useMemo(() => matMul(X, W_K), [X]);\n  const V = useMemo(() => matMul(X, W_V), [X]);\n  \n  const scale = Math.sqrt(2);\n  const scores = useMemo(() => Q.map(q => K.map(k => dot(q, k) / scale)), [Q, K]);\n  \n  const weights = useMemo(() => {\n    return scores.map(row => {\n      const exps = row.map(Math.exp);\n      const sum = exps.reduce((a, b) => a + b, 0);\n      return exps.map(e => e / sum);\n    });\n  }, [scores]);\n  \n  const output = useMemo(() => matMul(weights, V), [weights, V]);\n\n  useEffect(() => {\n    const interval = setInterval(() => setFlowPhase(p => (p + 1) % 100), 50);\n    return () => clearInterval(interval);\n  }, []);\n\n  const updateVector = (idx, dim, delta) => {\n    const newTokens = [...tokens];\n    newTokens[idx] = { ...newTokens[idx], vec: [...newTokens[idx].vec] };\n    newTokens[idx].vec[dim] = Math.max(0, Math.min(2, +(newTokens[idx].vec[dim] + delta).toFixed(1)));\n    setTokens(newTokens);\n  };\n\n  const currentWeights = weights[selected] || [0, 0, 0];\n  const maxIdx = currentWeights.indexOf(Math.max(...currentWeights));\n\n  return (\n    <div style={styles.container}>\n      {/* Header */}\n      <div style={styles.header}>\n        <h1 style={styles.title}>Self-Attention</h1>\n        <p style={styles.subtitle}>Click a word ‚Ä¢ Adjust vectors ‚Ä¢ Watch attention flow</p>\n      </div>\n\n      {/* Token Selection with Editable Vectors */}\n      <div style={styles.tokensSection}>\n        {tokens.map((token, i) => {\n          const isSelected = i === selected;\n          const isHov = i === hovered;\n          const weight = currentWeights[i] || 0;\n          const isMax = i === maxIdx;\n          \n          return (\n            <div\n              key={i}\n              onClick={() => setSelected(i)}\n              onMouseEnter={() => setHovered(i)}\n              onMouseLeave={() => setHovered(null)}\n              style={{\n                ...styles.tokenCard,\n                background: isSelected ? theme.query : theme.surface,\n                borderColor: isSelected ? theme.query : isMax ? theme.attention : isHov ? theme.muted : theme.border,\n                transform: isSelected ? 'scale(1.05)' : isHov ? 'scale(1.02)' : 'scale(1)',\n                boxShadow: isSelected ? `0 8px 30px ${theme.query}30` : 'none',\n              }}\n            >\n              <div style={{\n                fontSize: 22, fontWeight: 700,\n                color: isSelected ? '#fff' : theme.text,\n              }}>{token.label}</div>\n              \n              <div style={styles.vecEditor}>\n                {[0, 1].map(d => (\n                  <div key={d} style={styles.vecControl}>\n                    <button \n                      onClick={(e) => { e.stopPropagation(); updateVector(i, d, -0.1); }}\n                      style={styles.vecBtn}\n                    >‚àí</button>\n                    <span style={{\n                      ...styles.vecVal,\n                      color: isSelected ? '#fff' : theme.muted,\n                    }}>{token.vec[d].toFixed(1)}</span>\n                    <button \n                      onClick={(e) => { e.stopPropagation(); updateVector(i, d, 0.1); }}\n                      style={styles.vecBtn}\n                    >+</button>\n                  </div>\n                ))}\n              </div>\n              \n              {!isSelected && (\n                <div style={{\n                  ...styles.weightBadge,\n                  background: isMax ? theme.attention : theme.dim,\n                  color: isMax ? '#000' : '#fff',\n                }}>\n                  {(weight * 100).toFixed(0)}%\n                </div>\n              )}\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Main Content - Two Column Layout */}\n      <div style={styles.mainGrid}>\n        \n        {/* Left: Steps */}\n        <div style={styles.stepsColumn}>\n          \n          {/* Query */}\n          <div style={styles.stepRow}>\n            <div style={{...styles.badge, background: theme.query}}>Q</div>\n            <div style={styles.stepContent}>\n              <div style={styles.stepTitle}>\n                <span style={{color: theme.query}}>Query</span>: \"What am I looking for?\"\n              </div>\n              <div style={styles.stepDesc}>\n                <span style={{color: theme.query, fontWeight: 600}}>\"{tokens[selected].label}\"</span> creates a query vector to search for relevant context.\n              </div>\n              <div style={styles.vectorDisplay}>\n                <span style={{color: theme.query}}>Q = [{Q[selected].map(v => v.toFixed(2)).join(', ')}]</span>\n              </div>\n            </div>\n          </div>\n\n          {/* Keys */}\n          <div style={styles.stepRow}>\n            <div style={{...styles.badge, background: theme.key}}>K</div>\n            <div style={styles.stepContent}>\n              <div style={styles.stepTitle}>\n                <span style={{color: theme.key}}>Keys</span>: \"What can I be matched on?\"\n              </div>\n              <div style={styles.stepDesc}>\n                Each word has a Key ‚Äî like a <b>label or tag</b> that describes what it offers. \n                <span style={{color: theme.muted}}> Q matches against all Keys to find relevant words.</span>\n              </div>\n              <div style={styles.keysRow}>\n                {tokens.map((t, i) => (\n                  <div key={i} style={{\n                    ...styles.keyChip,\n                    borderColor: i === maxIdx ? theme.attention : theme.border,\n                  }}>\n                    <span style={{fontWeight: 600}}>{t.label}</span>\n                    <span style={{fontSize: 10, color: theme.key}}>\n                      [{K[i].map(v => v.toFixed(1)).join(', ')}]\n                    </span>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n\n          {/* Attention Flow */}\n          <div style={styles.flowSection}>\n            <div style={styles.flowHeader}>\n              <div style={{...styles.badge, background: theme.attention}}>!</div>\n              <span style={{color: theme.muted}}>Q ¬∑ K ‚Üí softmax ‚Üí attention weights</span>\n            </div>\n            \n            <svg style={styles.flowSvg} viewBox=\"0 0 340 50\">\n              {tokens.map((_, i) => {\n                const x = 57 + i * 113;\n                const weight = currentWeights[i];\n                const isMax = i === maxIdx;\n                \n                return (\n                  <g key={i}>\n                    <line\n                      x1={170} y1={0} x2={x} y2={50}\n                      stroke={isMax ? theme.attention : theme.dim}\n                      strokeWidth={2 + weight * 8}\n                      opacity={0.3 + weight * 0.5}\n                      strokeLinecap=\"round\"\n                    />\n                    {[0, 1, 2].map(p => {\n                      const progress = ((flowPhase + p * 33) % 100) / 100;\n                      return (\n                        <circle\n                          key={p}\n                          cx={170 + (x - 170) * progress}\n                          cy={progress * 50}\n                          r={2 + weight * 3}\n                          fill={isMax ? theme.attention : theme.muted}\n                          opacity={weight * (1 - progress * 0.4)}\n                        />\n                      );\n                    })}\n                  </g>\n                );\n              })}\n            </svg>\n\n            <div style={styles.weightsRow}>\n              {tokens.map((t, i) => {\n                const weight = currentWeights[i];\n                const isMax = i === maxIdx;\n                return (\n                  <div key={i} style={styles.weightCol}>\n                    <div style={{\n                      ...styles.weightBar,\n                      height: `${weight * 50}px`,\n                      background: isMax ? theme.attention : theme.dim,\n                    }} />\n                    <span style={{\n                      fontSize: 13, fontWeight: isMax ? 700 : 400,\n                      color: isMax ? theme.attention : theme.muted,\n                    }}>{(weight * 100).toFixed(0)}%</span>\n                    <span style={{fontSize: 12, color: theme.muted}}>{t.label}</span>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n\n          {/* Values & Output */}\n          <div style={styles.stepRow}>\n            <div style={{...styles.badge, background: theme.value}}>V</div>\n            <div style={styles.stepContent}>\n              <div style={styles.stepTitle}>\n                <span style={{color: theme.value}}>Values</span>: \"What do I actually contain?\"\n              </div>\n              <div style={styles.stepDesc}>\n                Values hold the <b>actual content</b> to retrieve. Keys decide <i>how much</i> attention; Values provide <i>what</i> gets passed along.\n              </div>\n              <div style={styles.valuesRow}>\n                {tokens.map((t, i) => {\n                  const weight = currentWeights[i];\n                  const isMax = i === maxIdx;\n                  return (\n                    <div key={i} style={{\n                      ...styles.valueChip,\n                      opacity: 0.4 + weight * 0.6,\n                      borderColor: isMax ? theme.attention : theme.border,\n                    }}>\n                      <span style={{fontWeight: 600, fontSize: 11}}>{t.label}</span>\n                      <span style={{fontSize: 10, color: theme.value}}>\n                        [{V[i].map(v => v.toFixed(1)).join(', ')}]\n                      </span>\n                      <span style={{fontSize: 9, color: theme.attention}}>\n                        √ó{(weight).toFixed(2)}\n                      </span>\n                    </div>\n                  );\n                })}\n              </div>\n              <div style={styles.outputBox}>\n                <span style={{color: theme.muted}}>Output = </span>\n                <span style={{color: theme.output, fontWeight: 700}}>\n                  [{output[selected].map(v => v.toFixed(2)).join(', ')}]\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Right: Attention Matrix + Analogy */}\n        <div style={styles.rightColumn}>\n          <div style={styles.matrixSection}>\n            <div style={styles.matrixTitle}>Attention Matrix</div>\n            <div style={styles.matrixGrid}>\n              <div />\n              {tokens.map((t, i) => (\n                <div key={i} style={{textAlign: 'center', color: theme.key, fontWeight: 600, fontSize: 12}}>\n                  {t.label}\n                </div>\n              ))}\n              {tokens.map((rowToken, r) => (\n                <React.Fragment key={r}>\n                  <div style={{textAlign: 'right', color: theme.query, fontWeight: 600, fontSize: 12, paddingRight: 8}}>\n                    {rowToken.label}\n                  </div>\n                  {tokens.map((_, c) => {\n                    const val = weights[r][c];\n                    const isCurrentRow = r === selected;\n                    const isMax = c === weights[r].indexOf(Math.max(...weights[r]));\n                    return (\n                      <div \n                        key={c}\n                        onClick={() => setSelected(r)}\n                        style={{\n                          ...styles.cell,\n                          background: isCurrentRow \n                            ? `rgba(192, 132, 252, ${val * 0.8})` \n                            : `rgba(74, 222, 128, ${val * 0.6})`,\n                          color: val > 0.4 ? '#000' : theme.text,\n                          border: isCurrentRow ? `2px solid ${theme.query}` : `1px solid ${theme.border}`,\n                          fontWeight: isMax ? 700 : 500,\n                          cursor: 'pointer',\n                        }}\n                      >\n                        {(val * 100).toFixed(0)}%\n                      </div>\n                    );\n                  })}\n                </React.Fragment>\n              ))}\n            </div>\n            <div style={styles.matrixCaption}>\n              Click row to switch query\n            </div>\n          </div>\n          \n          {/* Analogy Box */}\n          <div style={styles.analogyBox}>\n            <div style={styles.analogyTitle}>üîç Think of it like search:</div>\n            <div style={styles.analogyItem}>\n              <span style={{color: theme.query}}>Q</span> = your search query\n            </div>\n            <div style={styles.analogyItem}>\n              <span style={{color: theme.key}}>K</span> = tags on each result\n            </div>\n            <div style={styles.analogyItem}>\n              <span style={{color: theme.value}}>V</span> = the actual content\n            </div>\n            <div style={styles.analogyDesc}>\n              High Q¬∑K match ‚Üí retrieve more of that V\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Formula */}\n      <div style={styles.formulaBox}>\n        <span style={{color: theme.muted}}>Attention(</span>\n        <span style={{color: theme.query}}>Q</span>\n        <span style={{color: theme.muted}}>, </span>\n        <span style={{color: theme.key}}>K</span>\n        <span style={{color: theme.muted}}>, </span>\n        <span style={{color: theme.value}}>V</span>\n        <span style={{color: theme.muted}}>) = softmax(</span>\n        <span style={{color: theme.query}}>Q</span>\n        <span style={{color: theme.key}}>K</span>\n        <sup style={{color: theme.muted}}>T</sup>\n        <span style={{color: theme.muted}}> / ‚àöd) √ó </span>\n        <span style={{color: theme.value}}>V</span>\n      </div>\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    fontFamily: \"'Inter', -apple-system, sans-serif\",\n    background: theme.bg,\n    color: theme.text,\n    minHeight: '100vh',\n    padding: 20,\n    maxWidth: 720,\n    margin: '0 auto',\n  },\n  header: { textAlign: 'center', marginBottom: 20 },\n  title: { \n    fontSize: 28, fontWeight: 800, margin: 0,\n    background: `linear-gradient(90deg, ${theme.query}, ${theme.key}, ${theme.value})`,\n    WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent',\n  },\n  subtitle: { fontSize: 13, color: theme.muted, margin: '6px 0 0' },\n  tokensSection: {\n    display: 'flex', justifyContent: 'center', gap: 16, marginBottom: 20,\n  },\n  tokenCard: {\n    padding: '14px 20px', borderRadius: 14, border: '2px solid',\n    cursor: 'pointer', transition: 'all 0.2s ease', textAlign: 'center',\n    position: 'relative', minWidth: 100,\n  },\n  vecEditor: {\n    display: 'flex', gap: 8, marginTop: 10, justifyContent: 'center',\n  },\n  vecControl: {\n    display: 'flex', alignItems: 'center',\n    background: 'rgba(255,255,255,0.1)', borderRadius: 6,\n  },\n  vecBtn: {\n    background: 'transparent', border: 'none', color: theme.muted,\n    cursor: 'pointer', padding: '4px 8px', fontSize: 16, fontWeight: 600,\n  },\n  vecVal: { width: 32, textAlign: 'center', fontSize: 12, fontWeight: 600 },\n  weightBadge: {\n    position: 'absolute', top: -10, right: -10,\n    padding: '4px 10px', borderRadius: 12, fontSize: 11, fontWeight: 700,\n  },\n  mainGrid: {\n    display: 'grid', gridTemplateColumns: '1fr 210px', gap: 16, marginBottom: 16,\n  },\n  stepsColumn: {\n    display: 'flex', flexDirection: 'column', gap: 12,\n  },\n  rightColumn: {\n    display: 'flex', flexDirection: 'column', gap: 12,\n  },\n  stepRow: {\n    display: 'flex', alignItems: 'flex-start', gap: 12,\n    padding: 14, background: theme.surface, borderRadius: 12,\n  },\n  badge: {\n    width: 28, height: 28, borderRadius: 8, display: 'flex',\n    alignItems: 'center', justifyContent: 'center',\n    fontWeight: 800, fontSize: 13, color: '#fff', flexShrink: 0,\n  },\n  stepContent: {\n    flex: 1, fontSize: 13, lineHeight: 1.5,\n  },\n  stepTitle: {\n    fontWeight: 600, marginBottom: 4,\n  },\n  stepDesc: {\n    color: theme.muted, fontSize: 12, marginBottom: 8,\n  },\n  vectorDisplay: {\n    padding: '6px 10px', background: theme.card,\n    borderRadius: 6, fontFamily: 'monospace', fontSize: 12,\n    display: 'inline-block',\n  },\n  keysRow: {\n    display: 'flex', gap: 8,\n  },\n  keyChip: {\n    padding: '6px 10px', background: theme.card, borderRadius: 6,\n    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2,\n    fontSize: 12, border: '1px solid', transition: 'border-color 0.2s',\n  },\n  valuesRow: {\n    display: 'flex', gap: 8, marginBottom: 10,\n  },\n  valueChip: {\n    padding: '6px 10px', background: theme.card, borderRadius: 6,\n    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2,\n    fontSize: 12, border: '1px solid', transition: 'all 0.2s',\n  },\n  flowSection: {\n    padding: 14, background: theme.surface, borderRadius: 12,\n  },\n  flowHeader: {\n    display: 'flex', alignItems: 'center', gap: 10, marginBottom: 10,\n  },\n  flowSvg: { width: '100%', height: 50 },\n  weightsRow: {\n    display: 'flex', justifyContent: 'space-around', marginTop: 10,\n  },\n  weightCol: {\n    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 6,\n  },\n  weightBar: {\n    width: 32, borderRadius: 6, transition: 'height 0.3s ease',\n  },\n  outputBox: {\n    padding: '10px 14px', background: theme.card,\n    borderRadius: 8, fontSize: 13, textAlign: 'center',\n    border: `1px solid ${theme.output}30`,\n  },\n  matrixSection: {\n    padding: 14, background: theme.surface, borderRadius: 12,\n  },\n  matrixTitle: {\n    fontSize: 11, fontWeight: 600, color: theme.muted, marginBottom: 10,\n    textAlign: 'center', textTransform: 'uppercase', letterSpacing: 1,\n  },\n  matrixGrid: {\n    display: 'grid', gridTemplateColumns: '32px repeat(3, 1fr)', gap: 5,\n    alignItems: 'center',\n  },\n  cell: {\n    height: 36, display: 'flex', alignItems: 'center', justifyContent: 'center',\n    borderRadius: 6, fontSize: 11, transition: 'all 0.2s',\n  },\n  matrixCaption: {\n    fontSize: 10, color: theme.dim, textAlign: 'center', marginTop: 8, fontStyle: 'italic',\n  },\n  analogyBox: {\n    padding: 14, background: theme.surface, borderRadius: 12,\n  },\n  analogyTitle: {\n    fontSize: 12, fontWeight: 600, marginBottom: 10,\n  },\n  analogyItem: {\n    fontSize: 11, color: theme.muted, marginBottom: 4,\n    paddingLeft: 8,\n  },\n  analogyDesc: {\n    fontSize: 10, color: theme.dim, marginTop: 8, fontStyle: 'italic',\n    paddingTop: 8, borderTop: `1px solid ${theme.border}`,\n  },\n  formulaBox: {\n    padding: 14, background: theme.surface, borderRadius: 12,\n    fontFamily: 'monospace', fontSize: 13, textAlign: 'center',\n  },\n};\n",
  "settings": {
    "editorHeight": 600,
    "showPreview": true,
    "theme": "auto",
    "showConsole": false,
    "editorWidthPercentage": 35,
    "showEditor": false
  },
  "dependencies": {}
}