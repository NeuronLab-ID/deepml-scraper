{
  "description": "SW1wbGVtZW50IHRoZSBmb3J3YXJkIHBhc3Mgb2YgYSAzRCBjb252b2x1dGlvbmFsIGxheWVyLiBBIDNEIGNvbnZvbHV0aW9uIHNsaWRlcyBhIDNEIGtlcm5lbCBvdmVyIGEgM0QgaW5wdXQgdm9sdW1lIChsaWtlIHZpZGVvIGZyYW1lcyBvciBtZWRpY2FsIHNjYW5zKSwgY29tcHV0aW5nIGRvdCBwcm9kdWN0cyBhdCBlYWNoIHBvc2l0aW9uLiBHaXZlbiBhbiBpbnB1dCB2b2x1bWUsIGtlcm5lbCwgc3RyaWRlLCBhbmQgcGFkZGluZywgY29tcHV0ZSB0aGUgb3V0cHV0IGZlYXR1cmUgbWFwLiBUaGlzIGlzIHRoZSBjb3JlIG9wZXJhdGlvbiBpbiAzRCBDTk5zIHVzZWQgZm9yIHZpZGVvIGFuYWx5c2lzIGFuZCBtZWRpY2FsIGltYWdpbmcu",
  "id": "230",
  "test_cases": [
    {
      "test": "input_vol = np.array([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]]); kernel = np.array([[[[1, 0], [0, 0]], [[0, 0], [0, 0]]]]); result = conv3d_forward_pass(input_vol, kernel); print(result.tolist())",
      "expected_output": "[[[[1.0]]]]"
    },
    {
      "test": "input_vol = np.ones((1, 3, 3, 3)); kernel = np.ones((1, 2, 2, 2)); result = conv3d_forward_pass(input_vol, kernel); print(result.tolist())",
      "expected_output": "[[[[8.0, 8.0], [8.0, 8.0]], [[8.0, 8.0], [8.0, 8.0]]]]"
    }
  ],
  "difficulty": "hard",
  "pytorch_difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "input=(1,2,2,2) values [[[1,2],[3,4]],[[5,6],[7,8]]], kernel=(1,2,2,2) with [1,0,0,0,0,0,0,0]",
    "output": "[[[[1.0]]]]",
    "reasoning": "Kernel extracts top-left-front value. Dot product: 1*1+2*0+3*0+4*0+5*0+6*0+7*0+8*0=1. Output: single value 1.0 at position (0,0,0)."
  },
  "category": "Deep Learning",
  "starter_code": "import numpy as np\n\ndef conv3d_forward_pass(\n    input_volume: np.ndarray,\n    kernel: np.ndarray,\n    stride: tuple[int, int, int] = (1, 1, 1),\n    padding: tuple[int, int, int] = (0, 0, 0)\n) -> np.ndarray:\n\t\"\"\"\n\tPerform 3D convolution forward pass.\n\t\n\tSlide a 3D kernel over input volume, computing dot products.\n\t\n\tArgs:\n\t\tinput_volume: Shape (C, D, H, W)\n\t\t  C = channels, D = depth/time, H = height, W = width\n\t\tkernel: Shape (C, kD, kH, kW)\n\t\t  Must match input channels\n\t\tstride: (stride_d, stride_h, stride_w)\n\t\t  Step size in each dimension\n\t\tpadding: (pad_d, pad_h, pad_w)\n\t\t  Zero-padding in each dimension\n\t\n\tReturns:\n\t\tOutput volume: Shape (1, D_out, H_out, W_out)\n\t\t  Single output channel\n\t\t\n\tProcess:\n\t\t1. Apply padding to input\n\t\t2. Calculate output dimensions\n\t\t3. For each output position:\n\t\t   - Extract 3D patch from input\n\t\t   - Compute element-wise product with kernel\n\t\t   - Sum all products -> single output value\n\t\"\"\"\n\t# Your code here\n\tpass",
  "createdAt": "December 10, 2025 at 7:37:21 PM UTC-0500",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCmltcG9ydCB0b3JjaC5ubiBhcyBubgoKZGVmIGNvbnYzZF9mb3J3YXJkX3Bhc3NfcHl0b3JjaCgKICAgIGlucHV0X3ZvbHVtZTogdG9yY2guVGVuc29yLAogICAga2VybmVsX3dlaWdodDogdG9yY2guVGVuc29yLAogICAgc3RyaWRlOiB0dXBsZVtpbnQsIGludCwgaW50XSA9ICgxLCAxLCAxKSwKICAgIHBhZGRpbmc6IHR1cGxlW2ludCwgaW50LCBpbnRdID0gKDAsIDAsIDApCikgLT4gdG9yY2guVGVuc29yOgoJIiIiCglQZXJmb3JtIDNEIGNvbnZvbHV0aW9uIGZvcndhcmQgcGFzcyB1c2luZyBQeVRvcmNoLgoJCglVc2UgUHlUb3JjaCdzIG5uLkNvbnYzZCBsYXllciB0byBwZXJmb3JtIDNEIGNvbnZvbHV0aW9uLgoJTm90ZTogUHlUb3JjaCBleHBlY3RzIGlucHV0IHNoYXBlIChOLCBDLCBELCBILCBXKSB3aGVyZSBOIGlzIGJhdGNoIHNpemUuCgkKCUFyZ3M6CgkJaW5wdXRfdm9sdW1lOiBTaGFwZSAoQywgRCwgSCwgVykKCQlrZXJuZWxfd2VpZ2h0OiBTaGFwZSAoMSwgQywga0QsIGtILCBrVykgCgkJICBGaXJzdCBkaW0gaXMgb3V0cHV0IGNoYW5uZWxzICgxIGZvciBzaW1wbGlmaWVkIHZlcnNpb24pCgkJc3RyaWRlOiAoc3RyaWRlX2QsIHN0cmlkZV9oLCBzdHJpZGVfdykKCQlwYWRkaW5nOiAocGFkX2QsIHBhZF9oLCBwYWRfdykKCQoJUmV0dXJuczoKCQlPdXRwdXQgdGVuc29yOiBTaGFwZSAoMSwgRF9vdXQsIEhfb3V0LCBXX291dCkKCQkKCUhpbnRzOgoJCS0gQWRkIGJhdGNoIGRpbWVuc2lvbiB0byBpbnB1dDogaW5wdXQudW5zcXVlZXplKDApCgkJLSBDcmVhdGUgQ29udjNkIGxheWVyIHdpdGgga2VybmVsIHNpemUgZnJvbSBrZXJuZWxfd2VpZ2h0CgkJLSBTZXQgY29udi53ZWlnaHQgcGFyYW1ldGVyIHRvIGtlcm5lbF93ZWlnaHQKCQktIFNldCBjb252LmJpYXMgdG8gTm9uZSBvciB6ZXJvcwoJCS0gQXBwbHkgY29udm9sdXRpb24gYW5kIHJlbW92ZSBiYXRjaCBkaW1lbnNpb24KCSIiIgoJIyBZb3VyIGNvZGUgaGVyZQoJcGFzcw==",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "input_vol = torch.tensor([[[[1., 2.], [3., 4.]], [[5., 6.], [7., 8.]]]]); kernel = torch.tensor([[[[1., 0.], [0., 0.]], [[0., 0.], [0., 0.]]]]); result = conv3d_forward_pass_pytorch(input_vol, kernel); print(result.tolist())",
      "expected_output": "[[[1.0]]]"
    },
    {
      "test": "input_vol = torch.ones(1, 3, 3, 3); kernel = torch.ones(1, 1, 2, 2, 2); result = conv3d_forward_pass_pytorch(input_vol, kernel); print(result.tolist())",
      "expected_output": "[[[8.0, 8.0], [8.0, 8.0]], [[8.0, 8.0], [8.0, 8.0]]]"
    },
    {
      "test": "input_vol = torch.ones(1, 2, 2, 2); kernel = torch.ones(1, 1, 2, 2, 2); result = conv3d_forward_pass_pytorch(input_vol, kernel, padding=(1,1,1)); print(result.shape)",
      "expected_output": "torch.Size([1, 3, 3, 3])"
    },
    {
      "test": "torch.manual_seed(42); input_vol = torch.rand(2, 3, 3, 3); kernel = torch.rand(1, 2, 2, 2, 2); result = conv3d_forward_pass_pytorch(input_vol, kernel); print(result.shape)",
      "expected_output": "torch.Size([1, 2, 2, 2])"
    },
    {
      "test": "input_vol = torch.arange(64, dtype=torch.float32).reshape(1, 4, 4, 4); kernel = torch.ones(1, 1, 2, 2, 2); result = conv3d_forward_pass_pytorch(input_vol, kernel, stride=(2,2,2)); print(result.tolist())",
      "expected_output": "[[[84.0, 100.0], [148.0, 164.0]], [[340.0, 356.0], [404.0, 420.0]]]"
    }
  ],
  "title": "3D CNN Forward Pass Implementation",
  "learn_section": "IyMjIDNEIENvbnZvbHV0aW9uYWwgRm9yd2FyZCBQYXNzCgpBIDNEIGNvbnZvbHV0aW9uIHNsaWRlcyBhIDNEIGtlcm5lbCBvdmVyIGEgM0QgaW5wdXQgdm9sdW1lLCBjb21wdXRpbmcgZG90IHByb2R1Y3RzIGF0IGVhY2ggcG9zaXRpb24uIFRoaXMgb3BlcmF0aW9uIGlzIHRoZSBjb3JlIG9mIDNEIENOTnMgdXNlZCBpbiB2aWRlbyBhbmFseXNpcyBhbmQgbWVkaWNhbCBpbWFnaW5nLgoKIyMjIyBXaGF0IEhhcHBlbnMgaW4gM0QgQ29udm9sdXRpb24/CgoqKlRoZSBQcm9jZXNzKio6CjEuICoqU2xpZGUqKjogTW92ZSBhIDNEIGtlcm5lbCB0aHJvdWdoIHRoZSBpbnB1dCB2b2x1bWUKMi4gKipFeHRyYWN0Kio6IEdldCBhIDNEIHBhdGNoIGF0IGN1cnJlbnQgcG9zaXRpb24KMy4gKipNdWx0aXBseSoqOiBFbGVtZW50LXdpc2UgbXVsdGlwbGljYXRpb24gb2YgcGF0Y2ggYW5kIGtlcm5lbAo0LiAqKlN1bSoqOiBBZGQgYWxsIHByb2R1Y3RzIOKGkiBzaW5nbGUgb3V0cHV0IHZhbHVlCjUuICoqUmVwZWF0Kio6IE1vdmUgdG8gbmV4dCBwb3NpdGlvbiBiYXNlZCBvbiBzdHJpZGUKCioqS2V5IGluc2lnaHQqKjogRWFjaCBvdXRwdXQgdmFsdWUgcmVwcmVzZW50cyBob3cgd2VsbCB0aGUga2VybmVsIG1hdGNoZXMgdGhlIHBhdGNoIGF0IHRoYXQgbG9jYXRpb24uCgojIyMjIElucHV0IGFuZCBLZXJuZWwgU2hhcGVzCgoqKklucHV0Kio6IChDLCBELCBILCBXKQotIEMgPSBDaGFubmVscyAoZS5nLiwgMyBmb3IgUkdCIHZpZGVvKQotIEQgPSBEZXB0aC9UaW1lIChudW1iZXIgb2YgZnJhbWVzIG9yIHNsaWNlcykKLSBIID0gSGVpZ2h0IChzcGF0aWFsIGRpbWVuc2lvbikKLSBXID0gV2lkdGggKHNwYXRpYWwgZGltZW5zaW9uKQoKKipLZXJuZWwqKjogKEMsIGtELCBrSCwga1cpCi0gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIGlucHV0Ci0gS2VybmVsIHNsaWRlcyBvdmVyIEQsIEgsIFcgZGltZW5zaW9ucwotIFByb2Nlc3NlcyBhbGwgY2hhbm5lbHMgc2ltdWx0YW5lb3VzbHkKCioqT3V0cHV0Kio6ICgxLCBEX291dCwgSF9vdXQsIFdfb3V0KQotIFNpbmdsZSBvdXRwdXQgY2hhbm5lbCAoc2ltcGxpZmllZCkKLSBEaW1lbnNpb25zIGRlcGVuZCBvbiBzdHJpZGUgYW5kIHBhZGRpbmcKCiMjIyMgU2ltcGxlIEV4YW1wbGUKCioqSW5wdXQqKjogKDEsIDIsIDIsIDIpIC0gU2luZ2xlIGNoYW5uZWwsIDLDlzLDlzIgY3ViZQoKSW5wdXQgdmFsdWVzOgokJApcYmVnaW57YXJyYXl9e2NjfQpcdGV4dHtEZXB0aCAwOn0gJiBcdGV4dHtEZXB0aCAxOn0gXFwKXGJlZ2lue2JtYXRyaXh9MSAmIDIgXFwgMyAmIDRcZW5ke2JtYXRyaXh9ICYKXGJlZ2lue2JtYXRyaXh9NSAmIDYgXFwgNyAmIDhcZW5ke2JtYXRyaXh9ClxlbmR7YXJyYXl9CiQkCgoqKktlcm5lbCoqOiAoMSwgMiwgMiwgMikgLSBQaWNrcyB0b3AtbGVmdC1mcm9udCBjb3JuZXIKCktlcm5lbCB2YWx1ZXM6CiQkClxiZWdpbnthcnJheX17Y2N9Clx0ZXh0e0RlcHRoIDA6fSAmIFx0ZXh0e0RlcHRoIDE6fSBcXApcYmVnaW57Ym1hdHJpeH0xICYgMCBcXCAwICYgMFxlbmR7Ym1hdHJpeH0gJgpcYmVnaW57Ym1hdHJpeH0wICYgMCBcXCAwICYgMFxlbmR7Ym1hdHJpeH0KXGVuZHthcnJheX0KJCQKCioqQ29tcHV0YXRpb24qKjoKCk9ubHkgb25lIHBvc2l0aW9uIChrZXJuZWwgY292ZXJzIGVudGlyZSBpbnB1dCk6CgpFbGVtZW50LXdpc2UgbXVsdGlwbGljYXRpb246CiQkCjEgXHRpbWVzIDEgPSAxLCBccXVhZCAyIFx0aW1lcyAwID0gMCwgXHF1YWQgMyBcdGltZXMgMCA9IDAsIFxxdWFkIFxsZG90cwokJAoKU3VtIGFsbCBwcm9kdWN0czoKJCQKMSArIDAgKyAwICsgMCArIDAgKyAwICsgMCArIDAgPSAxCiQkCgoqKk91dHB1dCoqOiBTaW5nbGUgdmFsdWUgPSAxLjAKCiMjIyMgRXhhbXBsZSB3aXRoIE11bHRpcGxlIFBvc2l0aW9ucwoKKipJbnB1dCoqOiAoMSwgMywgMywgMykgLSBBbGwgb25lcywgM8OXM8OXMyBjdWJlCgoqKktlcm5lbCoqOiAoMSwgMiwgMiwgMikgLSBBbGwgb25lcwoKKipPdXRwdXQgZGltZW5zaW9ucyoqOgotIERlcHRoOiAoMyAtIDIpLzEgKyAxID0gMgotIEhlaWdodDogKDMgLSAyKS8xICsgMSA9IDIgIAotIFdpZHRoOiAoMyAtIDIpLzEgKyAxID0gMgotIE91dHB1dDogKDEsIDIsIDIsIDIpCgoqKkF0IHBvc2l0aW9uICgwLDAsMCkqKiAtIHRvcC1sZWZ0LWZyb250IGNvcm5lcjoKCkV4dHJhY3QgMsOXMsOXMiBwYXRjaCAoOCB2YWx1ZXMsIGFsbCBvbmVzKQoKS2VybmVsIGhhcyA4IHZhbHVlcywgYWxsIG9uZXMKCkRvdCBwcm9kdWN0OiAkMSBcdGltZXMgMSArIDEgXHRpbWVzIDEgKyBcbGRvdHMkICg4IHRpbWVzKSA9IDgKCioqQXQgcG9zaXRpb24gKDAsMCwxKSoqIC0gc2hpZnRlZCByaWdodCBieSAxOgoKRXh0cmFjdCBuZXh0IDLDlzLDlzIgcGF0Y2ggKHN0aWxsIGFsbCBvbmVzKQoKRG90IHByb2R1Y3Q6IDgKCioqUmVzdWx0Kio6IEFsbCA4IG91dHB1dCBwb3NpdGlvbnMgPSA4LjAKCiMjIyMgRWZmZWN0IG9mIFN0cmlkZQoKKipTdHJpZGUqKiBjb250cm9scyBob3cgZmFyIHRoZSBrZXJuZWwgbW92ZXMgYmV0d2VlbiBwb3NpdGlvbnMuCgoqKlN0cmlkZSA9ICgxLDEsMSkqKjogS2VybmVsIG1vdmVzIDEgc3RlcCBhdCBhIHRpbWUgKGRlbnNlIHNhbXBsaW5nKQoKKipTdHJpZGUgPSAoMiwyLDIpKio6IEtlcm5lbCBtb3ZlcyAyIHN0ZXBzIChza2lwcyBwb3NpdGlvbnMsIGRvd25zYW1wbGVzKQoKKipFeGFtcGxlIHdpdGggc3RyaWRlKio6CgpJbnB1dDogKDEsIDQsIDQsIDQpIHdpdGggc2VxdWVudGlhbCB2YWx1ZXMgMC02MwoKS2VybmVsOiAoMSwgMiwgMiwgMikgYWxsIG9uZXMKClN0cmlkZTogKDIsIDIsIDIpCgoqKk91dHB1dCoqOiAoMSwgMiwgMiwgMikKLSBPbmx5IDggcG9zaXRpb25zIGV2YWx1YXRlZCAoc2tpcHBpbmcgZXZlcnkgb3RoZXIgcG9zaXRpb24pCi0gRWFjaCB2YWx1ZSBpcyBzdW0gb2YgOCBpbnB1dCB2YWx1ZXMKCioqUG9zaXRpb24gKDAsMCwwKSoqOiBFeHRyYWN0cyBjdWJlIFswOjIsIDA6MiwgMDoyXQotIFZhbHVlczogMCwxLDQsNSwxNiwxNywyMCwyMQotIFN1bTogODQKCioqUG9zaXRpb24gKDAsMCwxKSoqOiBFeHRyYWN0cyBjdWJlIFswOjIsIDA6MiwgMjo0XQotIFZhbHVlczogMiwzLDYsNywxOCwxOSwyMiwyMwotIFN1bTogMTAwCgpTdHJpZGU9MiBjYXVzZXMgZG93bnNhbXBsaW5nIGJ5IGZhY3RvciBvZiAyIGluIGVhY2ggZGltZW5zaW9uLgoKIyMjIyBFZmZlY3Qgb2YgUGFkZGluZwoKKipQYWRkaW5nKiogYWRkcyB6ZXJvcyBhcm91bmQgdGhlIGlucHV0IGJlZm9yZSBjb252b2x1dGlvbi4KCioqV2l0aG91dCBwYWRkaW5nKio6IE91dHB1dCBzaHJpbmtzIChib3JkZXJzIG5vdCBmdWxseSBjb3ZlcmVkKQoKKipXaXRoIHBhZGRpbmcqKjogQ2FuIG1haW50YWluIG9yIGluY3JlYXNlIG91dHB1dCBzaXplCgoqKkV4YW1wbGUqKjoKCklucHV0OiAoMSwgMiwgMiwgMikgYWxsIG9uZXMKCktlcm5lbDogKDEsIDIsIDIsIDIpIGFsbCBvbmVzCgpQYWRkaW5nOiAoMSwgMSwgMSkgLSBhZGRzIG9uZSBsYXllciBvZiB6ZXJvcyBvbiBhbGwgc2lkZXMKCioqUGFkZGVkIGlucHV0Kio6ICgxLCA0LCA0LCA0KSB3aXRoIGNlbnRlciAyw5cyw5cyID0gb25lcywgcmVzdCA9IHplcm9zCgoqKk91dHB1dCoqOiAoMSwgMywgMywgMykKCioqQ29ybmVyIHBvc2l0aW9ucyoqOiBPbmx5IHBhcnRpYWwgb3ZlcmxhcCB3aXRoIG5vbi16ZXJvIHZhbHVlcwotIFBvc2l0aW9uICgwLDAsMCk6IE9ubHkgMSBpbnB1dCB2YWx1ZSBpcyBub24temVybyDihpIgb3V0cHV0ID0gMQoKKipDZW50ZXIgcG9zaXRpb24qKjogRnVsbCBvdmVybGFwIHdpdGggb25lcwotIFBvc2l0aW9uICgxLDEsMSk6IEFsbCA4IHZhbHVlcyBhcmUgb25lcyDihpIgb3V0cHV0ID0gOAoKUGFkZGluZyBhZmZlY3RzIGJvcmRlciB2YWx1ZXMgZGlmZmVyZW50bHkgdGhhbiBjZW50ZXIgdmFsdWVzLgoKIyMjIyBNdWx0aS1DaGFubmVsIFByb2Nlc3NpbmcKCldoZW4gaW5wdXQgaGFzIG11bHRpcGxlIGNoYW5uZWxzLCB0aGUga2VybmVsIG11c3QgbWF0Y2g6CgoqKklucHV0Kio6ICgyLCAzLCAzLCAzKSAtIDIgY2hhbm5lbHMKCioqS2VybmVsKio6ICgyLCAyLCAyLCAyKSAtIDIgY2hhbm5lbHMKCioqUHJvY2VzcyoqOiAKLSBFeHRyYWN0IDLDlzLDlzIgcGF0Y2ggZnJvbSBCT1RIIGNoYW5uZWxzCi0gTXVsdGlwbHkgYnkgY29ycmVzcG9uZGluZyBrZXJuZWwgY2hhbm5lbHMKLSBTdW0gQUxMIHByb2R1Y3RzIChhY3Jvc3MgY2hhbm5lbHMgYW5kIHBvc2l0aW9ucykKLSBSZXN1bHQ6IFNpbmdsZSB2YWx1ZSBwZXIgb3V0cHV0IHBvc2l0aW9uCgoqKk1hdGhlbWF0aWNhbCBmb3JtdWxhdGlvbioqOgokJApcdGV4dHtvdXRwdXR9W2QsaCx3XSA9IFxzdW1fe2M9MX1ee0N9IFxzdW1fe2ksaixrfSBcdGV4dHtpbnB1dH1bYywgZCtpLCBoK2osIHcra10gXHRpbWVzIFx0ZXh0e2tlcm5lbH1bYywgaSwgaiwga10KJCQKCiMjIyMgQWxnb3JpdGhtIFN0ZXBzCgoqKlN0ZXAgMSoqOiBEZXRlcm1pbmUgb3V0cHV0IGRpbWVuc2lvbnMKJCQKRF97b3V0fSA9IFxsZmxvb3IgKEQgKyAycF9kIC0ga19kKSAvIHNfZCBccmZsb29yICsgMQokJAokJApIX3tvdXR9ID0gXGxmbG9vciAoSCArIDJwX2ggLSBrX2gpIC8gc19oIFxyZmxvb3IgKyAxCiQkCiQkCldfe291dH0gPSBcbGZsb29yIChXICsgMnBfdyAtIGtfdykgLyBzX3cgXHJmbG9vciArIDEKJCQKCioqU3RlcCAyKio6IEFwcGx5IHBhZGRpbmcgaWYgc3BlY2lmaWVkCgpBZGQgemVyb3MgYXJvdW5kIGlucHV0IHZvbHVtZQoKKipTdGVwIDMqKjogRm9yIGVhY2ggb3V0cHV0IHBvc2l0aW9uIChkLCBoLCB3KToKCkNhbGN1bGF0ZSBzdGFydGluZyBpbmRpY2VzOgotIGRfc3RhcnQgPSBkIMOXIHN0cmlkZV9kCi0gaF9zdGFydCA9IGggw5cgc3RyaWRlX2gKLSB3X3N0YXJ0ID0gdyDDlyBzdHJpZGVfdwoKRXh0cmFjdCBwYXRjaDoKLSBwYXRjaCA9IGlucHV0WzosIGRfc3RhcnQ6ZF9zdGFydCtrRCwgaF9zdGFydDpoX3N0YXJ0K2tILCB3X3N0YXJ0Ondfc3RhcnQra1ddCgpDb21wdXRlIGRvdCBwcm9kdWN0OgotIG91dHB1dFtkLGgsd10gPSBzdW0ocGF0Y2ggKiBrZXJuZWwpCgoqKlN0ZXAgNCoqOiBSZXR1cm4gb3V0cHV0IHZvbHVtZQoKIyMjIyBBcHBsaWNhdGlvbnMgaW4gVmlkZW8gQW5hbHlzaXMKCioqQWN0aW9uIFJlY29nbml0aW9uKio6CgpJbnB1dDogKDMsIDE2LCAxMTIsIDExMikgLSAxNi1mcmFtZSBSR0IgdmlkZW8KCktlcm5lbDogKDMsIDMsIDcsIDcpIC0gQ2FwdHVyZXMgMyBmcmFtZXMgd2l0aCA3w5c3IHNwYXRpYWwgcGF0dGVybgoKVGhlIDNEIGtlcm5lbCBkZXRlY3RzIHRlbXBvcmFsIG1vdGlvbiBwYXR0ZXJuczoKLSBXYWxraW5nOiBsZWdzIGFsdGVybmF0aW5nIGFjcm9zcyBmcmFtZXMKLSBKdW1waW5nOiB1cHdhcmQgbW90aW9uIGFjcm9zcyBmcmFtZXMKLSBXYXZpbmc6IGhhbmQgbW90aW9uIGFjcm9zcyBmcmFtZXMKCioqTWVkaWNhbCBDVCBTY2FucyoqOgoKSW5wdXQ6ICgxLCA2NCwgMjU2LCAyNTYpIC0gNjQgQ1Qgc2xpY2VzCgpLZXJuZWw6ICgxLCA1LCA1LCA1KSAtIERldGVjdHMgM0QgdHVtb3Igc2hhcGUKClRoZSAzRCBrZXJuZWwgcmVjb2duaXplcyB2b2x1bWV0cmljIHBhdHRlcm5zOgotIFNwaGVyaWNhbCB0dW1vcnMgYWNyb3NzIG11bHRpcGxlIHNsaWNlcwotIElycmVndWxhciB0aXNzdWUgYm91bmRhcmllcwotIDNEIGFuYXRvbWljYWwgc3RydWN0dXJlcwoKIyMjIyBDb21wdXRhdGlvbmFsIENvbXBsZXhpdHkKCioqT3BlcmF0aW9ucyBwZXIgb3V0cHV0IHZhbHVlKio6CiQkCkMgXHRpbWVzIGtfRCBcdGltZXMga19IIFx0aW1lcyBrX1cKJCQKCioqVG90YWwgb3BlcmF0aW9ucyoqOgokJApEX3tvdXR9IFx0aW1lcyBIX3tvdXR9IFx0aW1lcyBXX3tvdXR9IFx0aW1lcyBDIFx0aW1lcyBrX0QgXHRpbWVzIGtfSCBcdGltZXMga19XCiQkCgoqKkV4YW1wbGUqKjoKLSBPdXRwdXQ6IDE0IMOXIDYyIMOXIDYyID0gNTMsODE2IHBvc2l0aW9ucwotIFBlciBwb3NpdGlvbjogMyDDlyAzIMOXIDMgw5cgMyA9IDgxIG9wZXJhdGlvbnMKLSBUb3RhbDogNCwzNTksMDk2IG11bHRpcGx5LWFkZHMKCjNEIGNvbnZvbHV0aW9ucyBhcmUgY29tcHV0YXRpb25hbGx5IGludGVuc2l2ZSEKCiMjIyMgTWVtb3J5IEFjY2VzcyBQYXR0ZXJuCgoqKk5haXZlIGltcGxlbWVudGF0aW9uKiogcmUtZXh0cmFjdHMgb3ZlcmxhcHBpbmcgcGF0Y2hlcyAoaW5lZmZpY2llbnQpCgoqKk9wdGltaXplZCBpbXBsZW1lbnRhdGlvbioqIHVzZXM6Ci0gSW0yY29sIHRyYW5zZm9ybWF0aW9uIChyZXNoYXBlIHRvIG1hdHJpeCBtdWx0aXBsaWNhdGlvbikKLSBHUFUgcGFyYWxsZWwgcHJvY2Vzc2luZyAoY29tcHV0ZSBhbGwgcG9zaXRpb25zIHNpbXVsdGFuZW91c2x5KQotIFRpbGVkIGNvbXB1dGF0aW9uIChyZXVzZSBsb2FkZWQgZGF0YSkKCk1vZGVybiBkZWVwIGxlYXJuaW5nIGZyYW1ld29ya3MgKFB5VG9yY2gsIFRlbnNvckZsb3cpIHVzZSBoaWdobHkgb3B0aW1pemVkIGltcGxlbWVudGF0aW9ucy4KCiMjIyMgRGlmZmVyZW5jZXMgZnJvbSAyRCBDb252b2x1dGlvbgoKfCBBc3BlY3QgfCAyRCBDb252IHwgM0QgQ29udiB8CnwtLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tfAp8IElucHV0IHwgKEMsIEgsIFcpIHwgKEMsIEQsIEgsIFcpIHwKfCBLZXJuZWwgfCAoQywga0gsIGtXKSB8IChDLCBrRCwga0gsIGtXKSB8CnwgU2xpZGVzIG92ZXIgfCBILCBXIHwgRCwgSCwgVyB8CnwgQ2FwdHVyZXMgfCBTcGF0aWFsIHwgVGVtcG9yYWwvVm9sdW1ldHJpYyB8CnwgVXNlIGNhc2UgfCBJbWFnZXMgfCBWaWRlb3MsIG1lZGljYWwgc2NhbnMgfAoKKipLZXkgZGlzdGluY3Rpb24qKjogM0QgY29udiBwcm9jZXNzZXMgdGltZS9kZXB0aCBkaW1lbnNpb24sIG5vdCBqdXN0IHNwYXRpYWwuCgojIyMjIFByYWN0aWNhbCBDb25zaWRlcmF0aW9ucwoKKipNZW1vcnkqKjogM0QgY29udm9sdXRpb25zIHVzZSBzaWduaWZpY2FudGx5IG1vcmUgbWVtb3J5Ci0gTGFyZ2VyIGlucHV0IHZvbHVtZXMKLSBMYXJnZXIgaW50ZXJtZWRpYXRlIGFjdGl2YXRpb25zCi0gTW9yZSBwYXJhbWV0ZXJzIGluIGtlcm5lbAoKKipTcGVlZCoqOiBTbG93ZXIgdGhhbiAyRCBjb252b2x1dGlvbnMKLSBNb3JlIG9wZXJhdGlvbnMgcGVyIG91dHB1dAotIE1vcmUgbWVtb3J5IGJhbmR3aWR0aCByZXF1aXJlZAotIEhhcmRlciB0byBwYXJhbGxlbGl6ZSBlZmZpY2llbnRseQoKKipCYXRjaCBzaXplKio6IFVzZSBzbWFsbGVyIGJhdGNoZXMgKG9mdGVuIDEtNCkgZHVlIHRvIG1lbW9yeSBjb25zdHJhaW50cwoKKipBcmNoaXRlY3R1cmUgZGVzaWduKio6IAotIFN0YXJ0IHdpdGggZG93bnNhbXBsaW5nIGxheWVycyAoc3RyaWRlID4gMSkKLSBVc2Ugc21hbGxlciBrZXJuZWwgc2l6ZXMgKDPDlzPDlzMgY29tbW9uKQotIENvbnNpZGVyICgyKzEpRCBmYWN0b3JpemF0aW9uIChzZXBhcmF0ZSBzcGF0aWFsIGFuZCB0ZW1wb3JhbCkKCiMjIyMgU3VtbWFyeQoKKiozRCBDb252b2x1dGlvbiBQcm9jZXNzKio6CjEuIFNsaWRlIDNEIGtlcm5lbCBvdmVyIDNEIGlucHV0CjIuIEV4dHJhY3QgcGF0Y2ggYXQgZWFjaCBwb3NpdGlvbgozLiBDb21wdXRlIGVsZW1lbnQtd2lzZSBwcm9kdWN0CjQuIFN1bSBhbGwgcHJvZHVjdHMKNS4gU3RvcmUgcmVzdWx0IGF0IG91dHB1dCBwb3NpdGlvbgoKKipPdXRwdXQgRm9ybXVsYSoqOiAKJCQKXHRleHR7b3V0fVtkLGgsd10gPSBcc3VtIFx0ZXh0e3BhdGNofSBcb2RvdCBcdGV4dHtrZXJuZWx9CiQkCgoqKkFwcGxpY2F0aW9ucyoqOiBWaWRlbyBhY3Rpb24gcmVjb2duaXRpb24sIG1lZGljYWwgaW1hZ2luZywgdm9sdW1ldHJpYyBkYXRhCgoqKkNoYWxsZW5nZSoqOiBIaWdoIGNvbXB1dGF0aW9uYWwgYW5kIG1lbW9yeSBjb3N0CgoqKktleSB0byBpbXBsZW1lbnRhdGlvbioqOiBDb3JyZWN0IGluZGV4aW5nIGFuZCBib3VuZGFyeSBoYW5kbGluZw==",
  "description_decoded": "Implement the forward pass of a 3D convolutional layer. A 3D convolution slides a 3D kernel over a 3D input volume (like video frames or medical scans), computing dot products at each position. Given an input volume, kernel, stride, and padding, compute the output feature map. This is the core operation in 3D CNNs used for video analysis and medical imaging.",
  "learn_section_decoded": "### 3D Convolutional Forward Pass\n\nA 3D convolution slides a 3D kernel over a 3D input volume, computing dot products at each position. This operation is the core of 3D CNNs used in video analysis and medical imaging.\n\n#### What Happens in 3D Convolution?\n\n**The Process**:\n1. **Slide**: Move a 3D kernel through the input volume\n2. **Extract**: Get a 3D patch at current position\n3. **Multiply**: Element-wise multiplication of patch and kernel\n4. **Sum**: Add all products → single output value\n5. **Repeat**: Move to next position based on stride\n\n**Key insight**: Each output value represents how well the kernel matches the patch at that location.\n\n#### Input and Kernel Shapes\n\n**Input**: (C, D, H, W)\n- C = Channels (e.g., 3 for RGB video)\n- D = Depth/Time (number of frames or slices)\n- H = Height (spatial dimension)\n- W = Width (spatial dimension)\n\n**Kernel**: (C, kD, kH, kW)\n- Must have same number of channels as input\n- Kernel slides over D, H, W dimensions\n- Processes all channels simultaneously\n\n**Output**: (1, D_out, H_out, W_out)\n- Single output channel (simplified)\n- Dimensions depend on stride and padding\n\n#### Simple Example\n\n**Input**: (1, 2, 2, 2) - Single channel, 2×2×2 cube\n\nInput values:\n$$\n\\begin{array}{cc}\n\\text{Depth 0:} & \\text{Depth 1:} \\\\\n\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\end{bmatrix} &\n\\begin{bmatrix}5 & 6 \\\\ 7 & 8\\end{bmatrix}\n\\end{array}\n$$\n\n**Kernel**: (1, 2, 2, 2) - Picks top-left-front corner\n\nKernel values:\n$$\n\\begin{array}{cc}\n\\text{Depth 0:} & \\text{Depth 1:} \\\\\n\\begin{bmatrix}1 & 0 \\\\ 0 & 0\\end{bmatrix} &\n\\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}\n\\end{array}\n$$\n\n**Computation**:\n\nOnly one position (kernel covers entire input):\n\nElement-wise multiplication:\n$$\n1 \\times 1 = 1, \\quad 2 \\times 0 = 0, \\quad 3 \\times 0 = 0, \\quad \\ldots\n$$\n\nSum all products:\n$$\n1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 1\n$$\n\n**Output**: Single value = 1.0\n\n#### Example with Multiple Positions\n\n**Input**: (1, 3, 3, 3) - All ones, 3×3×3 cube\n\n**Kernel**: (1, 2, 2, 2) - All ones\n\n**Output dimensions**:\n- Depth: (3 - 2)/1 + 1 = 2\n- Height: (3 - 2)/1 + 1 = 2  \n- Width: (3 - 2)/1 + 1 = 2\n- Output: (1, 2, 2, 2)\n\n**At position (0,0,0)** - top-left-front corner:\n\nExtract 2×2×2 patch (8 values, all ones)\n\nKernel has 8 values, all ones\n\nDot product: $1 \\times 1 + 1 \\times 1 + \\ldots$ (8 times) = 8\n\n**At position (0,0,1)** - shifted right by 1:\n\nExtract next 2×2×2 patch (still all ones)\n\nDot product: 8\n\n**Result**: All 8 output positions = 8.0\n\n#### Effect of Stride\n\n**Stride** controls how far the kernel moves between positions.\n\n**Stride = (1,1,1)**: Kernel moves 1 step at a time (dense sampling)\n\n**Stride = (2,2,2)**: Kernel moves 2 steps (skips positions, downsamples)\n\n**Example with stride**:\n\nInput: (1, 4, 4, 4) with sequential values 0-63\n\nKernel: (1, 2, 2, 2) all ones\n\nStride: (2, 2, 2)\n\n**Output**: (1, 2, 2, 2)\n- Only 8 positions evaluated (skipping every other position)\n- Each value is sum of 8 input values\n\n**Position (0,0,0)**: Extracts cube [0:2, 0:2, 0:2]\n- Values: 0,1,4,5,16,17,20,21\n- Sum: 84\n\n**Position (0,0,1)**: Extracts cube [0:2, 0:2, 2:4]\n- Values: 2,3,6,7,18,19,22,23\n- Sum: 100\n\nStride=2 causes downsampling by factor of 2 in each dimension.\n\n#### Effect of Padding\n\n**Padding** adds zeros around the input before convolution.\n\n**Without padding**: Output shrinks (borders not fully covered)\n\n**With padding**: Can maintain or increase output size\n\n**Example**:\n\nInput: (1, 2, 2, 2) all ones\n\nKernel: (1, 2, 2, 2) all ones\n\nPadding: (1, 1, 1) - adds one layer of zeros on all sides\n\n**Padded input**: (1, 4, 4, 4) with center 2×2×2 = ones, rest = zeros\n\n**Output**: (1, 3, 3, 3)\n\n**Corner positions**: Only partial overlap with non-zero values\n- Position (0,0,0): Only 1 input value is non-zero → output = 1\n\n**Center position**: Full overlap with ones\n- Position (1,1,1): All 8 values are ones → output = 8\n\nPadding affects border values differently than center values.\n\n#### Multi-Channel Processing\n\nWhen input has multiple channels, the kernel must match:\n\n**Input**: (2, 3, 3, 3) - 2 channels\n\n**Kernel**: (2, 2, 2, 2) - 2 channels\n\n**Process**: \n- Extract 2×2×2 patch from BOTH channels\n- Multiply by corresponding kernel channels\n- Sum ALL products (across channels and positions)\n- Result: Single value per output position\n\n**Mathematical formulation**:\n$$\n\\text{output}[d,h,w] = \\sum_{c=1}^{C} \\sum_{i,j,k} \\text{input}[c, d+i, h+j, w+k] \\times \\text{kernel}[c, i, j, k]\n$$\n\n#### Algorithm Steps\n\n**Step 1**: Determine output dimensions\n$$\nD_{out} = \\lfloor (D + 2p_d - k_d) / s_d \\rfloor + 1\n$$\n$$\nH_{out} = \\lfloor (H + 2p_h - k_h) / s_h \\rfloor + 1\n$$\n$$\nW_{out} = \\lfloor (W + 2p_w - k_w) / s_w \\rfloor + 1\n$$\n\n**Step 2**: Apply padding if specified\n\nAdd zeros around input volume\n\n**Step 3**: For each output position (d, h, w):\n\nCalculate starting indices:\n- d_start = d × stride_d\n- h_start = h × stride_h\n- w_start = w × stride_w\n\nExtract patch:\n- patch = input[:, d_start:d_start+kD, h_start:h_start+kH, w_start:w_start+kW]\n\nCompute dot product:\n- output[d,h,w] = sum(patch * kernel)\n\n**Step 4**: Return output volume\n\n#### Applications in Video Analysis\n\n**Action Recognition**:\n\nInput: (3, 16, 112, 112) - 16-frame RGB video\n\nKernel: (3, 3, 7, 7) - Captures 3 frames with 7×7 spatial pattern\n\nThe 3D kernel detects temporal motion patterns:\n- Walking: legs alternating across frames\n- Jumping: upward motion across frames\n- Waving: hand motion across frames\n\n**Medical CT Scans**:\n\nInput: (1, 64, 256, 256) - 64 CT slices\n\nKernel: (1, 5, 5, 5) - Detects 3D tumor shape\n\nThe 3D kernel recognizes volumetric patterns:\n- Spherical tumors across multiple slices\n- Irregular tissue boundaries\n- 3D anatomical structures\n\n#### Computational Complexity\n\n**Operations per output value**:\n$$\nC \\times k_D \\times k_H \\times k_W\n$$\n\n**Total operations**:\n$$\nD_{out} \\times H_{out} \\times W_{out} \\times C \\times k_D \\times k_H \\times k_W\n$$\n\n**Example**:\n- Output: 14 × 62 × 62 = 53,816 positions\n- Per position: 3 × 3 × 3 × 3 = 81 operations\n- Total: 4,359,096 multiply-adds\n\n3D convolutions are computationally intensive!\n\n#### Memory Access Pattern\n\n**Naive implementation** re-extracts overlapping patches (inefficient)\n\n**Optimized implementation** uses:\n- Im2col transformation (reshape to matrix multiplication)\n- GPU parallel processing (compute all positions simultaneously)\n- Tiled computation (reuse loaded data)\n\nModern deep learning frameworks (PyTorch, TensorFlow) use highly optimized implementations.\n\n#### Differences from 2D Convolution\n\n| Aspect | 2D Conv | 3D Conv |\n|--------|---------|---------|\n| Input | (C, H, W) | (C, D, H, W) |\n| Kernel | (C, kH, kW) | (C, kD, kH, kW) |\n| Slides over | H, W | D, H, W |\n| Captures | Spatial | Temporal/Volumetric |\n| Use case | Images | Videos, medical scans |\n\n**Key distinction**: 3D conv processes time/depth dimension, not just spatial.\n\n#### Practical Considerations\n\n**Memory**: 3D convolutions use significantly more memory\n- Larger input volumes\n- Larger intermediate activations\n- More parameters in kernel\n\n**Speed**: Slower than 2D convolutions\n- More operations per output\n- More memory bandwidth required\n- Harder to parallelize efficiently\n\n**Batch size**: Use smaller batches (often 1-4) due to memory constraints\n\n**Architecture design**: \n- Start with downsampling layers (stride > 1)\n- Use smaller kernel sizes (3×3×3 common)\n- Consider (2+1)D factorization (separate spatial and temporal)\n\n#### Summary\n\n**3D Convolution Process**:\n1. Slide 3D kernel over 3D input\n2. Extract patch at each position\n3. Compute element-wise product\n4. Sum all products\n5. Store result at output position\n\n**Output Formula**: \n$$\n\\text{out}[d,h,w] = \\sum \\text{patch} \\odot \\text{kernel}\n$$\n\n**Applications**: Video action recognition, medical imaging, volumetric data\n\n**Challenge**: High computational and memory cost\n\n**Key to implementation**: Correct indexing and boundary handling"
}