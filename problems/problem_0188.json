{
  "description": "IyMgUHJvYmxlbQoKV3JpdGUgYSBQeXRob24gZnVuY3Rpb24gYGNoZWNrcG9pbnRfZm9yd2FyZGAgdGhhdCB0YWtlcyBhIGxpc3Qgb2YgbnVtcHkgZnVuY3Rpb25zIChlYWNoIHJlcHJlc2VudGluZyBhIGxheWVyIG9yIG9wZXJhdGlvbikgYW5kIGFuIGlucHV0IG51bXB5IGFycmF5LCBhbmQgcmV0dXJucyB0aGUgZmluYWwgb3V0cHV0IGJ5IGFwcGx5aW5nIGVhY2ggZnVuY3Rpb24gaW4gc2VxdWVuY2UuIFRvIHNpbXVsYXRlIGdyYWRpZW50IGNoZWNrcG9pbnRpbmcsIHRoZSBmdW5jdGlvbiBzaG91bGQgbm90IHN0b3JlIGludGVybWVkaWF0ZSBhY3RpdmF0aW9uczsgaW5zdGVhZCwgaXQgc2hvdWxkIHJlY29tcHV0ZSB0aGVtIGFzIG5lZWRlZCAoZm9yIHRoaXMgcHJvYmxlbSwganVzdCBhcHBseSB0aGUgZnVuY3Rpb25zIGluIHNlcXVlbmNlIGFzIHVzdWFsKS4gT25seSB1c2Ugc3RhbmRhcmQgUHl0aG9uIGFuZCBudW1weS4gVGhlIHJldHVybmVkIGFycmF5IHNob3VsZCBiZSBvZiB0eXBlIGZsb2F0IGFuZCBoYXZlIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBvdXRwdXQgb2YgdGhlIGxhc3QgZnVuY3Rpb24u",
  "id": "188",
  "test_cases": [
    {
      "test": "import numpy as np\ndef f1(x): return x + 1\ndef f2(x): return x * 2\ndef f3(x): return x - 3\nfuncs = [f1, f2, f3]\ninput_arr = np.array([1.0, 2.0])\nprint(checkpoint_forward(funcs, input_arr))",
      "expected_output": "[1. 3.]"
    },
    {
      "test": "import numpy as np\ndef f1(x): return x * 0\ndef f2(x): return x + 10\nfuncs = [f1, f2]\ninput_arr = np.array([5.0, 7.0])\nprint(checkpoint_forward(funcs, input_arr))",
      "expected_output": "[10. 10.]"
    }
  ],
  "difficulty": "easy",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "import numpy as np\ndef f1(x): return x + 1\ndef f2(x): return x * 2\ndef f3(x): return x - 3\nfuncs = [f1, f2, f3]\ninput_arr = np.array([1.0, 2.0])\noutput = checkpoint_forward(funcs, input_arr)\nprint(output)",
    "output": "[-1.  1.]",
    "reasoning": "The input [1.0, 2.0] is passed through f1: [2.0, 3.0], then f2: [4.0, 6.0], then f3: [1.0, 3.0]. The final output is [1.0, 3.0]. (Correction: Actually, [1.0, 3.0] is correct, not [-1. 1.].)"
  },
  "category": "Machine Learning",
  "starter_code": "import numpy as np\n\n# Implement your function below.\ndef checkpoint_forward(funcs, input_arr):\n    \"\"\"\n    Applies a list of functions in sequence to the input array, simulating gradient checkpointing by not storing intermediates.\n\n    Args:\n        funcs (list of callables): List of functions to apply in sequence.\n        input_arr (np.ndarray): Input numpy array.\n\n    Returns:\n        np.ndarray: The output after applying all functions, same shape as output of last function.\n    \"\"\"\n    pass",
  "title": "Gradient Checkpointing",
  "createdAt": "October 16, 2025 at 9:27:03â€¯AM UTUTC-4",
  "contributor": [
    "https://github.com/komaksym"
  ],
  "learn_section": "IyAqKkdyYWRpZW50IENoZWNrcG9pbnRpbmcqKgoKIyMgKioxLiBEZWZpbml0aW9uKioKR3JhZGllbnQgY2hlY2twb2ludGluZyBpcyBhIHRlY2huaXF1ZSB1c2VkIGluIGRlZXAgbGVhcm5pbmcgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZSBkdXJpbmcgdHJhaW5pbmcgYnkgc2VsZWN0aXZlbHkgc3RvcmluZyBvbmx5IGEgc3Vic2V0IG9mIGludGVybWVkaWF0ZSBhY3RpdmF0aW9ucyAoY2hlY2twb2ludHMpIGFuZCByZWNvbXB1dGluZyB0aGUgb3RoZXJzIGFzIG5lZWRlZCBkdXJpbmcgdGhlIGJhY2t3YXJkIHBhc3MuIFRoaXMgYWxsb3dzIHRyYWluaW5nIG9mIGxhcmdlciBtb2RlbHMgb3IgdXNpbmcgbGFyZ2VyIGJhdGNoIHNpemVzIHdpdGhvdXQgZXhjZWVkaW5nIG1lbW9yeSBsaW1pdHMuCgojIyAqKjIuIFdoeSBVc2UgR3JhZGllbnQgQ2hlY2twb2ludGluZz8qKgoqICoqUmVkdWNlIE1lbW9yeSBVc2FnZToqKiBCeSBzdG9yaW5nIGZld2VyIGFjdGl2YXRpb25zLCBtZW1vcnkgcmVxdWlyZW1lbnRzIGFyZSByZWR1Y2VkLCBlbmFibGluZyB0cmFpbmluZyBvZiBkZWVwZXIgb3IgbGFyZ2VyIG1vZGVscy4KKiAqKkVuYWJsZSBMYXJnZXIgQmF0Y2hlcy9Nb2RlbHM6KiogTWFrZXMgaXQgcG9zc2libGUgdG8gZml0IGxhcmdlciBtb2RlbHMgb3IgdXNlIGxhcmdlciBiYXRjaCBzaXplcyBvbiBsaW1pdGVkIGhhcmR3YXJlLgoqICoqVHJhZGVvZmY6KiogVGhlIG1haW4gdHJhZGVvZmYgaXMgaW5jcmVhc2VkIGNvbXB1dGF0aW9uIHRpbWUsIGFzIHNvbWUgYWN0aXZhdGlvbnMgbXVzdCBiZSByZWNvbXB1dGVkIGR1cmluZyB0aGUgYmFja3dhcmQgcGFzcy4KCiMjICoqMy4gR3JhZGllbnQgQ2hlY2twb2ludGluZyBNZWNoYW5pc20qKgpTdXBwb3NlIGEgbW9kZWwgY29uc2lzdHMgb2YgJE4kIGxheWVycywgZWFjaCByZXByZXNlbnRlZCBieSBhIGZ1bmN0aW9uICRmX2kkLiBOb3JtYWxseSwgdGhlIGZvcndhcmQgcGFzcyBzdG9yZXMgYWxsIGludGVybWVkaWF0ZSBhY3RpdmF0aW9uczoKCiQkCkFfMCA9IHggXFwKQV8xID0gZl8xKEFfMCkgXFwKQV8yID0gZl8yKEFfMSkgXFwKXGxkb3RzIFxcCkFfTiA9IGZfTihBX3tOLTF9KQokJAoKV2l0aCBncmFkaWVudCBjaGVja3BvaW50aW5nLCBvbmx5IGEgc3Vic2V0IG9mICRBX2kkIGFyZSBzdG9yZWQgKHRoZSBjaGVja3BvaW50cykuIFRoZSBvdGhlcnMgYXJlIHJlY29tcHV0ZWQgYXMgbmVlZGVkIGR1cmluZyBiYWNrcHJvcGFnYXRpb24uIEluIHRoZSBzaW1wbGVzdCBjYXNlLCB5b3UgY2FuIHN0b3JlIG9ubHkgdGhlIGlucHV0IGFuZCBvdXRwdXQsIGFuZCByZWNvbXB1dGUgYWxsIGludGVybWVkaWF0ZXMgd2hlbiBuZWVkZWQuCgoqKkV4YW1wbGU6KioKSWYgeW91IGhhdmUgdGhyZWUgZnVuY3Rpb25zICRmXzEsIGZfMiwgZl8zJCBhbmQgaW5wdXQgJHgkOgoqIEZvcndhcmQ6ICRBXzEgPSBmXzEoeCkkLCAkQV8yID0gZl8yKEFfMSkkLCAkQV8zID0gZl8zKEFfMikkCiogV2l0aCBjaGVja3BvaW50aW5nLCB5b3UgbWlnaHQgb25seSBzdG9yZSAkeCQgYW5kICRBXzMkLCBhbmQgcmVjb21wdXRlICRBXzEkIGFuZCAkQV8yJCBhcyBuZWVkZWQuCgojIyAqKjQuIEFwcGxpY2F0aW9ucyBvZiBHcmFkaWVudCBDaGVja3BvaW50aW5nKioKR3JhZGllbnQgY2hlY2twb2ludGluZyBpcyB3aWRlbHkgdXNlZCBpbiB0cmFpbmluZzoKKiAqKlZlcnkgRGVlcCBOZXVyYWwgTmV0d29ya3M6KiogVHJhbnNmb3JtZXJzLCBSZXNOZXRzLCBhbmQgb3RoZXIgYXJjaGl0ZWN0dXJlcyB3aXRoIG1hbnkgbGF5ZXJzLgoqICoqTGFyZ2UtU2NhbGUgTW9kZWxzOioqIExhbmd1YWdlIG1vZGVscywgdmlzaW9uIG1vZGVscywgYW5kIG1vcmUuCiogKipNZW1vcnktQ29uc3RyYWluZWQgRW52aXJvbm1lbnRzOioqIFdoZW4gaGFyZHdhcmUgY2Fubm90IGZpdCBhbGwgYWN0aXZhdGlvbnMgaW4gbWVtb3J5LgoqICoqQW55IG9wdGltaXphdGlvbiBwcm9ibGVtKiogd2hlcmUgbWVtb3J5IGlzIGEgYm90dGxlbmVjayBkdXJpbmcgdHJhaW5pbmcuCgpHcmFkaWVudCBjaGVja3BvaW50aW5nIGlzIGEgcG93ZXJmdWwgdG9vbCB0byBlbmFibGUgdHJhaW5pbmcgb2YgbGFyZ2UgbW9kZWxzIG9uIGxpbWl0ZWQgaGFyZHdhcmUsIGF0IHRoZSBjb3N0IG9mIGV4dHJhIGNvbXB1dGF0aW9uLg==",
  "description_decoded": "## Problem\n\nWrite a Python function `checkpoint_forward` that takes a list of numpy functions (each representing a layer or operation) and an input numpy array, and returns the final output by applying each function in sequence. To simulate gradient checkpointing, the function should not store intermediate activations; instead, it should recompute them as needed (for this problem, just apply the functions in sequence as usual). Only use standard Python and numpy. The returned array should be of type float and have the same shape as the output of the last function.",
  "learn_section_decoded": "# **Gradient Checkpointing**\n\n## **1. Definition**\nGradient checkpointing is a technique used in deep learning to reduce memory usage during training by selectively storing only a subset of intermediate activations (checkpoints) and recomputing the others as needed during the backward pass. This allows training of larger models or using larger batch sizes without exceeding memory limits.\n\n## **2. Why Use Gradient Checkpointing?**\n* **Reduce Memory Usage:** By storing fewer activations, memory requirements are reduced, enabling training of deeper or larger models.\n* **Enable Larger Batches/Models:** Makes it possible to fit larger models or use larger batch sizes on limited hardware.\n* **Tradeoff:** The main tradeoff is increased computation time, as some activations must be recomputed during the backward pass.\n\n## **3. Gradient Checkpointing Mechanism**\nSuppose a model consists of $N$ layers, each represented by a function $f_i$. Normally, the forward pass stores all intermediate activations:\n\n$$\nA_0 = x \\\\\nA_1 = f_1(A_0) \\\\\nA_2 = f_2(A_1) \\\\\n\\ldots \\\\\nA_N = f_N(A_{N-1})\n$$\n\nWith gradient checkpointing, only a subset of $A_i$ are stored (the checkpoints). The others are recomputed as needed during backpropagation. In the simplest case, you can store only the input and output, and recompute all intermediates when needed.\n\n**Example:**\nIf you have three functions $f_1, f_2, f_3$ and input $x$:\n* Forward: $A_1 = f_1(x)$, $A_2 = f_2(A_1)$, $A_3 = f_3(A_2)$\n* With checkpointing, you might only store $x$ and $A_3$, and recompute $A_1$ and $A_2$ as needed.\n\n## **4. Applications of Gradient Checkpointing**\nGradient checkpointing is widely used in training:\n* **Very Deep Neural Networks:** Transformers, ResNets, and other architectures with many layers.\n* **Large-Scale Models:** Language models, vision models, and more.\n* **Memory-Constrained Environments:** When hardware cannot fit all activations in memory.\n* **Any optimization problem** where memory is a bottleneck during training.\n\nGradient checkpointing is a powerful tool to enable training of large models on limited hardware, at the cost of extra computation."
}