{
  "description": "V3JpdGUgYSBQeXRob24gZnVuY3Rpb24gYGNvbnZlcnRfcmFuZ2VgIHRoYXQgc2hpZnRzIGFuZCBzY2FsZXMgdGhlIHZhbHVlcyBvZiBhIE51bVB5IGFycmF5IGZyb20gdGhlaXIgb3JpZ2luYWwgcmFuZ2UgJFthLCBiXSQgKHdoZXJlICRhPVxtaW4oeCkkIGFuZCAkYj1cbWF4KHgpJCkgdG8gYSBuZXcgdGFyZ2V0IHJhbmdlICRbYywgZF0kLiBZb3VyIGZ1bmN0aW9uIHNob3VsZCB3b3JrIGZvciBib3RoIDFEIGFuZCAyRCBhcnJheXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgc2FtZSBzaGFwZSwgYW5kIG9ubHkgdXNlIE51bVB5LiBSZXR1cm4gZmxvYXRpbmctcG9pbnQgcmVzdWx0cywgYW5kIGVuc3VyZSB5b3UgdXNlIHRoZSBjb3JyZWN0IGZvcm11bGEgdG8gbWFwIHRoZSBpbnB1dCBpbnRlcnZhbCB0byB0aGUgb3V0cHV0IGludGVydmFsLg==",
  "id": "141",
  "test_cases": [
    {
      "test": "import numpy as np\nseq = np.array([388, 242, 124, 384, 313, 277, 339, 302, 268, 392])\nc, d = 0, 1\nout = convert_range(seq, c, d)\nprint(np.round(out, 6))",
      "expected_output": "[0.985075, 0.440299, 0.,       0.970149, 0.705224, 0.570896, 0.802239, 0.664179, 0.537313, 1.      ]"
    },
    {
      "test": "import numpy as np\nseq = np.array([[2028, 4522], [1412, 2502], [3414, 3694], [1747, 1233], [1862, 4868]])\nc, d = 4, 8\nout = convert_range(seq, c, d)\nprint(np.round(out, 6))",
      "expected_output": "[[4.874828 7.619257]\n [4.196974 5.396424]\n [6.4      6.708116]\n [4.565612 4.      ]\n [4.69216  8.      ]]"
    }
  ],
  "difficulty": "easy",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "import numpy as np\nx = np.array([0, 5, 10])\nc, d = 2, 4\nprint(convert_range(x, c, d))",
    "output": "[2. 3. 4.]",
    "reasoning": "The minimum value (a) is 0 and the maximum value (b) is 10. The formula maps 0 to 2, 5 to 3, and 10 to 4 using: f(x) = c + (d-c)/(b-a)*(x-a)."
  },
  "category": "Machine Learning",
  "starter_code": "import numpy as np\n\ndef convert_range(values: np.ndarray, c: float, d: float) -> np.ndarray:\n    \"\"\"\n    Shift and scale values from their original range [min, max] to a target [c, d] range.\n    \"\"\"\n    # Your code here\n    pass",
  "title": "Shift and Scale Array to Target Range",
  "learn_section": "IyAqKlNoaWZ0aW5nIGFuZCBTY2FsaW5nIGEgUmFuZ2UgKFJlc2NhbGluZyBEYXRhKSoqCgojIyAqKjEuIE1vdGl2YXRpb24qKgoKUmVzY2FsaW5nIChvciBzaGlmdGluZyBhbmQgc2NhbGluZykgaXMgYSBjb21tb24gcHJlcHJvY2Vzc2luZyBzdGVwIGluIGRhdGEgYW5hbHlzaXMgYW5kIG1hY2hpbmUgbGVhcm5pbmcuIEl0J3Mgb2Z0ZW4gbmVjZXNzYXJ5IHRvIG1hcCBkYXRhIGZyb20gYW4gb3JpZ2luYWwgcmFuZ2UgKGUuZy4sIHRlc3Qgc2NvcmVzLCBwaXhlbCB2YWx1ZXMsIEdQQSkgdG8gYSBuZXcgcmFuZ2Ugc3VpdGFibGUgZm9yIGRvd25zdHJlYW0gdGFza3Mgb3IgY29tcGF0aWJpbGl0eSBiZXR3ZWVuIGRhdGFzZXRzLiBGb3IgZXhhbXBsZSwgeW91IG1pZ2h0IHdhbnQgdG8gc2hpZnQgYSBHUEEgZnJvbSAkWzAsIDEwXSQgdG8gJFswLCA0XSQgZm9yIGNvbXBhcmlzb24gb3IgbW9kZWwgaW5wdXQuCgotLS0KCiMjICoqMi4gVGhlIEdlbmVyYWwgTWFwcGluZyBGb3JtdWxhKioKClN1cHBvc2UgeW91IGhhdmUgaW5wdXQgdmFsdWVzIGluIHRoZSByYW5nZSAkW2EsIGJdJCBhbmQgeW91IHdhbnQgdG8gbWFwIHRoZW0gdG8gdGhlIGludGVydmFsICRbYywgZF0kLgoKLSBGaXJzdCwgc2hpZnQgdGhlIGxvd2VyIGJvdW5kIHRvICQwJCBieSBhcHBseWluZyAkeCBcbWFwc3RvIHggLSBhJCwgc28gJFthLCBiXSBccmlnaHRhcnJvdyBbMCwgYi1hXSQuCi0gTmV4dCwgc2NhbGUgdG8gdW5pdCBpbnRlcnZhbDogJHQgXG1hcHN0byBcZnJhY3sxfXtiLWF9IFxjZG90IHQkLCB5aWVsZGluZyAkWzAsIDFdJC4KLSBOb3csIHNjYWxlIHRvICRbMCwgZC1jXSQgd2l0aCAkdCBcbWFwc3RvIChkLWMpdCQsIGFuZCBzaGlmdCB0byAkW2MsIGRdJCB3aXRoICR0IFxtYXBzdG8gYyArIHQkLgotIENvbWJpbmluZyBhbGwgc3RlcHMsIHRoZSBjb21wbGV0ZSBmb3JtdWxhIGlzOgoKJCQKICAgIGYoeCkgPSBjICsgXGxlZnQoXGZyYWN7ZC1jfXtiLWF9XHJpZ2h0KSh4LWEpCiQkCgotICR4JCA9IHRoZSBpbnB1dCB2YWx1ZQotICRhID0gXG1pbih4KSQgYW5kICRiID0gXG1heCh4KSQKLSAkYyQsICRkJCA9IHRhcmdldCBpbnRlcnZhbCBlbmRwb2ludHMKCi0tLQoKIyMgKiozLiBBcHBsaWNhdGlvbnMqKgotICoqSW1hZ2UgUHJvY2Vzc2luZyoqOiBSZXNjYWxlIHBpeGVsIGludGVuc2l0aWVzCi0gKipGZWF0dXJlIEVuZ2luZWVyaW5nKio6IE5vcm1hbGl6ZSBmZWF0dXJlcyB0byBhIGNvbW1vbiByYW5nZQotICoqU2NvcmUgQ29udmVyc2lvbioqOiBDb252ZXJ0IHRlc3Qgc2NvcmVzIG9yIGdyYWRlcyBiZXR3ZWVuIHN5c3RlbXMKCi0tLQoKIyMgKio0LiBQcmFjdGljYWwgQ29uc2lkZXJhdGlvbnMqKgotIEJlIGF3YXJlIG9mIHRoZSBjYXNlIHdoZW4gJGEgPSBiJCAoY29uc3RhbnQgaW5wdXQpOyB0aGlzIG1heSByZXF1aXJlIHNwZWNpYWwgaGFuZGxpbmcgKGUuZy4sIG91dHB1dCBhbGwgJGMkKS4KLSBGb3IgbXVsdGlkaW1lbnNpb25hbCBhcnJheXMsIHVzZSBOdW1QeeKAmXMgYC5taW4oKWAgYW5kIGAubWF4KClgIHRvIGRldGVybWluZSB0aGUgZnVsbCBpbnB1dCByYW5nZS4KCi0tLQoKVGhpcyBmb3JtdWxhIGdpdmVzIGEgKipzaW1wbGUsIG1hdGhlbWF0aWNhbGx5IGp1c3RpZmllZCB3YXkgdG8gc2hpZnQgYW5kIHNjYWxlIGRhdGEgdG8gYW55IHRhcmdldCByYW5nZSoq4oCUYSBjb3JlIHRvb2wgZm9yIHJvYnVzdCBtYWNoaW5lIGxlYXJuaW5nIHBpcGVsaW5lcy4K",
  "contributor": [
    {
      "profile_link": "https://github.com/turkunov",
      "name": "turkunov"
    }
  ],
  "description_decoded": "Write a Python function `convert_range` that shifts and scales the values of a NumPy array from their original range $[a, b]$ (where $a=\\min(x)$ and $b=\\max(x)$) to a new target range $[c, d]$. Your function should work for both 1D and 2D arrays, returning an array of the same shape, and only use NumPy. Return floating-point results, and ensure you use the correct formula to map the input interval to the output interval.",
  "learn_section_decoded": "# **Shifting and Scaling a Range (Rescaling Data)**\n\n## **1. Motivation**\n\nRescaling (or shifting and scaling) is a common preprocessing step in data analysis and machine learning. It's often necessary to map data from an original range (e.g., test scores, pixel values, GPA) to a new range suitable for downstream tasks or compatibility between datasets. For example, you might want to shift a GPA from $[0, 10]$ to $[0, 4]$ for comparison or model input.\n\n---\n\n## **2. The General Mapping Formula**\n\nSuppose you have input values in the range $[a, b]$ and you want to map them to the interval $[c, d]$.\n\n- First, shift the lower bound to $0$ by applying $x \\mapsto x - a$, so $[a, b] \\rightarrow [0, b-a]$.\n- Next, scale to unit interval: $t \\mapsto \\frac{1}{b-a} \\cdot t$, yielding $[0, 1]$.\n- Now, scale to $[0, d-c]$ with $t \\mapsto (d-c)t$, and shift to $[c, d]$ with $t \\mapsto c + t$.\n- Combining all steps, the complete formula is:\n\n$$\n    f(x) = c + \\left(\\frac{d-c}{b-a}\\right)(x-a)\n$$\n\n- $x$ = the input value\n- $a = \\min(x)$ and $b = \\max(x)$\n- $c$, $d$ = target interval endpoints\n\n---\n\n## **3. Applications**\n- **Image Processing**: Rescale pixel intensities\n- **Feature Engineering**: Normalize features to a common range\n- **Score Conversion**: Convert test scores or grades between systems\n\n---\n\n## **4. Practical Considerations**\n- Be aware of the case when $a = b$ (constant input); this may require special handling (e.g., output all $c$).\n- For multidimensional arrays, use NumPy’s `.min()` and `.max()` to determine the full input range.\n\n---\n\nThis formula gives a **simple, mathematically justified way to shift and scale data to any target range**—a core tool for robust machine learning pipelines.\n"
}