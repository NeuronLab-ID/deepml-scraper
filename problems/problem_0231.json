{
  "description": "SW1wbGVtZW50IHRlbXBlcmF0dXJlIGRlY2F5IHNjaGVkdWxlcnMgdXNlZCB0byBjb250cm9sIHJhbmRvbW5lc3MgaW4gbmV1cmFsIG5ldHdvcmsgdHJhaW5pbmcuIFRlbXBlcmF0dXJlIHNjYWxlcyB0aGUgc29mdG1heCBkaXN0cmlidXRpb246IGhpZ2ggdGVtcGVyYXR1cmUgcHJvZHVjZXMgbW9yZSB1bmlmb3JtIChleHBsb3JhdG9yeSkgb3V0cHV0cywgd2hpbGUgbG93IHRlbXBlcmF0dXJlIHByb2R1Y2VzIHBlYWtlZCAoZGV0ZXJtaW5pc3RpYykgb3V0cHV0cy4gSW1wbGVtZW50IGZvdXIgY29tbW9uIHNjaGVkdWxlczogbGluZWFyLCBleHBvbmVudGlhbCwgY29zaW5lIGFubmVhbGluZywgYW5kIGNvbnN0YW50LiBUaGVzZSBhcmUgY3J1Y2lhbCBmb3IgdGV4dCBnZW5lcmF0aW9uLCBHdW1iZWwtU29mdG1heCB0cmFpbmluZywgcmVpbmZvcmNlbWVudCBsZWFybmluZywgYW5kIGtub3dsZWRnZSBkaXN0aWxsYXRpb24u",
  "id": "231",
  "test_cases": [
    {
      "test": "result = temperature_decay('linear', 2.0, 500, 1000, final_temp=0.1); print(f\"{result:.4f}\")",
      "expected_output": "1.0500"
    },
    {
      "test": "result = temperature_decay('exponential', 1.0, 100, 1000, decay_rate=0.99); print(f\"{result:.6f}\")",
      "expected_output": "0.366032"
    }
  ],
  "difficulty": "medium",
  "pytorch_difficulty": "easy",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "schedule='linear', initial=2.0, step=500, total=1000, final=0.1",
    "output": "1.05",
    "reasoning": "Linear interpolation: progress=500/1000=0.5. Temperature = 2.0 - (2.0-0.1)*0.5 = 2.0 - 0.95 = 1.05. Halfway through training, temperature is halfway between initial and final values."
  },
  "category": "Deep Learning",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCmltcG9ydCBtYXRoCgpkZWYgdGVtcGVyYXR1cmVfZGVjYXlfcHl0b3JjaCgKICAgIHNjaGVkdWxlX3R5cGU6IHN0ciwKICAgIGluaXRpYWxfdGVtcDogZmxvYXQsCiAgICBjdXJyZW50X3N0ZXA6IGludCwKICAgIHRvdGFsX3N0ZXBzOiBpbnQsCiAgICBmaW5hbF90ZW1wOiBmbG9hdCA9IDAuMDEsCiAgICBkZWNheV9yYXRlOiBmbG9hdCA9IDAuOTUKKSAtPiB0b3JjaC5UZW5zb3I6CgkiIiIKCUNvbXB1dGUgdGVtcGVyYXR1cmUgYXQgY3VycmVudCB0cmFpbmluZyBzdGVwIHVzaW5nIFB5VG9yY2guCgkKCVNhbWUgYXMgTnVtUHkgdmVyc2lvbiBidXQgcmV0dXJucyB0b3JjaC5UZW5zb3IuCglVc2VmdWwgZm9yIGludGVncmF0aW9uIHdpdGggUHlUb3JjaCB0cmFpbmluZyBsb29wcy4KCQoJQXJnczoKCQlzY2hlZHVsZV90eXBlOiAnbGluZWFyJywgJ2V4cG9uZW50aWFsJywgJ2Nvc2luZScsIG9yICdjb25zdGFudCcKCQlpbml0aWFsX3RlbXA6IFN0YXJ0aW5nIHRlbXBlcmF0dXJlCgkJY3VycmVudF9zdGVwOiBDdXJyZW50IHRyYWluaW5nIHN0ZXAKCQl0b3RhbF9zdGVwczogVG90YWwgbnVtYmVyIG9mIHN0ZXBzCgkJZmluYWxfdGVtcDogTWluaW11bSB0ZW1wZXJhdHVyZQoJCWRlY2F5X3JhdGU6IERlY2F5IHJhdGUgZm9yIGV4cG9uZW50aWFsCgkKCVJldHVybnM6CgkJVGVtcGVyYXR1cmUgYXMgdG9yY2guVGVuc29yIChzY2FsYXIpCgkJCglIaW50czoKCQktIFVzZSB0b3JjaC50ZW5zb3IoKSB0byBjcmVhdGUgdGVuc29ycwoJCS0gVXNlIHRvcmNoLmNvcygpIGZvciBjb3NpbmUKCQktIFVzZSB0b3JjaC5jbGFtcCgpIHRvIGVuZm9yY2UgbWluaW11bQoJCS0gVXNlIC5pdGVtKCkgdG8gZXh0cmFjdCBQeXRob24gZmxvYXQgaWYgbmVlZGVkCgkiIiIKCSMgWW91ciBjb2RlIGhlcmUKCXBhc3M=",
  "title": "Temperature Decay Scheduler",
  "createdAt": "December 11, 2025 at 1:49:40 PM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "result = temperature_decay_pytorch('linear', 2.0, 500, 1000, final_temp=0.1); print(f\"{result.item():.4f}\")",
      "expected_output": "1.0500"
    },
    {
      "test": "result = temperature_decay_pytorch('exponential', 1.0, 100, 1000, decay_rate=0.99); print(f\"{result.item():.6f}\")",
      "expected_output": "0.366032"
    },
    {
      "test": "result = temperature_decay_pytorch('cosine', 2.0, 500, 1000, final_temp=0.0); print(f\"{result.item():.4f}\")",
      "expected_output": "1.0000"
    },
    {
      "test": "result = temperature_decay_pytorch('constant', 1.5, 999, 1000); print(f\"{result.item():.1f}\")",
      "expected_output": "1.5"
    },
    {
      "test": "result = temperature_decay_pytorch('exponential', 1.0, 20, 1000, final_temp=0.01, decay_rate=0.5); print(f\"{result.item():.2f}\")",
      "expected_output": "0.01"
    }
  ],
  "learn_section": "IyMjIFRlbXBlcmF0dXJlIERlY2F5IFNjaGVkdWxpbmcKClRlbXBlcmF0dXJlIGlzIGEgaHlwZXJwYXJhbWV0ZXIgdGhhdCBjb250cm9scyByYW5kb21uZXNzIGluIG5ldXJhbCBuZXR3b3JrIG91dHB1dHMuIFRlbXBlcmF0dXJlIGRlY2F5IHNjaGVkdWxlcyBncmFkdWFsbHkgcmVkdWNlIHRlbXBlcmF0dXJlIGR1cmluZyB0cmFpbmluZyB0byB0cmFuc2l0aW9uIGZyb20gZXhwbG9yYXRpb24gdG8gZXhwbG9pdGF0aW9uLgoKIyMjIyBXaGF0IGlzIFRlbXBlcmF0dXJlPwoKKipUZW1wZXJhdHVyZSAoVCkqKiBzY2FsZXMgbG9naXRzIGJlZm9yZSBhcHBseWluZyBzb2Z0bWF4OgoKJCQKUCh5X2kpID0gXGZyYWN7ZV57el9pL1x0YXV9fXtcc3VtX2ogZV57el9qL1x0YXV9fQokJAoKV2hlcmU6Ci0gJHpfaSQgPSBsb2dpdHMgKHJhdyBtb2RlbCBvdXRwdXRzKQotICRcdGF1JCA9IHRlbXBlcmF0dXJlCi0gJFAoeV9pKSQgPSBwcm9iYWJpbGl0eSBvZiBjbGFzcyAkaSQKCioqRWZmZWN0IG9mIHRlbXBlcmF0dXJlKio6Ci0gKipIaWdoIHRlbXBlcmF0dXJlIChUID4gMSkqKjogTW9yZSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiwgbW9yZSByYW5kb21uZXNzCi0gKipMb3cgdGVtcGVyYXR1cmUgKFQgPCAxKSoqOiBQZWFrZWQgZGlzdHJpYnV0aW9uLCBtb3JlIGRldGVybWluaXN0aWMKLSAqKlQgPSAxKio6IFN0YW5kYXJkIHNvZnRtYXggKG5vIHNjYWxpbmcpCgojIyMjIFRlbXBlcmF0dXJlIERlY2F5IFNjaGVkdWxlcwoKKioxLiBMaW5lYXIgRGVjYXkqKgoKJCQKXHRhdSh0KSA9IFx0YXVfe1x0ZXh0e2luaXRpYWx9fSAtIChcdGF1X3tcdGV4dHtpbml0aWFsfX0gLSBcdGF1X3tcdGV4dHtmaW5hbH19KSBcY2RvdCBcZnJhY3t0fXtUfQokJAoKV2hlcmU6Ci0gJHQkID0gY3VycmVudCBzdGVwCi0gJFQkID0gdG90YWwgc3RlcHMKCioqUHJvcGVydGllcyoqOgotIENvbnN0YW50IGRlY2F5IHJhdGUKLSBQcmVkaWN0YWJsZSBwcm9ncmVzc2lvbgotIFNpbXBsZSB0byBpbXBsZW1lbnQKCioqRXhhbXBsZSoqOiAkXHRhdV97XHRleHR7aW5pdGlhbH19ID0gMi4wJCwgJFx0YXVfe1x0ZXh0e2ZpbmFsfX0gPSAwLjEkLCAkdCA9IDUwMCQsICRUID0gMTAwMCQKCiQkClx0YXUoNTAwKSA9IDIuMCAtICgyLjAgLSAwLjEpIFxjZG90IDAuNSA9IDIuMCAtIDAuOTUgPSAxLjA1CiQkCgoqKjIuIEV4cG9uZW50aWFsIERlY2F5KioKCiQkClx0YXUodCkgPSBcbWF4KFx0YXVfe1x0ZXh0e2luaXRpYWx9fSBcY2RvdCBcZ2FtbWFedCwgXHRhdV97XHRleHR7ZmluYWx9fSkKJCQKCldoZXJlICRcZ2FtbWEkIGlzIHRoZSBkZWNheSByYXRlIChlLmcuLCAwLjk5KQoKKipQcm9wZXJ0aWVzKio6Ci0gRmFzdCBpbml0aWFsIGRlY2F5Ci0gU2xvdyBsYXRlciBkZWNheQotIE5lZWRzIG1pbmltdW0gdGVtcGVyYXR1cmUgKGZsb29yKQoKKipFeGFtcGxlKio6ICRcdGF1X3tcdGV4dHtpbml0aWFsfX0gPSAxLjAkLCAkXGdhbW1hID0gMC45OSQsICR0ID0gMTAwJAoKJCQKXHRhdSgxMDApID0gMS4wIFx0aW1lcyAwLjk5XnsxMDB9IFxhcHByb3ggMC4zNjYKJCQKCioqMy4gQ29zaW5lIEFubmVhbGluZyoqCgokJApcdGF1KHQpID0gXHRhdV97XHRleHR7ZmluYWx9fSArIFxmcmFjezF9ezJ9KFx0YXVfe1x0ZXh0e2luaXRpYWx9fSAtIFx0YXVfe1x0ZXh0e2ZpbmFsfX0pIFxsZWZ0KDEgKyBcY29zXGxlZnQoXGZyYWN7XHBpIHR9e1R9XHJpZ2h0KVxyaWdodCkKJCQKCioqUHJvcGVydGllcyoqOgotIFNtb290aCBkZWNheQotIFNsb3cgYXQgc3RhcnQgYW5kIGVuZAotIEZhc3QgaW4gbWlkZGxlCi0gU09UQSBpbiBtYW55IGFwcGxpY2F0aW9ucwoKKipFeGFtcGxlKio6ICRcdGF1X3tcdGV4dHtpbml0aWFsfX0gPSAyLjAkLCAkXHRhdV97XHRleHR7ZmluYWx9fSA9IDAuMCQsICR0ID0gNTAwJCwgJFQgPSAxMDAwJAoKUHJvZ3Jlc3M6ICRcZnJhY3s1MDB9ezEwMDB9ID0gMC41JAoKJCQKXGNvcyhccGkgXGNkb3QgMC41KSA9IFxjb3NcbGVmdChcZnJhY3tccGl9ezJ9XHJpZ2h0KSA9IDAKJCQKCiQkClx0YXUoNTAwKSA9IDAuMCArIFxmcmFjezF9ezJ9KDIuMCAtIDAuMCkoMSArIDApID0gMS4wCiQkCgoqKjQuIENvbnN0YW50IChObyBEZWNheSkqKgoKJCQKXHRhdSh0KSA9IFx0YXVfe1x0ZXh0e2luaXRpYWx9fSBccXVhZCBcZm9yYWxsIHQKJCQKClVzZWQgYXMgYmFzZWxpbmUgb3Igd2hlbiB0ZW1wZXJhdHVyZSBpcyBub3QgY3JpdGljYWwuCgojIyMjIEFwcGxpY2F0aW9ucwoKKioxLiBUZXh0IEdlbmVyYXRpb24qKgoKQ29udHJvbCBkaXZlcnNpdHkgaW4gbGFuZ3VhZ2UgbW9kZWwgb3V0cHV0cy4KCioqRXhhbXBsZSBsb2dpdHMqKjogWzIuMCwgMS4wLCAwLjVdIGZvciB0aHJlZSB0b2tlbnMKCioqVGVtcGVyYXR1cmUgPSAwLjEqKiAobG93LCBkZXRlcm1pbmlzdGljKToKLSBQcm9iYWJpbGl0aWVzOiBbOTkuOTk1JSwgMC4wMDUlLCAwLjAlXQotIE5lYXJseSBhbHdheXMgcGlja3MgaGlnaGVzdCBsb2dpdAotIFVzZTogRmFjdHVhbCBxdWVzdGlvbiBhbnN3ZXJpbmcKCioqVGVtcGVyYXR1cmUgPSAyLjAqKiAoaGlnaCwgcmFuZG9tKToKLSBQcm9iYWJpbGl0aWVzOiBbNDglLCAyOSUsIDIzJV0KLSBNb3JlIHVuaWZvcm0gZGlzdHJpYnV0aW9uCi0gVXNlOiBDcmVhdGl2ZSB3cml0aW5nLCBicmFpbnN0b3JtaW5nCgoqKkRlY2F5IHNjaGVkdWxlKio6IFN0YXJ0IHdpdGggVD0yLjAgZm9yIGV4cGxvcmF0aW9uLCBkZWNheSB0byBUPTAuNSBmb3IgcXVhbGl0eS4KCioqMi4gR3VtYmVsLVNvZnRtYXgqKgoKRW5hYmxlcyBncmFkaWVudC1iYXNlZCBsZWFybmluZyB3aXRoIGRpc2NyZXRlIGxhdGVudCB2YXJpYWJsZXMuCgoqKlN0YW5kYXJkIHByb2JsZW0qKjogRGlzY3JldGUgc2FtcGxpbmcgaXMgbm9uLWRpZmZlcmVudGlhYmxlCgoqKkd1bWJlbC1Tb2Z0bWF4IHRyaWNrKio6CiQkCnlfaSA9IFxmcmFje1xleHAoKFxsb2coXHBpX2kpICsgZ19pKS9cdGF1KX17XHN1bV9qIFxleHAoKFxsb2coXHBpX2opICsgZ19qKS9cdGF1KX0KJCQKCldoZXJlICRnX2kkIGlzIEd1bWJlbCBub2lzZTogJGcgPSAtXGxvZygtXGxvZyh1KSkkLCAkdSBcc2ltIFx0ZXh0e1VuaWZvcm19KDAsMSkkCgoqKlRlbXBlcmF0dXJlIGRlY2F5Kio6Ci0gKipTdGFydCBoaWdoIChUPTUuMCkqKjogU29mdCwgZ3JhZGllbnRzIGZsb3cgZWFzaWx5Ci0gKipEZWNheSoqOiBHcmFkdWFsbHkgYmVjb21lIG1vcmUgZGlzY3JldGUKLSAqKkVuZCBsb3cgKFQ9MC4xKSoqOiBOZWFybHkgb25lLWhvdCwgYmVoYXZlcyBsaWtlIGRpc2NyZXRlIHNhbXBsZQoKKipVc2UgY2FzZXMqKjoKLSBWYXJpYXRpb25hbCBBdXRvZW5jb2RlcnMgKFZBRXMpIHdpdGggZGlzY3JldGUgbGF0ZW50cwotIE5ldXJhbCBhcmNoaXRlY3R1cmUgc2VhcmNoCi0gRGlzY3JldGUgYm90dGxlbmVjayBsYXllcnMKCioqMy4gUmVpbmZvcmNlbWVudCBMZWFybmluZyoqCgpCb2x0em1hbm4gZXhwbG9yYXRpb24gcG9saWN5OgoKJCQKXHBpKGF8cykgPSBcZnJhY3tcZXhwKFEocyxhKS9cdGF1KX17XHN1bV97YSd9IFxleHAoUShzLGEnKS9cdGF1KX0KJCQKCioqVGVtcGVyYXR1cmUgZGVjYXkqKjoKLSAqKkVhcmx5IHRyYWluaW5nIChUPTIuMCkqKjogSGlnaCBleHBsb3JhdGlvbiwgdHJ5IG1hbnkgYWN0aW9ucwotICoqTWlkIHRyYWluaW5nIChUPTEuMCkqKjogQmFsYW5jZWQgZXhwbG9yYXRpb24tZXhwbG9pdGF0aW9uCi0gKipMYXRlIHRyYWluaW5nIChUPTAuMSkqKjogRXhwbG9pdGF0aW9uLCBuZWFyLWdyZWVkeSBwb2xpY3kKCioqRXhhbXBsZSBRLXZhbHVlcyoqOiBbMC44LCAwLjUsIDAuMywgMC4xXQoKKipUZW1wZXJhdHVyZSA9IDIuMCoqIChleHBsb3JlKToKLSBBY3Rpb24gcHJvYnM6IFswLjMwLCAwLjI2LCAwLjIzLCAwLjIxXQotIEZhaXJseSB1bmlmb3JtLCB0cmllcyBhbGwgYWN0aW9ucwoKKipUZW1wZXJhdHVyZSA9IDAuMSoqIChleHBsb2l0KToKLSBBY3Rpb24gcHJvYnM6IFswLjkyLCAwLjA1LCAwLjAyLCAwLjAxXQotIFN0cm9uZ2x5IHByZWZlcnMgYmVzdCBhY3Rpb24KCioqNC4gS25vd2xlZGdlIERpc3RpbGxhdGlvbioqCgpTdHVkZW50IG5ldHdvcmsgbGVhcm5zIGZyb20gdGVhY2hlcidzIHNvZnQgdGFyZ2V0cy4KCioqSGFyZCBsYWJlbHMqKjogWzAsIDAsIDEsIDBdIC0gb25seSB0YXJnZXQgY2xhc3MKCioqU29mdCB0YXJnZXRzKiogKHRlYWNoZXIgd2l0aCBUPTMpOgotIExvZ2l0czogWzUuMCwgMi4wLCA2LjAsIDEuMF0KLSBTb2Z0IHByb2JzOiBbMC4yMiwgMC4wMywgMC43MywgMC4wMV0KLSBSZXZlYWxzOiBDbGFzcyAzIGlzIGJlc3QsIGNsYXNzIDEgaXMgc2ltaWxhciwgY2xhc3MgMiBpcyBkaXNzaW1pbGFyCgoqKkJlbmVmaXRzIG9mIGhpZ2ggdGVtcGVyYXR1cmUqKjoKLSBQcmVzZXJ2ZXMgcmVsYXRpdmUgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGNsYXNzZXMKLSBTdHVkZW50IGxlYXJucyByaWNoZXIgcmVwcmVzZW50YXRpb24KLSBJbXByb3ZlZCBnZW5lcmFsaXphdGlvbgoKKipUeXBpY2FsIGFwcHJvYWNoKio6IFVzZSBUPTMtMTAgZHVyaW5nIGRpc3RpbGxhdGlvbiwgVD0xIGZvciBmaW5hbCBwcmVkaWN0aW9ucwoKIyMjIyBDaG9vc2luZyBhIFNjaGVkdWxlCgoqKkxpbmVhcioqOgotIFVzZSB3aGVuOiBGaXhlZCB0cmFpbmluZyBkdXJhdGlvbiwgc2ltcGxlIGJhc2VsaW5lCi0gUHJvczogUHJlZGljdGFibGUsIGVhc3kgdG8gdW5kZXJzdGFuZAotIENvbnM6IE1heSBiZSB0b28gYWdncmVzc2l2ZSBlYXJseSBvciB0b28gc2xvdyBsYXRlCgoqKkV4cG9uZW50aWFsKio6Ci0gVXNlIHdoZW46IFdhbnQgZmFzdCBpbml0aWFsIGRlY2F5Ci0gUHJvczogUXVpY2sgZWFybHkgYWRhcHRhdGlvbgotIENvbnM6IENhbiBkZWNheSB0b28gZmFzdCwgbWF5IGhpdCBmbG9vciBlYXJseQoKKipDb3NpbmUqKjoKLSBVc2Ugd2hlbjogR2VuZXJhbCBwdXJwb3NlLCBTT1RBIGFwcHJvYWNoCi0gUHJvczogU21vb3RoLCB3ZWxsLWJhbGFuY2VkLCB3aWRlbHkgc3VjY2Vzc2Z1bAotIENvbnM6IFNsaWdodGx5IG1vcmUgY29tcGxleAoKKipDb25zdGFudCoqOgotIFVzZSB3aGVuOiBUZW1wZXJhdHVyZSBub3QgY3JpdGljYWwsIGJhc2VsaW5lIGNvbXBhcmlzb24KLSBQcm9zOiBObyB0dW5pbmcgbmVlZGVkCi0gQ29uczogTm8gYWRhcHRhdGlvbgoKIyMjIyBTY2hlZHVsZSBDb21wYXJpc29uCgpUcmFpbmluZyBmb3IgMTAwMCBzdGVwcywgVF9pbml0aWFsPTIuMCwgVF9maW5hbD0wLjEKCnwgU3RlcCB8IExpbmVhciB8IEV4cG9uZW50aWFsICjOsz0wLjk5NSkgfCBDb3NpbmUgfCBDb25zdGFudCB8CnwtLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tfAp8IDAgfCAyLjAwIHwgMi4wMCB8IDIuMDAgfCAyLjAwIHwKfCAyNTAgfCAxLjUzIHwgMC41NyB8IDEuNzIgfCAyLjAwIHwKfCA1MDAgfCAxLjA1IHwgMC4xNiB8IDEuMDUgfCAyLjAwIHwKfCA3NTAgfCAwLjU4IHwgMC4wNSB8IDAuMzggfCAyLjAwIHwKfCAxMDAwIHwgMC4xMCB8IDAuMDEgfCAwLjEwIHwgMi4wMCB8CgoqKk9ic2VydmF0aW9ucyoqOgotIEV4cG9uZW50aWFsIGRlY2F5cyBmYXN0ZXN0IChtYXkgYmUgdG9vIGFnZ3Jlc3NpdmUpCi0gTGluZWFyIGlzIHN0ZWFkeSBhbmQgcHJlZGljdGFibGUKLSBDb3NpbmUgaXMgc21vb3RoIHdpdGggc2xvdyBzdGFydC9lbmQKLSBDb25zdGFudCBwcm92aWRlcyB1cHBlciBib3VuZCBiYXNlbGluZQoKIyMjIyBJbXBsZW1lbnRhdGlvbiBDb25zaWRlcmF0aW9ucwoKKioxLiBNaW5pbXVtIFRlbXBlcmF0dXJlKioKCkFsd2F5cyBlbmZvcmNlIGEgZmxvb3IgdG8gcHJldmVudCBudW1lcmljYWwgaXNzdWVzOgoKJCQKXHRhdSh0KSA9IFxtYXgoXHRhdV97XHRleHR7Y29tcHV0ZWR9fSwgXHRhdV97XHRleHR7bWlufX0pCiQkCgpUeXBpY2FsICRcdGF1X3tcdGV4dHttaW59fSA9IDAuMDEkIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8uCgoqKjIuIFN0ZXAgdnMgRXBvY2gqKgoKQ2FuIGRlY2F5IHBlciBzdGVwIG9yIHBlciBlcG9jaDoKLSAqKlBlciBzdGVwKio6IFNtb290aGVyLCBtb3JlIGdyYWR1YWwKLSAqKlBlciBlcG9jaCoqOiBDb2Fyc2VyLCBlYXNpZXIgdG8gdHJhY2sKCioqMy4gV2FybXVwIFBlcmlvZCoqCgpTb21ldGltZXMga2VlcCB0ZW1wZXJhdHVyZSBjb25zdGFudCBpbml0aWFsbHk6Ci0gRmlyc3QgMTAlIG9mIHRyYWluaW5nOiBUID0gVF9pbml0aWFsCi0gUmVtYWluaW5nIDkwJTogQXBwbHkgZGVjYXkgc2NoZWR1bGUKCioqNC4gQ3ljbGljIFNjaGVkdWxlcyoqCgpSZXN0YXJ0IHRlbXBlcmF0dXJlIHBlcmlvZGljYWxseSAobGVzcyBjb21tb24pOgotIENhbiBoZWxwIGVzY2FwZSBsb2NhbCBtaW5pbWEKLSBVc2VkIGluIHNvbWUgYWR2ZXJzYXJpYWwgdHJhaW5pbmcKCiMjIyMgUHJhY3RpY2FsIFRyYWluaW5nIEV4YW1wbGUKCioqVGFzayoqOiBUcmFpbiBkaXNjcmV0ZSBWQUUgd2l0aCBHdW1iZWwtU29mdG1heAoKKipTZXR1cCoqOgotIFRvdGFsIHN0ZXBzOiAxMDAsMDAwICgxMDAgZXBvY2hzIMOXIDEwMDAgc3RlcHMpCi0gU2NoZWR1bGU6IENvc2luZSBhbm5lYWxpbmcKLSBUX2luaXRpYWw6IDIuMCAoc29mdCwgZWFzeSBncmFkaWVudHMpCi0gVF9maW5hbDogMC4xIChkaXNjcmV0ZSwgcmVhbGlzdGljIHNhbXBsZXMpCgoqKlRlbXBlcmF0dXJlIGF0IGtleSBwb2ludHMqKjoKLSBTdGVwIDAgKEVwb2NoIDApOiBUID0gMi4wMCAtIFZlcnkgc29mdAotIFN0ZXAgMjUsMDAwIChFcG9jaCAyNSk6IFQgPSAxLjcyIC0gU3RpbGwgZXhwbG9yYXRvcnkgIAotIFN0ZXAgNTAsMDAwIChFcG9jaCA1MCk6IFQgPSAxLjA1IC0gVHJhbnNpdGlvbmluZwotIFN0ZXAgNzUsMDAwIChFcG9jaCA3NSk6IFQgPSAwLjM4IC0gR2V0dGluZyBkaXNjcmV0ZQotIFN0ZXAgMTAwLDAwMCAoRXBvY2ggMTAwKTogVCA9IDAuMTAgLSBOZWFybHkgZGlzY3JldGUKCioqQmVuZWZpdHMqKjoKLSBFYXJseTogU29mdCBzYW1wbGVzLCBzdGFibGUgZ3JhZGllbnRzLCB3aWRlIGV4cGxvcmF0aW9uCi0gTWlkZGxlOiBCYWxhbmNlZCwgbGVhcm5pbmcgbWVhbmluZ2Z1bCBwYXR0ZXJucwotIExhdGU6IERpc2NyZXRlIHNhbXBsZXMsIHJlYWxpc3RpYyBvdXRwdXRzCgojIyMjIENvbW1vbiBQaXRmYWxscwoKKioxLiBEZWNheWluZyB0b28gZmFzdCoqOiBNb2RlbCBkb2Vzbid0IGV4cGxvcmUgZW5vdWdoCi0gU29sdXRpb246IFVzZSBzbG93ZXIgc2NoZWR1bGUgKGNvc2luZSkgb3IgaGlnaGVyIGRlY2F5IHJhdGUKCioqMi4gRGVjYXlpbmcgdG9vIHNsb3cqKjogTmV2ZXIgcmVhY2hlcyBleHBsb2l0YXRpb24KLSBTb2x1dGlvbjogRW5zdXJlIGZpbmFsIHRlbXBlcmF0dXJlIGlzIGxvdyBlbm91Z2ggKDwgMC41KQoKKiozLiBObyBtaW5pbXVtIHRlbXBlcmF0dXJlKio6IE51bWVyaWNhbCBpbnN0YWJpbGl0eQotIFNvbHV0aW9uOiBBbHdheXMgZW5mb3JjZSBUX21pbiAoZS5nLiwgMC4wMSkKCioqNC4gV3Jvbmcgc2NoZWR1bGUgZm9yIHRhc2sqKjogTGluZWFyIG1heSBiZSB0b28gc2ltcGxlCi0gU29sdXRpb246IFRyeSBjb3NpbmUgYXMgZGVmYXVsdCwgdHVuZSBpZiBuZWVkZWQKCiMjIyMgU3VtbWFyeQoKKipUZW1wZXJhdHVyZSBkZWNheSBzY2hlZHVsZXMqKjoKLSBMaW5lYXI6ICRcdGF1KHQpID0gXHRhdV8wIC0gKFx0YXVfMCAtIFx0YXVfZikgXGNkb3QgdC9UJAotIEV4cG9uZW50aWFsOiAkXHRhdSh0KSA9IFx0YXVfMCBcY2RvdCBcZ2FtbWFedCQKLSBDb3NpbmU6ICRcdGF1KHQpID0gXHRhdV9mICsgXGZyYWN7MX17Mn0oXHRhdV8wIC0gXHRhdV9mKSgxICsgXGNvcyhccGkgdC9UKSkkCi0gQ29uc3RhbnQ6ICRcdGF1KHQpID0gXHRhdV8wJAoKKipLZXkgYXBwbGljYXRpb25zKio6IFRleHQgZ2VuZXJhdGlvbiwgR3VtYmVsLVNvZnRtYXgsIFJMIGV4cGxvcmF0aW9uLCBrbm93bGVkZ2UgZGlzdGlsbGF0aW9uCgoqKkdlbmVyYWwgYWR2aWNlKio6IFN0YXJ0IHdpdGggY29zaW5lIGFubmVhbGluZyAoVF9pbml0aWFsPTIuMCwgVF9maW5hbD0wLjEpLCBhZGp1c3QgYmFzZWQgb24gdGFzawoKKipHb2FsKio6IFNtb290aCB0cmFuc2l0aW9uIGZyb20gZXhwbG9yYXRpb24gKGhpZ2ggVCkgdG8gZXhwbG9pdGF0aW9uIChsb3cgVCk=",
  "starter_code": "import numpy as np\n\ndef temperature_decay(\n    schedule_type: str,\n    initial_temp: float,\n    current_step: int,\n    total_steps: int,\n    final_temp: float = 0.01,\n    decay_rate: float = 0.95\n) -> float:\n\t\"\"\"\n\tCompute temperature at current training step using decay schedule.\n\t\n\tTemperature controls randomness in neural network outputs:\n\t- High temperature: More random, more exploration\n\t- Low temperature: More deterministic, more exploitation\n\t\n\tArgs:\n\t\tschedule_type: Decay schedule type\n\t\t  'linear': Steady linear decrease\n\t\t  'exponential': Fast early decay, slow later\n\t\t  'cosine': Smooth cosine curve\n\t\t  'constant': No decay\n\t\tinitial_temp: Starting temperature\n\t\tcurrent_step: Current training step (0 to total_steps)\n\t\ttotal_steps: Total number of training steps\n\t\tfinal_temp: Minimum temperature (floor)\n\t\tdecay_rate: Decay rate per step (for exponential)\n\t\n\tReturns:\n\t\tTemperature value at current step\n\t\"\"\"\n\t# Your code here\n\tpass",
  "description_decoded": "Implement temperature decay schedulers used to control randomness in neural network training. Temperature scales the softmax distribution: high temperature produces more uniform (exploratory) outputs, while low temperature produces peaked (deterministic) outputs. Implement four common schedules: linear, exponential, cosine annealing, and constant. These are crucial for text generation, Gumbel-Softmax training, reinforcement learning, and knowledge distillation.",
  "learn_section_decoded": "### Temperature Decay Scheduling\n\nTemperature is a hyperparameter that controls randomness in neural network outputs. Temperature decay schedules gradually reduce temperature during training to transition from exploration to exploitation.\n\n#### What is Temperature?\n\n**Temperature (T)** scales logits before applying softmax:\n\n$$\nP(y_i) = \\frac{e^{z_i/\\tau}}{\\sum_j e^{z_j/\\tau}}\n$$\n\nWhere:\n- $z_i$ = logits (raw model outputs)\n- $\\tau$ = temperature\n- $P(y_i)$ = probability of class $i$\n\n**Effect of temperature**:\n- **High temperature (T > 1)**: More uniform distribution, more randomness\n- **Low temperature (T < 1)**: Peaked distribution, more deterministic\n- **T = 1**: Standard softmax (no scaling)\n\n#### Temperature Decay Schedules\n\n**1. Linear Decay**\n\n$$\n\\tau(t) = \\tau_{\\text{initial}} - (\\tau_{\\text{initial}} - \\tau_{\\text{final}}) \\cdot \\frac{t}{T}\n$$\n\nWhere:\n- $t$ = current step\n- $T$ = total steps\n\n**Properties**:\n- Constant decay rate\n- Predictable progression\n- Simple to implement\n\n**Example**: $\\tau_{\\text{initial}} = 2.0$, $\\tau_{\\text{final}} = 0.1$, $t = 500$, $T = 1000$\n\n$$\n\\tau(500) = 2.0 - (2.0 - 0.1) \\cdot 0.5 = 2.0 - 0.95 = 1.05\n$$\n\n**2. Exponential Decay**\n\n$$\n\\tau(t) = \\max(\\tau_{\\text{initial}} \\cdot \\gamma^t, \\tau_{\\text{final}})\n$$\n\nWhere $\\gamma$ is the decay rate (e.g., 0.99)\n\n**Properties**:\n- Fast initial decay\n- Slow later decay\n- Needs minimum temperature (floor)\n\n**Example**: $\\tau_{\\text{initial}} = 1.0$, $\\gamma = 0.99$, $t = 100$\n\n$$\n\\tau(100) = 1.0 \\times 0.99^{100} \\approx 0.366\n$$\n\n**3. Cosine Annealing**\n\n$$\n\\tau(t) = \\tau_{\\text{final}} + \\frac{1}{2}(\\tau_{\\text{initial}} - \\tau_{\\text{final}}) \\left(1 + \\cos\\left(\\frac{\\pi t}{T}\\right)\\right)\n$$\n\n**Properties**:\n- Smooth decay\n- Slow at start and end\n- Fast in middle\n- SOTA in many applications\n\n**Example**: $\\tau_{\\text{initial}} = 2.0$, $\\tau_{\\text{final}} = 0.0$, $t = 500$, $T = 1000$\n\nProgress: $\\frac{500}{1000} = 0.5$\n\n$$\n\\cos(\\pi \\cdot 0.5) = \\cos\\left(\\frac{\\pi}{2}\\right) = 0\n$$\n\n$$\n\\tau(500) = 0.0 + \\frac{1}{2}(2.0 - 0.0)(1 + 0) = 1.0\n$$\n\n**4. Constant (No Decay)**\n\n$$\n\\tau(t) = \\tau_{\\text{initial}} \\quad \\forall t\n$$\n\nUsed as baseline or when temperature is not critical.\n\n#### Applications\n\n**1. Text Generation**\n\nControl diversity in language model outputs.\n\n**Example logits**: [2.0, 1.0, 0.5] for three tokens\n\n**Temperature = 0.1** (low, deterministic):\n- Probabilities: [99.995%, 0.005%, 0.0%]\n- Nearly always picks highest logit\n- Use: Factual question answering\n\n**Temperature = 2.0** (high, random):\n- Probabilities: [48%, 29%, 23%]\n- More uniform distribution\n- Use: Creative writing, brainstorming\n\n**Decay schedule**: Start with T=2.0 for exploration, decay to T=0.5 for quality.\n\n**2. Gumbel-Softmax**\n\nEnables gradient-based learning with discrete latent variables.\n\n**Standard problem**: Discrete sampling is non-differentiable\n\n**Gumbel-Softmax trick**:\n$$\ny_i = \\frac{\\exp((\\log(\\pi_i) + g_i)/\\tau)}{\\sum_j \\exp((\\log(\\pi_j) + g_j)/\\tau)}\n$$\n\nWhere $g_i$ is Gumbel noise: $g = -\\log(-\\log(u))$, $u \\sim \\text{Uniform}(0,1)$\n\n**Temperature decay**:\n- **Start high (T=5.0)**: Soft, gradients flow easily\n- **Decay**: Gradually become more discrete\n- **End low (T=0.1)**: Nearly one-hot, behaves like discrete sample\n\n**Use cases**:\n- Variational Autoencoders (VAEs) with discrete latents\n- Neural architecture search\n- Discrete bottleneck layers\n\n**3. Reinforcement Learning**\n\nBoltzmann exploration policy:\n\n$$\n\\pi(a|s) = \\frac{\\exp(Q(s,a)/\\tau)}{\\sum_{a'} \\exp(Q(s,a')/\\tau)}\n$$\n\n**Temperature decay**:\n- **Early training (T=2.0)**: High exploration, try many actions\n- **Mid training (T=1.0)**: Balanced exploration-exploitation\n- **Late training (T=0.1)**: Exploitation, near-greedy policy\n\n**Example Q-values**: [0.8, 0.5, 0.3, 0.1]\n\n**Temperature = 2.0** (explore):\n- Action probs: [0.30, 0.26, 0.23, 0.21]\n- Fairly uniform, tries all actions\n\n**Temperature = 0.1** (exploit):\n- Action probs: [0.92, 0.05, 0.02, 0.01]\n- Strongly prefers best action\n\n**4. Knowledge Distillation**\n\nStudent network learns from teacher's soft targets.\n\n**Hard labels**: [0, 0, 1, 0] - only target class\n\n**Soft targets** (teacher with T=3):\n- Logits: [5.0, 2.0, 6.0, 1.0]\n- Soft probs: [0.22, 0.03, 0.73, 0.01]\n- Reveals: Class 3 is best, class 1 is similar, class 2 is dissimilar\n\n**Benefits of high temperature**:\n- Preserves relative relationships between classes\n- Student learns richer representation\n- Improved generalization\n\n**Typical approach**: Use T=3-10 during distillation, T=1 for final predictions\n\n#### Choosing a Schedule\n\n**Linear**:\n- Use when: Fixed training duration, simple baseline\n- Pros: Predictable, easy to understand\n- Cons: May be too aggressive early or too slow late\n\n**Exponential**:\n- Use when: Want fast initial decay\n- Pros: Quick early adaptation\n- Cons: Can decay too fast, may hit floor early\n\n**Cosine**:\n- Use when: General purpose, SOTA approach\n- Pros: Smooth, well-balanced, widely successful\n- Cons: Slightly more complex\n\n**Constant**:\n- Use when: Temperature not critical, baseline comparison\n- Pros: No tuning needed\n- Cons: No adaptation\n\n#### Schedule Comparison\n\nTraining for 1000 steps, T_initial=2.0, T_final=0.1\n\n| Step | Linear | Exponential (γ=0.995) | Cosine | Constant |\n|------|--------|----------------------|--------|----------|\n| 0 | 2.00 | 2.00 | 2.00 | 2.00 |\n| 250 | 1.53 | 0.57 | 1.72 | 2.00 |\n| 500 | 1.05 | 0.16 | 1.05 | 2.00 |\n| 750 | 0.58 | 0.05 | 0.38 | 2.00 |\n| 1000 | 0.10 | 0.01 | 0.10 | 2.00 |\n\n**Observations**:\n- Exponential decays fastest (may be too aggressive)\n- Linear is steady and predictable\n- Cosine is smooth with slow start/end\n- Constant provides upper bound baseline\n\n#### Implementation Considerations\n\n**1. Minimum Temperature**\n\nAlways enforce a floor to prevent numerical issues:\n\n$$\n\\tau(t) = \\max(\\tau_{\\text{computed}}, \\tau_{\\text{min}})\n$$\n\nTypical $\\tau_{\\text{min}} = 0.01$ to avoid division by zero.\n\n**2. Step vs Epoch**\n\nCan decay per step or per epoch:\n- **Per step**: Smoother, more gradual\n- **Per epoch**: Coarser, easier to track\n\n**3. Warmup Period**\n\nSometimes keep temperature constant initially:\n- First 10% of training: T = T_initial\n- Remaining 90%: Apply decay schedule\n\n**4. Cyclic Schedules**\n\nRestart temperature periodically (less common):\n- Can help escape local minima\n- Used in some adversarial training\n\n#### Practical Training Example\n\n**Task**: Train discrete VAE with Gumbel-Softmax\n\n**Setup**:\n- Total steps: 100,000 (100 epochs × 1000 steps)\n- Schedule: Cosine annealing\n- T_initial: 2.0 (soft, easy gradients)\n- T_final: 0.1 (discrete, realistic samples)\n\n**Temperature at key points**:\n- Step 0 (Epoch 0): T = 2.00 - Very soft\n- Step 25,000 (Epoch 25): T = 1.72 - Still exploratory  \n- Step 50,000 (Epoch 50): T = 1.05 - Transitioning\n- Step 75,000 (Epoch 75): T = 0.38 - Getting discrete\n- Step 100,000 (Epoch 100): T = 0.10 - Nearly discrete\n\n**Benefits**:\n- Early: Soft samples, stable gradients, wide exploration\n- Middle: Balanced, learning meaningful patterns\n- Late: Discrete samples, realistic outputs\n\n#### Common Pitfalls\n\n**1. Decaying too fast**: Model doesn't explore enough\n- Solution: Use slower schedule (cosine) or higher decay rate\n\n**2. Decaying too slow**: Never reaches exploitation\n- Solution: Ensure final temperature is low enough (< 0.5)\n\n**3. No minimum temperature**: Numerical instability\n- Solution: Always enforce T_min (e.g., 0.01)\n\n**4. Wrong schedule for task**: Linear may be too simple\n- Solution: Try cosine as default, tune if needed\n\n#### Summary\n\n**Temperature decay schedules**:\n- Linear: $\\tau(t) = \\tau_0 - (\\tau_0 - \\tau_f) \\cdot t/T$\n- Exponential: $\\tau(t) = \\tau_0 \\cdot \\gamma^t$\n- Cosine: $\\tau(t) = \\tau_f + \\frac{1}{2}(\\tau_0 - \\tau_f)(1 + \\cos(\\pi t/T))$\n- Constant: $\\tau(t) = \\tau_0$\n\n**Key applications**: Text generation, Gumbel-Softmax, RL exploration, knowledge distillation\n\n**General advice**: Start with cosine annealing (T_initial=2.0, T_final=0.1), adjust based on task\n\n**Goal**: Smooth transition from exploration (high T) to exploitation (low T)"
}