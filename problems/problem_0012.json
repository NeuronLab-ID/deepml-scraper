{
  "learn_section": "IyMgRGVyaXZpbmcgU1ZEIGZvciBhIDJ4MiBNYXRyaXgKClRoZSBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIChTVkQpIHJld3JpdGVzIGFueSByZWFsIG1hdHJpeCAkQSBcaW4gXG1hdGhiYntSfV57bSBcdGltZXMgbn0kIGFzOgoKJCRBID0gVSBcU2lnbWEgVl5UJCQKCndoZXJlOgotICRVIFxpbiBcbWF0aGJie1J9XnttIFx0aW1lcyBtfSQgaXMgb3J0aG9nb25hbCAoJFVeVCBVID0gSSQpCi0gJFYgXGluIFxtYXRoYmJ7Un1ee24gXHRpbWVzIG59JCBpcyBvcnRob2dvbmFsICgkVl5UIFYgPSBJJCkKLSAkXFNpZ21hJCBpcyBkaWFnb25hbCB3aXRoIG5vbi1uZWdhdGl2ZSAqKnNpbmd1bGFyIHZhbHVlcyoqICRcc2lnbWFfMSBcZ2VxIFxzaWdtYV8yIFxnZXEgXGNkb3RzIFxnZXEgMCQKCkZvciBhIDJ4MiBtYXRyaXgsIHdlIGNhbiBjb21wdXRlIHRoaXMgYW5hbHl0aWNhbGx5IHdpdGggYSBzaW5nbGUgSmFjb2JpIHJvdGF0aW9uLgoKIyMjIFN0ZXAgMTogRm9ybSB0aGUgU3ltbWV0cmljIE1hdHJpeCAkQV5UIEEkCgpTaW5jZSAkQV5UIEEgPSBWIFxTaWdtYV5UIFxTaWdtYSBWXlQkLCB0aGUgZWlnZW52ZWN0b3JzIG9mICRBXlQgQSQgYXJlIHRoZSBjb2x1bW5zIG9mICRWJCwgYW5kIHRoZSBlaWdlbnZhbHVlcyBhcmUgJFxzaWdtYV9pXjIkLgoKRm9yIGEgMngyIG1hdHJpeDoKJCRBXlQgQSA9IFxiZWdpbntibWF0cml4fSBhX3sxMX1eMiArIGFfezIxfV4yICYgYV97MTF9YV97MTJ9ICsgYV97MjF9YV97MjJ9IFxcIGFfezExfWFfezEyfSArIGFfezIxfWFfezIyfSAmIGFfezEyfV4yICsgYV97MjJ9XjIgXGVuZHtibWF0cml4fSQkCgojIyMgU3RlcCAyOiBKYWNvYmkgUm90YXRpb24KClRvIGRpYWdvbmFsaXplIHRoaXMgc3ltbWV0cmljIG1hdHJpeCwgd2UgZmluZCBhIHJvdGF0aW9uIGFuZ2xlICRcdGhldGEkIHN1Y2ggdGhhdCAkUl5UIChBXlQgQSkgUiQgaXMgZGlhZ29uYWw6CgokJFIoXHRoZXRhKSA9IFxiZWdpbntibWF0cml4fSBcY29zXHRoZXRhICYgLVxzaW5cdGhldGEgXFwgXHNpblx0aGV0YSAmIFxjb3NcdGhldGEgXGVuZHtibWF0cml4fSQkCgpUaGUgb3B0aW1hbCBhbmdsZSBpczoKJCRcdGhldGEgPSBcYmVnaW57Y2FzZXN9IFxmcmFje1xwaX17NH0gJiBcdGV4dHtpZiB9IEJfezExfSA9IEJfezIyfSBcXCBcZnJhY3sxfXsyfSBcYXJjdGFuXGxlZnQoXGZyYWN7MkJfezEyfX17Ql97MTF9IC0gQl97MjJ9fVxyaWdodCkgJiBcdGV4dHtvdGhlcndpc2V9IFxlbmR7Y2FzZXN9JCQKCndoZXJlICRCID0gQV5UIEEkLgoKIyMjIFN0ZXAgMzogRXh0cmFjdCBTaW5ndWxhciBWYWx1ZXMKCkFmdGVyIHJvdGF0aW9uLCB0aGUgZGlhZ29uYWwgbWF0cml4ICREID0gUl5UIChBXlQgQSkgUiQgY29udGFpbnMgZWlnZW52YWx1ZXMgJFxsYW1iZGFfMSwgXGxhbWJkYV8yJC4KClNpbmd1bGFyIHZhbHVlcyBhcmU6ICRcc2lnbWFfaSA9IFxzcXJ0e1xsYW1iZGFfaX0kCgojIyMgU3RlcCA0OiBDb21wdXRlIFUKCldpdGggJFYgPSBSJCwgY29tcHV0ZToKJCRVID0gQSBWIFxTaWdtYV57LTF9JCQKCndoZXJlICRcU2lnbWFeey0xfSA9IFx0ZXh0e2RpYWd9KDEvXHNpZ21hXzEsIDEvXHNpZ21hXzIpJC4KCiMjIyBXaHkgT25lIFJvdGF0aW9uIFN1ZmZpY2VzCgpGb3IgYSAyw5cyIHN5bW1ldHJpYyBtYXRyaXgsIGEgc2luZ2xlIEphY29iaSByb3RhdGlvbiBleGFjdGx5IHplcm9zIHRoZSBvZmYtZGlhZ29uYWwgZWxlbWVudHMuIExhcmdlciBtYXRyaWNlcyByZXF1aXJlIGl0ZXJhdGl2ZSByb3RhdGlvbnMuCgojIyMgTnVtZXJpY2FsIENvbnNpZGVyYXRpb25zCgotIEhhbmRsZSAkXHNpZ21hX2kgXGFwcHJveCAwJCBjYXJlZnVsbHkgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVybwotIFRoZSBzaWducyBvZiBVIGFuZCBWIGNvbHVtbnMgY2FuIHZhcnkgKGJvdGggJHVfaSQgYW5kICQtdV9pJCBhcmUgdmFsaWQgc2luZ3VsYXIgdmVjdG9ycykK",
  "description": "V3JpdGUgYSBQeXRob24gZnVuY3Rpb24gdGhhdCBjb21wdXRlcyBhbiBhcHByb3hpbWF0ZSBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIChTVkQpIG9mIGEgcmVhbCAyw5cyIG1hdHJpeCB1c2luZyBvbmUgSmFjb2JpIHJvdGF0aW9uLgoKKipJbnB1dDoqKgotIGBBYDogYSBOdW1QeSBhcnJheSBvZiBzaGFwZSAoMiwgMikKCioqUnVsZXM6KioKLSBZb3UgbWF5IHVzZSBiYXNpYyBOdW1QeSBvcGVyYXRpb25zIChtYXRyaXggbXVsdGlwbGljYXRpb24sIHRyYW5zcG9zZSwgZWxlbWVudC13aXNlIG1hdGgsIGV0Yy4pCi0gRG8gTk9UIGNhbGwgYG51bXB5LmxpbmFsZy5zdmRgIG9yIGFueSBvdGhlciBoaWdoLWxldmVsIFNWRCByb3V0aW5lCi0gVXNlIGEgc2luZ2xlIEphY29iaSByb3RhdGlvbiBzdGVwIChubyBpdGVyYXRpdmUgcmVmaW5lbWVudHMpCgoqKlJldHVybjoqKgpBIHR1cGxlIGAoVSwgUywgVnQpYCB3aGVyZToKLSBgVWAgaXMgYSAyw5cyIG9ydGhvZ29uYWwgbWF0cml4IChsZWZ0IHNpbmd1bGFyIHZlY3RvcnMpCi0gYFNgIGlzIGEgbGVuZ3RoLTIgTnVtUHkgYXJyYXkgY29udGFpbmluZyB0aGUgc2luZ3VsYXIgdmFsdWVzCi0gYFZ0YCBpcyB0aGUgdHJhbnNwb3NlIG9mIHRoZSByaWdodCBzaW5ndWxhciB2ZWN0b3IgbWF0cml4IFYKClRoZSBkZWNvbXBvc2l0aW9uIHNob3VsZCBzYXRpc2Z5OiBBIOKJiCBVIEAgZGlhZyhTKSBAIFZ0",
  "mdx_file": "81ae5461-af60-471a-97d1-ddd4b26ddbae.mdx",
  "id": "12",
  "test_cases": [
    {
      "test": "U, S, Vt = svd_2x2_singular_values(np.array([[2, 1], [1, 2]]))\nprint(f'S: {np.round(S, 4).tolist()}')",
      "expected_output": "S: [3.0, 1.0]"
    },
    {
      "test": "U, S, Vt = svd_2x2_singular_values(np.array([[1, 2], [3, 4]]))\nprint(f'S: {np.round(S, 4).tolist()}')",
      "expected_output": "S: [5.465, 0.366]"
    }
  ],
  "difficulty": "hard",
  "pytorch_difficulty": "medium",
  "video": "",
  "cuda_difficulty": "hard",
  "likes": "0",
  "cuda_test_cases": [
    {
      "test": "#include <iostream>\n#include <vector>\nstruct SVDResult { std::vector<std::vector<float>> U; std::vector<float> S; std::vector<std::vector<float>> Vt; };\nSVDResult svd_2x2(const std::vector<std::vector<float>>& A);\nint main() {\n    auto result = svd_2x2({{2,1},{1,2}});\n    std::cout << \"S: [\" << result.S[0] << \", \" << result.S[1] << \"]\" << std::endl;\n    return 0;\n}",
      "expected_output": "S: [3, 1]"
    }
  ],
  "dislikes": "0",
  "example": {
    "input": "A = np.array([[2, 1], [1, 2]])",
    "output": "U ≈ [[0.707, -0.707], [0.707, 0.707]]\nS = [3.0, 1.0]\nVt ≈ [[0.707, 0.707], [-0.707, 0.707]]",
    "reasoning": "The symmetric matrix [[2,1],[1,2]] has eigenvalues 3 and 1. Since it's symmetric, the SVD simplifies: the singular values equal the absolute eigenvalues, and U, V are related to the eigenvectors. The decomposition satisfies A = U @ diag(S) @ Vt."
  },
  "category": "Linear Algebra",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCgpkZWYgc3ZkXzJ4Ml9zaW5ndWxhcl92YWx1ZXMoQTogdG9yY2guVGVuc29yKSAtPiB0dXBsZVt0b3JjaC5UZW5zb3IsIHRvcmNoLlRlbnNvciwgdG9yY2guVGVuc29yXToKICAgICIiIgogICAgQ29tcHV0ZSBTVkQgb2YgYSAyeDIgbWF0cml4IHVzaW5nIG9uZSBKYWNvYmkgcm90YXRpb24uCiAgICAKICAgIEFyZ3M6CiAgICAgICAgQTogQSAyeDIgdG9yY2ggdGVuc29yCiAgICAKICAgIFJldHVybnM6CiAgICAgICAgVHVwbGUgKFUsIFMsIFZ0KSB3aGVyZSBBIOKJiCBVIEAgZGlhZyhTKSBAIFZ0CiAgICAiIiIKICAgICMgWW91ciBjb2RlIGhlcmUKICAgIHBhc3M=",
  "title": "Singular Value Decomposition (SVD) of 2x2 Matrix",
  "cuda_starter_code": "I2luY2x1ZGUgPGN1ZGFfcnVudGltZS5oPgojaW5jbHVkZSA8aW9zdHJlYW0+CiNpbmNsdWRlIDx2ZWN0b3I+CiNpbmNsdWRlIDxjbWF0aD4KCnN0cnVjdCBTVkRSZXN1bHQgewogICAgc3RkOjp2ZWN0b3I8c3RkOjp2ZWN0b3I8ZmxvYXQ+PiBVOwogICAgc3RkOjp2ZWN0b3I8ZmxvYXQ+IFM7CiAgICBzdGQ6OnZlY3RvcjxzdGQ6OnZlY3RvcjxmbG9hdD4+IFZ0Owp9OwoKX19nbG9iYWxfXyB2b2lkIHN2ZF8yeDJfa2VybmVsKGNvbnN0IGZsb2F0KiBBLCBmbG9hdCogVSwgZmxvYXQqIFMsIGZsb2F0KiBWdCkgewogICAgLy8gQ29tcHV0ZSBTVkQgdXNpbmcgb25lIEphY29iaSByb3RhdGlvbgp9CgpTVkRSZXN1bHQgc3ZkXzJ4Mihjb25zdCBzdGQ6OnZlY3RvcjxzdGQ6OnZlY3RvcjxmbG9hdD4+JiBBKSB7CiAgICByZXR1cm4ge307Cn0=",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "import torch\nU, S, Vt = svd_2x2_singular_values(torch.tensor([[2.0, 1.0], [1.0, 2.0]]))\nprint(f'S: {S.round().tolist()}')",
      "expected_output": "S: [3.0, 1.0]"
    },
    {
      "test": "import torch\n# Verify reconstruction\nA = torch.tensor([[1.0, 2.0], [3.0, 4.0]])\nU, S, Vt = svd_2x2_singular_values(A)\nA_rec = U @ torch.diag(S) @ Vt\nprint(f'Reconstruction error < 1e-5: {torch.max(torch.abs(A - A_rec)).item() < 1e-5}')",
      "expected_output": "Reconstruction error < 1e-5: True"
    },
    {
      "test": "import torch\n# Diagonal matrix\nU, S, Vt = svd_2x2_singular_values(torch.tensor([[3.0, 0.0], [0.0, 2.0]]))\nprint(f'S: {S.tolist()}')",
      "expected_output": "S: [3.0, 2.0]"
    }
  ],
  "starter_code": "import numpy as np\n\ndef svd_2x2_singular_values(A: np.ndarray) -> tuple:\n    \"\"\"\n    Compute SVD of a 2x2 matrix using one Jacobi rotation.\n    \n    Args:\n        A: A 2x2 numpy array\n    \n    Returns:\n        Tuple (U, S, Vt) where A ≈ U @ diag(S) @ Vt\n        - U: 2x2 orthogonal matrix\n        - S: length-2 array of singular values\n        - Vt: 2x2 orthogonal matrix (transpose of V)\n    \"\"\"\n    # Your code here\n    pass",
  "createdAt": "December 15, 2025 at 8:32:52 AM UTC-0500",
  "description_decoded": "Write a Python function that computes an approximate Singular Value Decomposition (SVD) of a real 2×2 matrix using one Jacobi rotation.\n\n**Input:**\n- `A`: a NumPy array of shape (2, 2)\n\n**Rules:**\n- You may use basic NumPy operations (matrix multiplication, transpose, element-wise math, etc.)\n- Do NOT call `numpy.linalg.svd` or any other high-level SVD routine\n- Use a single Jacobi rotation step (no iterative refinements)\n\n**Return:**\nA tuple `(U, S, Vt)` where:\n- `U` is a 2×2 orthogonal matrix (left singular vectors)\n- `S` is a length-2 NumPy array containing the singular values\n- `Vt` is the transpose of the right singular vector matrix V\n\nThe decomposition should satisfy: A ≈ U @ diag(S) @ Vt",
  "learn_section_decoded": "## Deriving SVD for a 2x2 Matrix\n\nThe Singular Value Decomposition (SVD) rewrites any real matrix $A \\in \\mathbb{R}^{m \\times n}$ as:\n\n$$A = U \\Sigma V^T$$\n\nwhere:\n- $U \\in \\mathbb{R}^{m \\times m}$ is orthogonal ($U^T U = I$)\n- $V \\in \\mathbb{R}^{n \\times n}$ is orthogonal ($V^T V = I$)\n- $\\Sigma$ is diagonal with non-negative **singular values** $\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq 0$\n\nFor a 2x2 matrix, we can compute this analytically with a single Jacobi rotation.\n\n### Step 1: Form the Symmetric Matrix $A^T A$\n\nSince $A^T A = V \\Sigma^T \\Sigma V^T$, the eigenvectors of $A^T A$ are the columns of $V$, and the eigenvalues are $\\sigma_i^2$.\n\nFor a 2x2 matrix:\n$$A^T A = \\begin{bmatrix} a_{11}^2 + a_{21}^2 & a_{11}a_{12} + a_{21}a_{22} \\\\ a_{11}a_{12} + a_{21}a_{22} & a_{12}^2 + a_{22}^2 \\end{bmatrix}$$\n\n### Step 2: Jacobi Rotation\n\nTo diagonalize this symmetric matrix, we find a rotation angle $\\theta$ such that $R^T (A^T A) R$ is diagonal:\n\n$$R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}$$\n\nThe optimal angle is:\n$$\\theta = \\begin{cases} \\frac{\\pi}{4} & \\text{if } B_{11} = B_{22} \\\\ \\frac{1}{2} \\arctan\\left(\\frac{2B_{12}}{B_{11} - B_{22}}\\right) & \\text{otherwise} \\end{cases}$$\n\nwhere $B = A^T A$.\n\n### Step 3: Extract Singular Values\n\nAfter rotation, the diagonal matrix $D = R^T (A^T A) R$ contains eigenvalues $\\lambda_1, \\lambda_2$.\n\nSingular values are: $\\sigma_i = \\sqrt{\\lambda_i}$\n\n### Step 4: Compute U\n\nWith $V = R$, compute:\n$$U = A V \\Sigma^{-1}$$\n\nwhere $\\Sigma^{-1} = \\text{diag}(1/\\sigma_1, 1/\\sigma_2)$.\n\n### Why One Rotation Suffices\n\nFor a 2×2 symmetric matrix, a single Jacobi rotation exactly zeros the off-diagonal elements. Larger matrices require iterative rotations.\n\n### Numerical Considerations\n\n- Handle $\\sigma_i \\approx 0$ carefully to avoid division by zero\n- The signs of U and V columns can vary (both $u_i$ and $-u_i$ are valid singular vectors)\n"
}