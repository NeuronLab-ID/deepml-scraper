{
  "description": "SW4gdGhpcyB0YXNrLCB5b3Ugd2lsbCB0cmFpbiBhIEdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29yayAoR0FOKSB0byBsZWFybiBhIG9uZS1kaW1lbnNpb25hbCBHYXVzc2lhbiBkaXN0cmlidXRpb24uIFRoZSBHQU4gY29uc2lzdHMgb2YgYSBnZW5lcmF0b3IgdGhhdCBwcm9kdWNlcyBzYW1wbGVzIGZyb20gbGF0ZW50IG5vaXNlIGFuZCBhIGRpc2NyaW1pbmF0b3IgdGhhdCBlc3RpbWF0ZXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSBnaXZlbiBzYW1wbGUgaXMgcmVhbC4gQm90aCBuZXR3b3JrcyBzaG91bGQgaGF2ZSBvbmUgaGlkZGVuIGxheWVyIHdpdGggUmVMVSBhY3RpdmF0aW9uIGluIHRoZSBoaWRkZW4gbGF5ZXIuIFRoZSBnZW5lcmF0b3LigJlzIG91dHB1dCBsYXllciBpcyBsaW5lYXIsIHdoaWxlIHRoZSBkaXNjcmltaW5hdG9yJ3Mgb3V0cHV0IGxheWVyIHVzZXMgYSBzaWdtb2lkIGFjdGl2YXRpb24uCgpZb3UgbXVzdCB0cmFpbiB0aGUgR0FOIHVzaW5nIHRoZSBzdGFuZGFyZCBub24tc2F0dXJhdGluZyBHQU4gbG9zcyBmb3IgdGhlIGdlbmVyYXRvciBhbmQgYmluYXJ5IGNyb3NzLWVudHJvcHkgbG9zcyBmb3IgdGhlIGRpc2NyaW1pbmF0b3IuIEluIHRoZSBOdW1QeSB2ZXJzaW9uLCBwYXJhbWV0ZXJzIHNob3VsZCBiZSB1cGRhdGVkIHVzaW5nIHZhbmlsbGEgZ3JhZGllbnQgZGVzY2VudC4gSW4gdGhlIFB5VG9yY2ggdmVyc2lvbiwgcGFyYW1ldGVycyBzaG91bGQgYmUgdXBkYXRlZCB1c2luZyBzdG9jaGFzdGljIGdyYWRpZW50IGRlc2NlbnQgKFNHRCkgd2l0aCB0aGUgc3BlY2lmaWVkIGxlYXJuaW5nIHJhdGUuIFRoZSB0cmFpbmluZyBsb29wIHNob3VsZCBhbHRlcm5hdGUgYmV0d2VlbiB1cGRhdGluZyB0aGUgZGlzY3JpbWluYXRvciBhbmQgdGhlIGdlbmVyYXRvciBlYWNoIGl0ZXJhdGlvbi4KCllvdXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gdGhlIHRyYWluZWQgZ2VuZXJhdG9yIGZvcndhcmQgZnVuY3Rpb24gYGdlbl9mb3J3YXJkKHopYCwgd2hpY2ggcHJvZHVjZXMgZ2VuZXJhdGVkIHNhbXBsZXMgZ2l2ZW4gbGF0ZW50IG5vaXNlLg==",
  "id": "174",
  "test_cases": [
    {
      "test": "gen_forward = train_gan(4.0, 1.25, epochs=1000, seed=42)\nz = np.random.normal(0, 1, (500, 1))\nx_gen, _, _ = gen_forward(z)\nprint((round(np.mean(x_gen), 4), round(np.std(x_gen), 4)))",
      "expected_output": "(0.0004, 0.0002)"
    },
    {
      "test": "gen_forward = train_gan(0.0, 1.0, epochs=500, seed=0)\nz = np.random.normal(0, 1, (300, 1))\nx_gen, _, _ = gen_forward(z)\nprint((round(np.mean(x_gen), 4), round(np.std(x_gen), 4)))",
      "expected_output": "(-0.0002, 0.0002)"
    }
  ],
  "difficulty": "hard",
  "pytorch_difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "gen_forward = train_gan(4.0, 1.25, epochs=1000, seed=42)\nz = np.random.normal(0, 1, (500, 1))\nx_gen, _, _ = gen_forward(z)\n(round(np.mean(x_gen), 4), round(np.std(x_gen), 4))",
    "output": "(0.0004, 0.0002)",
    "reasoning": "The test cases call `gen_forward` after training, sample 500 points, and then compute the mean and std."
  },
  "category": "Deep Learning",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCmltcG9ydCB0b3JjaC5ubiBhcyBubgppbXBvcnQgdG9yY2gub3B0aW0gYXMgb3B0aW0KCmRlZiB0cmFpbl9nYW4obWVhbl9yZWFsOiBmbG9hdCwgc3RkX3JlYWw6IGZsb2F0LCBsYXRlbnRfZGltOiBpbnQgPSAxLCBoaWRkZW5fZGltOiBpbnQgPSAxNiwgbGVhcm5pbmdfcmF0ZTogZmxvYXQgPSAwLjAwMSwgZXBvY2hzOiBpbnQgPSA1MDAwLCBiYXRjaF9zaXplOiBpbnQgPSAxMjgsIHNlZWQ6IGludCA9IDQyKToKICAgIHRvcmNoLm1hbnVhbF9zZWVkKHNlZWQpCiAgICAjIFlvdXIgUHlUb3JjaCBpbXBsZW1lbnRhdGlvbiBoZXJlCiAgICBwYXNz",
  "title": "Train a Simple GAN on 1D Gaussian Data",
  "createdAt": "August 13, 2025 at 11:01:53 AM UTUTC-4",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "moe"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "gen_forward = train_gan(4.0, 1.25, epochs=100, seed=42)\nz = torch.randn(500, 1)\nx_gen = gen_forward(z)\nprint((round(x_gen.mean().item(), 4), round(x_gen.std().item(), 4)))",
      "expected_output": "(0.4725, 0.3563)"
    },
    {
      "test": "gen_forward = train_gan(0.0, 1.0, epochs=50, seed=0)\nz = torch.randn(300, 1)\nx_gen = gen_forward(z)\nprint((round(x_gen.mean().item(), 4), round(x_gen.std().item(), 4)))",
      "expected_output": "(0.0644, 0.244)"
    }
  ],
  "learn_section": "IyMgVW5kZXJzdGFuZGluZyBHQU5zIGZvciAxRCBHYXVzc2lhbiBEYXRhCkEgR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrIChHQU4pIGNvbnNpc3RzIG9mIHR3byBuZXVyYWwgbmV0d29ya3MgLSBhICoqR2VuZXJhdG9yKiogJEdfXHRoZXRhJCBhbmQgYSAqKkRpc2NyaW1pbmF0b3IqKiAkRF9ccGhpJCAtIHRyYWluZWQgaW4gYSBtaW5pbWF4IGdhbWUuCgojIyMgMS4gVGhlIFJvbGVzCi0gKipHZW5lcmF0b3IqKiAkR19cdGhldGEoeikkOiBUYWtlcyBhIGxhdGVudCBub2lzZSB2ZWN0b3IgJHogXHNpbSBcbWF0aGNhbHtOfSgwLCBJKSQgYW5kIG91dHB1dHMgYSBzYW1wbGUgaW50ZW5kZWQgdG8gcmVzZW1ibGUgdGhlIHJlYWwgZGF0YS4KLSAqKkRpc2NyaW1pbmF0b3IqKiAkRF9ccGhpKHgpJDogT3V0cHV0cyBhIHByb2JhYmlsaXR5ICRwIFxpbiAoMCwgMSkkIHRoYXQgdGhlIGlucHV0ICR4JCBjYW1lIGZyb20gdGhlIHJlYWwgZGF0YSBkaXN0cmlidXRpb24gcmF0aGVyIHRoYW4gdGhlIGdlbmVyYXRvci4KCiMjIyAyLiBUaGUgT2JqZWN0aXZlClRoZSBjbGFzc2ljYWwgR0FOIG9iamVjdGl2ZSBpczoKJCQKXG1pbl97XHRoZXRhfSBcOyBcbWF4X3tccGhpfSBcOyBcbWF0aGJie0V9X3t4IFxzaW0gcF97XHRleHR7ZGF0YX19fSBbXGxvZyBEX1xwaGkoeCldICsgXG1hdGhiYntFfV97eiBcc2ltIHAoeil9IFtcbG9nICgxIC0gRF9ccGhpKEdfXHRoZXRhKHopKSldCiQkCkhlcmU6Ci0gJHBfe1x0ZXh0e2RhdGF9fSQgaXMgdGhlIHJlYWwgZGF0YSBkaXN0cmlidXRpb24uCi0gJHAoeikkIGlzIHRoZSBwcmlvciBkaXN0cmlidXRpb24gZm9yIHRoZSBsYXRlbnQgbm9pc2UgKG9mdGVuIHN0YW5kYXJkIG5vcm1hbCkuCgojIyMgMy4gUHJhY3RpY2FsIExvc3NlcwpJbiBpbXBsZW1lbnRhdGlvbiwgd2UgbWluaW1pemU6Ci0gKipEaXNjcmltaW5hdG9yIGxvc3MqKjoKJCQKXG1hdGhjYWx7TH1fRCA9IC0gXGxlZnQoIFxmcmFjezF9e219IFxzdW1fe2k9MX1ebSBcbG9nIEQoeF57KGkpfV97XHRleHR7cmVhbH19KSArIFxsb2coMSAtIEQoeF57KGkpfV97XHRleHR7ZmFrZX19KSkgXHJpZ2h0KQokJAotICoqR2VuZXJhdG9yIGxvc3MqKiAobm9uLXNhdHVyYXRpbmcgZm9ybSk6CiQkClxtYXRoY2Fse0x9X0cgPSAtIFxmcmFjezF9e219IFxzdW1fe2k9MX1ebSBcbG9nIEQoRyh6XnsoaSl9KSkKJCQKCiMjIyA0LiBGb3J3YXJkL0JhY2t3YXJkIEZsb3cKMS4gKipEaXNjcmltaW5hdG9yIHN0ZXAqKjogUmVhbCBzYW1wbGVzICR4X3tcdGV4dHtyZWFsfX0kIGFuZCBmYWtlIHNhbXBsZXMgJHhfe1x0ZXh0e2Zha2V9fSA9IEcoeikkIGFyZSBwYXNzZWQgdGhyb3VnaCAkRCQsIGFuZCAkXG1hdGhjYWx7TH1fRCQgaXMgbWluaW1pemVkIHcuci50LiAkXHBoaSQuCjIuICoqR2VuZXJhdG9yIHN0ZXAqKjogRnJlc2ggJHokIGlzIHNhbXBsZWQsICR4X3tcdGV4dHtmYWtlfX0gPSBHKHopJCBpcyBwYXNzZWQgdGhyb3VnaCAkRCQsIGFuZCAkXG1hdGhjYWx7TH1fRyQgaXMgbWluaW1pemVkIHcuci50LiAkXHRoZXRhJCB3aGlsZSBrZWVwaW5nICRccGhpJCBmaXhlZC4KCiMjIyA1LiBBcmNoaXRlY3R1cmUgZm9yIFRoaXMgVGFzawotICoqR2VuZXJhdG9yKio6IEZ1bGx5IGNvbm5lY3RlZCBsYXllciAoJFxtYXRoYmJ7Un1ee1x0ZXh0e2xhdGVudFxfZGltfX0gXHRvIFxtYXRoYmJ7Un1ee1x0ZXh0e2hpZGRlblxfZGltfX0kKSAtPiBSZUxVIC0+IEZ1bGx5IGNvbm5lY3RlZCBsYXllciAoJFxtYXRoYmJ7Un1ee1x0ZXh0e2hpZGRlblxfZGltfX0gXHRvIFxtYXRoYmJ7Un1eMSQpLgotICoqRGlzY3JpbWluYXRvcioqOiBGdWxseSBjb25uZWN0ZWQgbGF5ZXIgKCRcbWF0aGJie1J9XjEgXHRvIFxtYXRoYmJ7Un1ee1x0ZXh0e2hpZGRlblxfZGltfX0kKSDihpIgUmVMVSDihpIgRnVsbHkgY29ubmVjdGVkIGxheWVyICgkXG1hdGhiYntSfV57XHRleHR7aGlkZGVuXF9kaW19fSBcdG8gXG1hdGhiYntSfV4xJCkg4oaSIFNpZ21vaWQuCgojIyMgNi4gTnVtZXJpY2FsIFRpcHMKLSBJbml0aWFsaXplIHdlaWdodHMgd2l0aCBhIHNtYWxsIEdhdXNzaWFuICgkXG1hdGhjYWx7Tn0oMCwgMC4wMSkkKS4KLSBBZGQgJDEwXnstOH0kIHRvIGxvZ3MgZm9yIG51bWVyaWNhbCBzdGFiaWxpdHkuCi0gVXNlIGEgY29uc2lzdGVudCBiYXRjaCBzaXplICRtJCBmb3IgYm90aCByZWFsIGFuZCBmYWtlIHNhbXBsZXMuCi0gQWx3YXlzIHNhbXBsZSBmcmVzaCBub2lzZSBmb3IgdGhlIGdlbmVyYXRvciBvbiBlYWNoIHVwZGF0ZS4KCioqWW91ciBUYXNrKio6IEltcGxlbWVudCB0aGUgdHJhaW5pbmcgbG9vcCB0byBsZWFybiB0aGUgcGFyYW1ldGVycyAkXHRoZXRhJCBhbmQgJFxwaGkkLCBhbmQgcmV0dXJuIHRoZSB0cmFpbmVkIGBnZW5fZm9yd2FyZCh6KWAgZnVuY3Rpb24uIFRoZSBldmFsdWF0aW9uIChtZWFuL3N0ZCBvZiBnZW5lcmF0ZWQgc2FtcGxlcykgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB0ZXN0IGNhc2VzLg==",
  "starter_code": "import numpy as np\n\ndef train_gan(mean_real: float, std_real: float, latent_dim: int = 1, hidden_dim: int = 16, learning_rate: float = 0.001, epochs: int = 5000, batch_size: int = 128, seed: int = 42):\n    \"\"\"\n    Train a simple GAN to learn a 1D Gaussian distribution.\n\n    Args:\n        mean_real: Mean of the target Gaussian\n        std_real: Std of the target Gaussian\n        latent_dim: Dimension of the noise input to the generator\n        hidden_dim: Hidden layer size for both networks\n        learning_rate: Learning rate for gradient descent\n        epochs: Number of training epochs\n        batch_size: Training batch size\n        seed: Random seed for reproducibility\n\n    Returns:\n        gen_forward: A function that takes z and returns generated samples\n    \"\"\"\n    # Your code here\n    pass",
  "description_decoded": "In this task, you will train a Generative Adversarial Network (GAN) to learn a one-dimensional Gaussian distribution. The GAN consists of a generator that produces samples from latent noise and a discriminator that estimates the probability that a given sample is real. Both networks should have one hidden layer with ReLU activation in the hidden layer. The generator’s output layer is linear, while the discriminator's output layer uses a sigmoid activation.\n\nYou must train the GAN using the standard non-saturating GAN loss for the generator and binary cross-entropy loss for the discriminator. In the NumPy version, parameters should be updated using vanilla gradient descent. In the PyTorch version, parameters should be updated using stochastic gradient descent (SGD) with the specified learning rate. The training loop should alternate between updating the discriminator and the generator each iteration.\n\nYour function must return the trained generator forward function `gen_forward(z)`, which produces generated samples given latent noise.",
  "learn_section_decoded": "## Understanding GANs for 1D Gaussian Data\nA Generative Adversarial Network (GAN) consists of two neural networks - a **Generator** $G_\\theta$ and a **Discriminator** $D_\\phi$ - trained in a minimax game.\n\n### 1. The Roles\n- **Generator** $G_\\theta(z)$: Takes a latent noise vector $z \\sim \\mathcal{N}(0, I)$ and outputs a sample intended to resemble the real data.\n- **Discriminator** $D_\\phi(x)$: Outputs a probability $p \\in (0, 1)$ that the input $x$ came from the real data distribution rather than the generator.\n\n### 2. The Objective\nThe classical GAN objective is:\n$$\n\\min_{\\theta} \\; \\max_{\\phi} \\; \\mathbb{E}_{x \\sim p_{\\text{data}}} [\\log D_\\phi(x)] + \\mathbb{E}_{z \\sim p(z)} [\\log (1 - D_\\phi(G_\\theta(z)))]\n$$\nHere:\n- $p_{\\text{data}}$ is the real data distribution.\n- $p(z)$ is the prior distribution for the latent noise (often standard normal).\n\n### 3. Practical Losses\nIn implementation, we minimize:\n- **Discriminator loss**:\n$$\n\\mathcal{L}_D = - \\left( \\frac{1}{m} \\sum_{i=1}^m \\log D(x^{(i)}_{\\text{real}}) + \\log(1 - D(x^{(i)}_{\\text{fake}})) \\right)\n$$\n- **Generator loss** (non-saturating form):\n$$\n\\mathcal{L}_G = - \\frac{1}{m} \\sum_{i=1}^m \\log D(G(z^{(i)}))\n$$\n\n### 4. Forward/Backward Flow\n1. **Discriminator step**: Real samples $x_{\\text{real}}$ and fake samples $x_{\\text{fake}} = G(z)$ are passed through $D$, and $\\mathcal{L}_D$ is minimized w.r.t. $\\phi$.\n2. **Generator step**: Fresh $z$ is sampled, $x_{\\text{fake}} = G(z)$ is passed through $D$, and $\\mathcal{L}_G$ is minimized w.r.t. $\\theta$ while keeping $\\phi$ fixed.\n\n### 5. Architecture for This Task\n- **Generator**: Fully connected layer ($\\mathbb{R}^{\\text{latent\\_dim}} \\to \\mathbb{R}^{\\text{hidden\\_dim}}$) -> ReLU -> Fully connected layer ($\\mathbb{R}^{\\text{hidden\\_dim}} \\to \\mathbb{R}^1$).\n- **Discriminator**: Fully connected layer ($\\mathbb{R}^1 \\to \\mathbb{R}^{\\text{hidden\\_dim}}$) → ReLU → Fully connected layer ($\\mathbb{R}^{\\text{hidden\\_dim}} \\to \\mathbb{R}^1$) → Sigmoid.\n\n### 6. Numerical Tips\n- Initialize weights with a small Gaussian ($\\mathcal{N}(0, 0.01)$).\n- Add $10^{-8}$ to logs for numerical stability.\n- Use a consistent batch size $m$ for both real and fake samples.\n- Always sample fresh noise for the generator on each update.\n\n**Your Task**: Implement the training loop to learn the parameters $\\theta$ and $\\phi$, and return the trained `gen_forward(z)` function. The evaluation (mean/std of generated samples) will be handled in the test cases."
}