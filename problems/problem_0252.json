{
  "description": "SW4gcHJvZHVjdGlvbiBNTCBzeXN0ZW1zLCBkYXRhIHF1YWxpdHkgaXMgY3JpdGljYWwgZm9yIG1vZGVsIHBlcmZvcm1hbmNlLiBQb29yIHF1YWxpdHkgZGF0YSBjYW4gbGVhZCB0byBtb2RlbCBkZWdyYWRhdGlvbiwgYmlhc2VkIHByZWRpY3Rpb25zLCBhbmQgc3lzdGVtIGZhaWx1cmVzLiBZb3UgbmVlZCB0byBpbXBsZW1lbnQgYSBkYXRhIHF1YWxpdHkgc2NvcmluZyBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyBpbmNvbWluZyBkYXRhIGFnYWluc3QgYSBkZWZpbmVkIHNjaGVtYS4KCkdpdmVuIGEgbGlzdCBvZiBkYXRhIHJlY29yZHMgKGRpY3Rpb25hcmllcykgYW5kIGEgc2NoZW1hIGRlZmluaXRpb24sIGNvbXB1dGUgdGhlIGZvbGxvd2luZyBxdWFsaXR5IG1ldHJpY3M6CgoxLiAqKkNvbXBsZXRlbmVzcyoqOiBQZXJjZW50YWdlIG9mIG5vbi1udWxsIHZhbHVlcyBhY3Jvc3MgYWxsIGV4cGVjdGVkIGZpZWxkcwoyLiAqKlR5cGUgVmFsaWRpdHkqKjogUGVyY2VudGFnZSBvZiB2YWx1ZXMgdGhhdCBtYXRjaCB0aGVpciBleHBlY3RlZCBkYXRhIHR5cGVzIChpbmNsdWRpbmcgbnVsbCBoYW5kbGluZyBiYXNlZCBvbiBudWxsYWJsZSBmbGFnKQozLiAqKlVuaXF1ZW5lc3MgUmF0aW8qKjogUGVyY2VudGFnZSBvZiB1bmlxdWUgcmVjb3JkcyBpbiB0aGUgZGF0YXNldAo0LiAqKk92ZXJhbGwgU2NvcmUqKjogV2VpZ2h0ZWQgY29tYmluYXRpb24gb2YgbWV0cmljcyAoNDAlIGNvbXBsZXRlbmVzcywgNDAlIHR5cGUgdmFsaWRpdHksIDIwJSB1bmlxdWVuZXNzKQoKVGhlIHNjaGVtYSBpcyBhIGRpY3Rpb25hcnkgd2hlcmUgZWFjaCBrZXkgaXMgYSBjb2x1bW4gbmFtZSBhbmQgdGhlIHZhbHVlIGlzIGEgc3BlY2lmaWNhdGlvbiB3aXRoOgotICd0eXBlJzogT25lIG9mICdudW1lcmljJywgJ2NhdGVnb3JpY2FsJywgb3IgJ2Jvb2xlYW4nCi0gJ251bGxhYmxlJzogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIG51bGwgdmFsdWVzIGFyZSBhY2NlcHRhYmxlCgpGb3IgdHlwZSB2YWxpZGl0eToKLSBOdW1lcmljIHR5cGUgYWNjZXB0cyBpbnQgYW5kIGZsb2F0IChidXQgbm90IGJvb2xlYW4pCi0gQ2F0ZWdvcmljYWwgdHlwZSBhY2NlcHRzIHN0cmluZ3MKLSBCb29sZWFuIHR5cGUgYWNjZXB0cyBUcnVlL0ZhbHNlIG9ubHkKLSBJZiBhIHZhbHVlIGlzIE5vbmUgYW5kIHRoZSBmaWVsZCBpcyBudWxsYWJsZSwgaXQgY291bnRzIGFzIHR5cGUtdmFsaWQKLSBJZiBhIHZhbHVlIGlzIE5vbmUgYW5kIHRoZSBmaWVsZCBpcyBub3QgbnVsbGFibGUsIGl0IGNvdW50cyBhcyB0eXBlLWludmFsaWQKCldyaXRlIGEgZnVuY3Rpb24gYGNhbGN1bGF0ZV9kYXRhX3F1YWxpdHlfc2NvcmUoZGF0YSwgc2NoZW1hKWAgdGhhdCByZXR1cm5zIGEgZGljdGlvbmFyeSB3aXRoIGFsbCBmb3VyIG1ldHJpY3MuIFJldHVybiBhbiBlbXB0eSBkaWN0aW9uYXJ5IGlmIHRoZSBpbnB1dCBkYXRhIGlzIGVtcHR5LiBBbGwgdmFsdWVzIHNob3VsZCBiZSByb3VuZGVkIHRvIDIgZGVjaW1hbCBwbGFjZXMu",
  "id": "252",
  "test_cases": [
    {
      "test": "print(calculate_data_quality_score([{'age': 25, 'name': 'Alice', 'active': True}, {'age': 30, 'name': 'Bob', 'active': False}, {'age': 35, 'name': 'Charlie', 'active': True}], {'age': {'type': 'numeric', 'nullable': False}, 'name': {'type': 'categorical', 'nullable': False}, 'active': {'type': 'boolean', 'nullable': False}}))",
      "expected_output": "{'completeness': 100.0, 'type_validity': 100.0, 'uniqueness_ratio': 100.0, 'overall_score': 100.0}"
    },
    {
      "test": "print(calculate_data_quality_score([{'age': 25, 'name': 'Alice', 'active': True}, {'age': 'thirty', 'name': 'Bob', 'active': False}, {'age': None, 'name': None, 'active': True}, {'age': 40, 'name': 'Dave', 'active': 'yes'}], {'age': {'type': 'numeric', 'nullable': True}, 'name': {'type': 'categorical', 'nullable': True}, 'active': {'type': 'boolean', 'nullable': False}}))",
      "expected_output": "{'completeness': 83.33, 'type_validity': 83.33, 'uniqueness_ratio': 100.0, 'overall_score': 86.67}"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "data = [{'age': 25, 'name': 'Alice', 'active': True}, {'age': 'thirty', 'name': 'Bob', 'active': False}, {'age': None, 'name': None, 'active': True}, {'age': 40, 'name': 'Dave', 'active': 'yes'}], schema = {'age': {'type': 'numeric', 'nullable': True}, 'name': {'type': 'categorical', 'nullable': True}, 'active': {'type': 'boolean', 'nullable': False}}",
    "output": "{'completeness': 83.33, 'type_validity': 83.33, 'uniqueness_ratio': 100.0, 'overall_score': 86.67}",
    "reasoning": "Total fields = 4 rows x 3 columns = 12. Non-null fields = 10 (row 3 has 2 nulls). Completeness = 10/12 = 83.33%. For type validity: row 1 has 3 valid, row 2 has 2 valid (age is string not numeric), row 3 has 3 valid (nulls are allowed), row 4 has 2 valid (active is string not boolean). Type validity = 10/12 = 83.33%. All 4 rows are unique, so uniqueness = 100%. Overall = 0.4*83.33 + 0.4*83.33 + 0.2*100 = 86.67%."
  },
  "category": "MLOps",
  "starter_code": "def calculate_data_quality_score(data: list, schema: dict) -> dict:\n    \"\"\"\n    Calculate data quality metrics for ML pipeline monitoring.\n    \n    Args:\n        data: list of dictionaries representing rows of data\n        schema: dictionary defining expected columns and their types\n                {'column_name': {'type': 'numeric'|'categorical'|'boolean', 'nullable': True|False}}\n    \n    Returns:\n        dict with keys: 'completeness', 'type_validity', 'uniqueness_ratio', 'overall_score'\n        All values as percentages (0-100), rounded to 2 decimal places.\n    \"\"\"\n    pass",
  "title": "Data Quality Scoring for ML Pipelines",
  "createdAt": "December 14, 2025 at 11:57:17â€¯AM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "learn_section": "IyMgRGF0YSBRdWFsaXR5IE1vbml0b3JpbmcgaW4gTUxPcHMKCkRhdGEgcXVhbGl0eSBpcyBhIGZvdW5kYXRpb25hbCBjb25jZXJuIGluIHByb2R1Y3Rpb24gTUwgc3lzdGVtcy4gTW9kZWxzIHRyYWluZWQgb24gaGlnaC1xdWFsaXR5IGRhdGEgY2FuIGRlZ3JhZGUgc2lnbmlmaWNhbnRseSB3aGVuIGV4cG9zZWQgdG8gcG9vci1xdWFsaXR5IGlucHV0cyBkdXJpbmcgaW5mZXJlbmNlLiBUaGlzIG1ha2VzIGNvbnRpbnVvdXMgZGF0YSBxdWFsaXR5IG1vbml0b3JpbmcgZXNzZW50aWFsLgoKIyMjIEtleSBEYXRhIFF1YWxpdHkgRGltZW5zaW9ucwoKIyMjIyAxLiBDb21wbGV0ZW5lc3MKQ29tcGxldGVuZXNzIG1lYXN1cmVzIHRoZSBwcmVzZW5jZSBvZiBleHBlY3RlZCB2YWx1ZXM6CgokJFx0ZXh0e0NvbXBsZXRlbmVzc30gPSBcZnJhY3tcdGV4dHtOb24tbnVsbCBWYWx1ZXN9fXtcdGV4dHtUb3RhbCBFeHBlY3RlZCBWYWx1ZXN9fSBcdGltZXMgMTAwXCUkJAoKTWlzc2luZyB2YWx1ZXMgY2FuIGNhdXNlOgotIE1vZGVsIHByZWRpY3Rpb24gZmFpbHVyZXMKLSBCaWFzZWQgZmVhdHVyZSByZXByZXNlbnRhdGlvbnMKLSBTaWxlbnQgZGVncmFkYXRpb24gb2YgbW9kZWwgcGVyZm9ybWFuY2UKCiMjIyMgMi4gVHlwZSBWYWxpZGl0eQpUeXBlIHZhbGlkaXR5IGVuc3VyZXMgZGF0YSBjb25mb3JtcyB0byBleHBlY3RlZCBzY2hlbWFzOgoKJCRcdGV4dHtUeXBlIFZhbGlkaXR5fSA9IFxmcmFje1x0ZXh0e1R5cGUtQ29uZm9ybWluZyBWYWx1ZXN9fXtcdGV4dHtUb3RhbCBWYWx1ZXN9fSBcdGltZXMgMTAwXCUkJAoKVGhpcyBpbmNsdWRlcyBjaGVja2luZzoKLSBOdW1lcmljIGZpZWxkcyBjb250YWluIGFjdHVhbCBudW1iZXJzIChpbnQsIGZsb2F0KQotIENhdGVnb3JpY2FsIGZpZWxkcyBhcmUgc3RyaW5ncwotIEJvb2xlYW4gZmllbGRzIGFyZSBUcnVlL0ZhbHNlCi0gTnVsbGFibGUgY29uc3RyYWludHMgYXJlIHJlc3BlY3RlZAoKIyMjIyAzLiBVbmlxdWVuZXNzClVuaXF1ZW5lc3MgbWVhc3VyZXMgZGF0YSByZWR1bmRhbmN5OgoKJCRcdGV4dHtVbmlxdWVuZXNzIFJhdGlvfSA9IFxmcmFje3xcdGV4dHtVbmlxdWUgUmVjb3Jkc318fXt8XHRleHR7VG90YWwgUmVjb3Jkc318fSBcdGltZXMgMTAwXCUkJAoKTG93IHVuaXF1ZW5lc3MgbWF5IGluZGljYXRlOgotIERhdGEgcGlwZWxpbmUgZHVwbGljYXRpb24gYnVncwotIFJlcGxheSBvZiBoaXN0b3JpY2FsIGRhdGEKLSBQb3RlbnRpYWwgZm9yIHRyYWluaW5nIGRhdGEgbGVha2FnZQoKIyMjIE92ZXJhbGwgUXVhbGl0eSBTY29yZQoKQ29tYmluaW5nIG1ldHJpY3MgaW50byBhIHNpbmdsZSBzY29yZSBlbmFibGVzIHRocmVzaG9sZC1iYXNlZCBhbGVydGluZzoKCiQkXHRleHR7T3ZlcmFsbCBTY29yZX0gPSB3XzEgXGNkb3QgXHRleHR7Q29tcGxldGVuZXNzfSArIHdfMiBcY2RvdCBcdGV4dHtUeXBlIFZhbGlkaXR5fSArIHdfMyBcY2RvdCBcdGV4dHtVbmlxdWVuZXNzfSQkCgp3aGVyZSAkd18xICsgd18yICsgd18zID0gMSQuIFR5cGljYWwgd2VpZ2h0aW5ncyBwcmlvcml0aXplIGNvbXBsZXRlbmVzcyBhbmQgdmFsaWRpdHkgKDQwJSBlYWNoKSBvdmVyIHVuaXF1ZW5lc3MgKDIwJSkuCgojIyMgSW1wbGVtZW50YXRpb24gQ29uc2lkZXJhdGlvbnMKCioqU2NoZW1hIEV2b2x1dGlvbioqOiBTY2hlbWFzIG1heSBjaGFuZ2Ugb3ZlciB0aW1lLiBWZXJzaW9uIHlvdXIgc2NoZW1hcyBhbmQgdHJhY2sgY29tcGF0aWJpbGl0eS4KCioqTnVsbGFibGUgSGFuZGxpbmcqKjogVGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gIm1pc3NpbmciIGFuZCAiaW50ZW50aW9uYWxseSBudWxsIiBpcyBpbXBvcnRhbnQuIFlvdXIgc2NoZW1hIHNob3VsZCBleHBsaWNpdGx5IGRlZmluZSBudWxsYWJsZSBjb25zdHJhaW50cy4KCioqVHlwZSBIaWVyYXJjaHkqKjogSW4gUHl0aG9uLCAkXHRleHR7Ym9vbH0kIGlzIGEgc3ViY2xhc3Mgb2YgJFx0ZXh0e2ludH0kLCBzbyBgaXNpbnN0YW5jZShUcnVlLCBpbnQpYCByZXR1cm5zIFRydWUuIEV4cGxpY2l0IHR5cGUgY2hlY2tpbmcgbXVzdCBhY2NvdW50IGZvciB0aGlzLgoKIyMjIFNldHRpbmcgUXVhbGl0eSBUaHJlc2hvbGRzCgpDb21tb24gcHJvZHVjdGlvbiB0aHJlc2hvbGRzOgotICoqQ3JpdGljYWwqKiAoJDwgODBcJSQpOiBCbG9jayBwaXBlbGluZSwgYWxlcnQgb24tY2FsbAotICoqV2FybmluZyoqICgkODBcJSAtIDk1XCUkKTogTG9nIHdhcm5pbmcsIGNvbnRpbnVlIHByb2Nlc3NpbmcKLSAqKkhlYWx0aHkqKiAoJD4gOTVcJSQpOiBOb3JtYWwgb3BlcmF0aW9uCgpUaGVzZSB0aHJlc2hvbGRzIHNob3VsZCBiZSBjYWxpYnJhdGVkIGJhc2VkIG9uIHlvdXIgbW9kZWwncyBzZW5zaXRpdml0eSB0byBkYXRhIHF1YWxpdHkgaXNzdWVzLg==",
  "description_decoded": "In production ML systems, data quality is critical for model performance. Poor quality data can lead to model degradation, biased predictions, and system failures. You need to implement a data quality scoring function that evaluates incoming data against a defined schema.\n\nGiven a list of data records (dictionaries) and a schema definition, compute the following quality metrics:\n\n1. **Completeness**: Percentage of non-null values across all expected fields\n2. **Type Validity**: Percentage of values that match their expected data types (including null handling based on nullable flag)\n3. **Uniqueness Ratio**: Percentage of unique records in the dataset\n4. **Overall Score**: Weighted combination of metrics (40% completeness, 40% type validity, 20% uniqueness)\n\nThe schema is a dictionary where each key is a column name and the value is a specification with:\n- 'type': One of 'numeric', 'categorical', or 'boolean'\n- 'nullable': Boolean indicating if null values are acceptable\n\nFor type validity:\n- Numeric type accepts int and float (but not boolean)\n- Categorical type accepts strings\n- Boolean type accepts True/False only\n- If a value is None and the field is nullable, it counts as type-valid\n- If a value is None and the field is not nullable, it counts as type-invalid\n\nWrite a function `calculate_data_quality_score(data, schema)` that returns a dictionary with all four metrics. Return an empty dictionary if the input data is empty. All values should be rounded to 2 decimal places.",
  "learn_section_decoded": "## Data Quality Monitoring in MLOps\n\nData quality is a foundational concern in production ML systems. Models trained on high-quality data can degrade significantly when exposed to poor-quality inputs during inference. This makes continuous data quality monitoring essential.\n\n### Key Data Quality Dimensions\n\n#### 1. Completeness\nCompleteness measures the presence of expected values:\n\n$$\\text{Completeness} = \\frac{\\text{Non-null Values}}{\\text{Total Expected Values}} \\times 100\\%$$\n\nMissing values can cause:\n- Model prediction failures\n- Biased feature representations\n- Silent degradation of model performance\n\n#### 2. Type Validity\nType validity ensures data conforms to expected schemas:\n\n$$\\text{Type Validity} = \\frac{\\text{Type-Conforming Values}}{\\text{Total Values}} \\times 100\\%$$\n\nThis includes checking:\n- Numeric fields contain actual numbers (int, float)\n- Categorical fields are strings\n- Boolean fields are True/False\n- Nullable constraints are respected\n\n#### 3. Uniqueness\nUniqueness measures data redundancy:\n\n$$\\text{Uniqueness Ratio} = \\frac{|\\text{Unique Records}|}{|\\text{Total Records}|} \\times 100\\%$$\n\nLow uniqueness may indicate:\n- Data pipeline duplication bugs\n- Replay of historical data\n- Potential for training data leakage\n\n### Overall Quality Score\n\nCombining metrics into a single score enables threshold-based alerting:\n\n$$\\text{Overall Score} = w_1 \\cdot \\text{Completeness} + w_2 \\cdot \\text{Type Validity} + w_3 \\cdot \\text{Uniqueness}$$\n\nwhere $w_1 + w_2 + w_3 = 1$. Typical weightings prioritize completeness and validity (40% each) over uniqueness (20%).\n\n### Implementation Considerations\n\n**Schema Evolution**: Schemas may change over time. Version your schemas and track compatibility.\n\n**Nullable Handling**: The distinction between \"missing\" and \"intentionally null\" is important. Your schema should explicitly define nullable constraints.\n\n**Type Hierarchy**: In Python, $\\text{bool}$ is a subclass of $\\text{int}$, so `isinstance(True, int)` returns True. Explicit type checking must account for this.\n\n### Setting Quality Thresholds\n\nCommon production thresholds:\n- **Critical** ($< 80\\%$): Block pipeline, alert on-call\n- **Warning** ($80\\% - 95\\%$): Log warning, continue processing\n- **Healthy** ($> 95\\%$): Normal operation\n\nThese thresholds should be calibrated based on your model's sensitivity to data quality issues."
}