{
  "description": "SW1wbGVtZW50IHRoZSBNaW5pbWF4IGFsZ29yaXRobSB0byBjaG9vc2UgdGhlIGJlc3QgbW92ZSBmb3IgYSBUaWMtVGFjLVRvZSBBSSBwbGF5ZXIuIEdpdmVuIGEgVGljLVRhYy1Ub2UgYm9hcmQgYW5kIGEgcGxheWVyIChlaXRoZXIgJ1gnIG9yICdPJyksIHdyaXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvcHRpbWFsIG5leHQgbW92ZSBhcyBhIHR1cGxlIChyb3csIGNvbCkuIFlvdXIgZnVuY3Rpb24gc2hvdWxkIGFzc3VtZSBib3RoIHBsYXllcnMgcGxheSBvcHRpbWFsbHkgYW5kIHJldHVybiBhIG1vdmUgdGhhdCBtYXhpbWl6ZXMgdGhlIEFJJ3MgY2hhbmNlIG9mIHdpbm5pbmcgKG9yIG1pbmltaXplcyB0aGUgY2hhbmNlIG9mIGxvc2luZyBpZiBubyB3aW4gaXMgcG9zc2libGUpLiBUaGUgYm9hcmQgaXMgZ2l2ZW4gYXMgYSAzeDMgTnVtUHkgYXJyYXkgd2l0aCBlbnRyaWVzICdYJywgJ08nLCBvciAnJywgYW5kIHRoZSBwbGF5ZXIgdG8gbW92ZSBpcyBhIHN0cmluZyAoJ1gnIG9yICdPJykuIERvIG5vdCB1c2UgYW55IGV4dGVybmFsIGdhbWUgbGlicmFyaWVzLg==",
  "id": "171",
  "test_cases": [
    {
      "test": "import numpy as np\nboard = np.array([['X', '', 'X'], ['', 'O', ''], ['', 'O', '']])\nmove = minimax_tictactoe(board, 'X')\nprint(move)",
      "expected_output": "(0, 1)"
    },
    {
      "test": "import numpy as np\nboard = np.array([['X', 'O', 'X'], ['', 'O', ''], ['', '', '']])\nmove = minimax_tictactoe(board, 'X')\nprint(move)",
      "expected_output": "(2, 1)"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "import numpy as np\nboard = np.array([['X', 'O', 'X'], ['', 'O', ''], ['', '', '']])\nmove = minimax_tictactoe(board, 'X')\nprint(move)",
    "output": "(2, 2)",
    "reasoning": "X can win by playing in (2, 2) if both sides play optimally."
  },
  "category": "Game Theory",
  "starter_code": "import numpy as np\n\ndef is_winner(board, player):\n    # Check rows, columns, and diagonals\n    for i in range(3):\n        if all(board[i, j] == player for j in range(3)):\n            return True\n        if all(board[j, i] == player for j in range(3)):\n            return True\n    if all(board[i, i] == player for i in range(3)):\n        return True\n    if all(board[i, 2-i] == player for i in range(3)):\n        return True\n    return False\n\ndef is_full(board):\n    return not any(board[i, j] == '' for i in range(3) for j in range(3))\n\ndef get_available_moves(board):\n    return [(i, j) for i in range(3) for j in range(3) if board[i, j] == '']\n\ndef minimax_tictactoe(board: np.ndarray, player: str) -> tuple:\n    \"\"\"\n    Returns the optimal move (row, col) for the given player ('X' or 'O') on the current board using Minimax.\n    Args:\n        board: 3x3 NumPy array with entries 'X', 'O', or ''\n        player: 'X' or 'O'\n    Returns:\n        Tuple (row, col) for the optimal move\n    \"\"\"\n    # Your code here\n    pass",
  "createdAt": "July 28, 2025 at 7:48:04â€¯PM UTUTC-4",
  "title": "Minimax Algorithm for Tic-Tac-Toe",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    }
  ],
  "learn_section": "IyAqKk1pbmltYXggQWxnb3JpdGhtIGZvciBUaWMtVGFjLVRvZTogTWF0aGVtYXRpY2FsIEZvdW5kYXRpb24qKgoKIyMgKioxLiBNaW5pbWF4IFByaW5jaXBsZSoqCgpUaGUgKipNaW5pbWF4IGFsZ29yaXRobSoqIGlzIGEgY2xhc3NpYyByZWN1cnNpdmUgbWV0aG9kIGZvciBmaW5kaW5nIHRoZSBvcHRpbWFsIG1vdmUgaW4gdHdvLXBsYXllciB6ZXJvLXN1bSBnYW1lcywgc3VjaCBhcyBUaWMtVGFjLVRvZS4gSXQgYXNzdW1lcyBib3RoIHBsYXllcnMgcGxheSBvcHRpbWFsbHk6IG9uZSB0cmllcyB0byBtYXhpbWl6ZSB0aGVpciBvdXRjb21lICh0aGUgbWF4aW1pemVyKSwgd2hpbGUgdGhlIG90aGVyIHRyaWVzIHRvIG1pbmltaXplIGl0ICh0aGUgbWluaW1pemVyKS4KCi0gVGhlICoqQUkqKiBpcyB0aGUgbWF4aW1pemVyICh0cmllcyB0byBnZXQgdGhlIGhpZ2hlc3QgcG9zc2libGUgc2NvcmUpCi0gVGhlICoqb3Bwb25lbnQqKiBpcyB0aGUgbWluaW1pemVyICh0cmllcyB0byBnZXQgdGhlIGxvd2VzdCBwb3NzaWJsZSBzY29yZSBmb3IgdGhlIEFJKQoKLS0tCgojIyAqKjIuIEdhbWUgRXZhbHVhdGlvbioqCgotIEEgVGljLVRhYy1Ub2UgYm9hcmQgc3RhdGUgY2FuIGVuZCBpbiBhICoqd2luKiogKCsxIGZvciBYLCAtMSBmb3IgTyksICoqZHJhdyoqICgwKSwgb3IgKipvbmdvaW5nKiogKHVuZGVjaWRlZCkuCi0gVGhlIG1pbmltYXggYWxnb3JpdGhtIHJlY3Vyc2l2ZWx5IGV4cGxvcmVzIGFsbCBwb3NzaWJsZSBtb3ZlcyBhbmQgYXNzaWducyBzY29yZXMgYWNjb3JkaW5nIHRvIHRoZSBvdXRjb21lOgogIC0gSWYgWCB3aW5zOiArMQogIC0gSWYgTyB3aW5zOiAtMQogIC0gSWYgZHJhdzogMAoKLS0tCgojIyAqKjMuIE1pbmltYXggUmVjdXJzaW9uKioKCkZvciBhIGdpdmVuIHBsYXllciBhbmQgYm9hcmQ6Ci0gRm9yIGV2ZXJ5IGF2YWlsYWJsZSBtb3ZlOgogIC0gU2ltdWxhdGUgdGhhdCBtb3ZlIG9uIHRoZSBib2FyZC4KICAtIFJlY3Vyc2l2ZWx5IGNhbGwgbWluaW1heCBmb3IgdGhlIG5ldyBib2FyZCBzdGF0ZSB3aXRoIHRoZSBvdGhlciBwbGF5ZXIuCi0gSWYgaXQncyB0aGUgbWF4aW1pemVyJ3MgdHVybiAoZS5nLiwgWCksIHBpY2sgdGhlIG1vdmUgd2l0aCB0aGUgaGlnaGVzdCByZXR1cm5lZCBzY29yZS4KLSBJZiBpdCdzIHRoZSBtaW5pbWl6ZXIncyB0dXJuIChlLmcuLCBPKSwgcGljayB0aGUgbW92ZSB3aXRoIHRoZSBsb3dlc3QgcmV0dXJuZWQgc2NvcmUuCgpMZXQgJFMkIGJlIGEgYm9hcmQgc3RhdGUsIGFuZCAkQSQgYmUgdGhlIHNldCBvZiBhdmFpbGFibGUgbW92ZXMuIExldCAkVihTKSQgYmUgdGhlIHNjb3JlIG9mIHN0YXRlICRTJC4KCkZvciBYJ3MgdHVybiAobWF4aW1pemluZyk6CiQkClYoUykgPSBcbWF4X3thIFxpbiBBfSBcYmlnWyBcdGV4dHtNaW5pbWF4fShTX2EsICdPJykgXGJpZ10KJCQKRm9yIE8ncyB0dXJuIChtaW5pbWl6aW5nKToKJCQKVihTKSA9IFxtaW5fe2EgXGluIEF9IFxiaWdbIFx0ZXh0e01pbmltYXh9KFNfYSwgJ1gnKSBcYmlnXQokJAp3aGVyZSAkU19hJCBpcyB0aGUgYm9hcmQgYWZ0ZXIgbW92ZSAkYSQuCgpUaGUgcmVjdXJzaW9uIGNvbnRpbnVlcyB1bnRpbCB0aGUgZ2FtZSBlbmRzLgoKLS0tCgojIyAqKjQuIENvbXBsZXhpdHkqKgoKVGljLVRhYy1Ub2UgaGFzIGEgc21hbGwgZW5vdWdoIGdhbWUgdHJlZSB0aGF0IHRoaXMgYnJ1dGUtZm9yY2UgcmVjdXJzaXZlIGFwcHJvYWNoIGlzIHRyYWN0YWJsZS4gRm9yIGxhcmdlciBnYW1lcywgb3B0aW1pemF0aW9ucyAobGlrZSBhbHBoYS1iZXRhIHBydW5pbmcpIGFyZSB1c2VkLgoKLS0tCgojIyAqKjUuIFdoeSBEb2VzIE1pbmltYXggV29yaz8qKgoKTWluaW1heCB3b3JrcyBiZWNhdXNlIGl0IG1vZGVscyBib3RoIHBsYXllcnMgYXMgcmF0aW9uYWwgYW5kIGFsd2F5cyBjaG9vc2luZyB0aGVpciBiZXN0IG1vdmVzLiBJdCBndWFyYW50ZWVzIGFuIG9wdGltYWwgb3V0Y29tZSBhc3N1bWluZyBib3RoIHBsYXkgcGVyZmVjdGx5LiBJbiBUaWMtVGFjLVRvZSwgaXQgY2FuIGFsd2F5cyBmb3JjZSBhIHdpbiBvciBhIGRyYXcgZm9yIHRoZSBmaXJzdCBwbGF5ZXIuCgotLS0KCioqSW4gc3VtbWFyeToqKiBUaGUgbWluaW1heCBhbGdvcml0aG0gZXhoYXVzdGl2ZWx5IHNpbXVsYXRlcyBhbGwgcG9zc2libGUgb3V0Y29tZXMsIHBpY2tzIHRoZSBiZXN0IGd1YXJhbnRlZWQgcmVzdWx0LCBhbmQgaXMgdGhlIGZvdW5kYXRpb24gb2YgQUkgaW4gY2xhc3NpYyB0d28tcGxheWVyIGJvYXJkIGdhbWVzIGxpa2UgVGljLVRhYy1Ub2Uu",
  "description_decoded": "Implement the Minimax algorithm to choose the best move for a Tic-Tac-Toe AI player. Given a Tic-Tac-Toe board and a player (either 'X' or 'O'), write a function that returns the optimal next move as a tuple (row, col). Your function should assume both players play optimally and return a move that maximizes the AI's chance of winning (or minimizes the chance of losing if no win is possible). The board is given as a 3x3 NumPy array with entries 'X', 'O', or '', and the player to move is a string ('X' or 'O'). Do not use any external game libraries.",
  "learn_section_decoded": "# **Minimax Algorithm for Tic-Tac-Toe: Mathematical Foundation**\n\n## **1. Minimax Principle**\n\nThe **Minimax algorithm** is a classic recursive method for finding the optimal move in two-player zero-sum games, such as Tic-Tac-Toe. It assumes both players play optimally: one tries to maximize their outcome (the maximizer), while the other tries to minimize it (the minimizer).\n\n- The **AI** is the maximizer (tries to get the highest possible score)\n- The **opponent** is the minimizer (tries to get the lowest possible score for the AI)\n\n---\n\n## **2. Game Evaluation**\n\n- A Tic-Tac-Toe board state can end in a **win** (+1 for X, -1 for O), **draw** (0), or **ongoing** (undecided).\n- The minimax algorithm recursively explores all possible moves and assigns scores according to the outcome:\n  - If X wins: +1\n  - If O wins: -1\n  - If draw: 0\n\n---\n\n## **3. Minimax Recursion**\n\nFor a given player and board:\n- For every available move:\n  - Simulate that move on the board.\n  - Recursively call minimax for the new board state with the other player.\n- If it's the maximizer's turn (e.g., X), pick the move with the highest returned score.\n- If it's the minimizer's turn (e.g., O), pick the move with the lowest returned score.\n\nLet $S$ be a board state, and $A$ be the set of available moves. Let $V(S)$ be the score of state $S$.\n\nFor X's turn (maximizing):\n$$\nV(S) = \\max_{a \\in A} \\big[ \\text{Minimax}(S_a, 'O') \\big]\n$$\nFor O's turn (minimizing):\n$$\nV(S) = \\min_{a \\in A} \\big[ \\text{Minimax}(S_a, 'X') \\big]\n$$\nwhere $S_a$ is the board after move $a$.\n\nThe recursion continues until the game ends.\n\n---\n\n## **4. Complexity**\n\nTic-Tac-Toe has a small enough game tree that this brute-force recursive approach is tractable. For larger games, optimizations (like alpha-beta pruning) are used.\n\n---\n\n## **5. Why Does Minimax Work?**\n\nMinimax works because it models both players as rational and always choosing their best moves. It guarantees an optimal outcome assuming both play perfectly. In Tic-Tac-Toe, it can always force a win or a draw for the first player.\n\n---\n\n**In summary:** The minimax algorithm exhaustively simulates all possible outcomes, picks the best guaranteed result, and is the foundation of AI in classic two-player board games like Tic-Tac-Toe."
}