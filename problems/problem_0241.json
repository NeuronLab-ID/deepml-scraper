{
  "description": "IyMgVGFzazogU29iZWwgRWRnZSBEZXRlY3Rpb24KCkVkZ2UgZGV0ZWN0aW9uIGlzIGEgZnVuZGFtZW50YWwgdGVjaG5pcXVlIGluIGNvbXB1dGVyIHZpc2lvbiB1c2VkIHRvIGlkZW50aWZ5IGJvdW5kYXJpZXMgd2l0aGluIGltYWdlcy4gSW4gdGhpcyB0YXNrLCB5b3Ugd2lsbCBpbXBsZW1lbnQgYSBmdW5jdGlvbiBgc29iZWxfZWRnZV9kZXRlY3Rpb24oaW1hZ2UpYCB0aGF0IGFwcGxpZXMgdGhlIFNvYmVsIG9wZXJhdG9yIHRvIGRldGVjdCBlZGdlcyBpbiBhIGdyYXlzY2FsZSBpbWFnZS4KCiMjIyBJbnB1dDoKLSBgaW1hZ2VgOiBBIDJEIGxpc3QvYXJyYXkgcmVwcmVzZW50aW5nIGEgZ3JheXNjYWxlIGltYWdlIHdpdGggcGl4ZWwgdmFsdWVzIGluIHJhbmdlIFswLCAyNTVdCgojIyMgT3V0cHV0OgotIFJldHVybiB0aGUgZWRnZSBtYWduaXR1ZGUgaW1hZ2UgYXMgYSAyRCBsaXN0IHdpdGggaW50ZWdlciB2YWx1ZXMgbm9ybWFsaXplZCB0byBbMCwgMjU1XQotIFRoZSBvdXRwdXQgZGltZW5zaW9ucyB3aWxsIGJlIChILTIsIFctMikgZHVlIHRvIHZhbGlkIGNvbnZvbHV0aW9uIChubyBwYWRkaW5nKQotIFJldHVybiBgLTFgIGZvciBpbnZhbGlkIGlucHV0cwoKIyMjIEVkZ2UgQ2FzZXMgdG8gSGFuZGxlOgotIElucHV0IGlzIG5vdCBhIHZhbGlkIDJEIGFycmF5Ci0gSW1hZ2UgZGltZW5zaW9ucyBhcmUgc21hbGxlciB0aGFuIDN4MyAobWluaW11bSByZXF1aXJlZCBmb3IgU29iZWwpCi0gQW55IHBpeGVsIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UgKDAtMjU1KQotIEVtcHR5IGltYWdlCgojIyMgTm90ZXM6Ci0gVXNlIHRoZSBzdGFuZGFyZCBTb2JlbCBrZXJuZWxzIGZvciBncmFkaWVudCBjb21wdXRhdGlvbgotIENvbXB1dGUgZ3JhZGllbnQgbWFnbml0dWRlIGZyb20gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZ3JhZGllbnRzCi0gTm9ybWFsaXplIHRoZSBvdXRwdXQgdG8gdGhlIHJhbmdlIFswLCAyNTVdIGJhc2VkIG9uIHRoZSBtYXhpbXVtIG1hZ25pdHVkZSB2YWx1ZQ==",
  "id": "241",
  "test_cases": [
    {
      "test": "# Test vertical edge detection\nimage = [[0, 0, 255], [0, 0, 255], [0, 0, 255]]\nprint(sobel_edge_detection(image))",
      "expected_output": "[[255]]"
    },
    {
      "test": "# Test uniform image (no edges)\nimage = [[100, 100, 100], [100, 100, 100], [100, 100, 100]]\nprint(sobel_edge_detection(image))",
      "expected_output": "[[0]]"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "image = [[0, 0, 255], [0, 0, 255], [0, 0, 255]]\nprint(sobel_edge_detection(image))",
    "output": "[[255]]",
    "reasoning": "This 3x3 image has a strong vertical edge (black on left, white on right). The Sobel operator computes: Gx = 1020 (strong horizontal gradient), Gy = 0 (no vertical gradient). The magnitude sqrt(1020^2 + 0^2) = 1020 is normalized to 255 since it's the maximum value."
  },
  "category": "Computer Vision",
  "starter_code": "import numpy as np\n\ndef sobel_edge_detection(image):\n    \"\"\"\n    Apply Sobel edge detection to a grayscale image.\n    \n    Args:\n        image: 2D list/array representing a grayscale image\n               with values in range [0, 255]\n    \n    Returns:\n        Edge magnitude image as 2D list with integer values (0-255),\n        or -1 if input is invalid\n    \"\"\"\n    # Your code here\n    pass",
  "createdAt": "December 14, 2025 at 11:26:37â€¯AM UTC-0500",
  "learn_section": "IyBTb2JlbCBFZGdlIERldGVjdGlvbgoKVGhlIFNvYmVsIG9wZXJhdG9yIGlzIGEgZGlzY3JldGUgZGlmZmVyZW50aWF0aW9uIG9wZXJhdG9yIHVzZWQgaW4gaW1hZ2UgcHJvY2Vzc2luZyBhbmQgY29tcHV0ZXIgdmlzaW9uIHRvIGRldGVjdCBlZGdlcy4gSXQgY29tcHV0ZXMgYW4gYXBwcm94aW1hdGlvbiBvZiB0aGUgZ3JhZGllbnQgb2YgdGhlIGltYWdlIGludGVuc2l0eSBmdW5jdGlvbi4KCiMjIFNvYmVsIEtlcm5lbHMKClRoZSBTb2JlbCBvcGVyYXRvciB1c2VzIHR3byAzeDMgY29udm9sdXRpb24ga2VybmVscyB0byBjb21wdXRlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGdyYWRpZW50czoKCioqSG9yaXpvbnRhbCBncmFkaWVudCBrZXJuZWwgKEd4KToqKgokJEdfeCA9IFxiZWdpbntibWF0cml4fSAtMSAmIDAgJiAxIFxcIC0yICYgMCAmIDIgXFwgLTEgJiAwICYgMSBcZW5ke2JtYXRyaXh9JCQKCioqVmVydGljYWwgZ3JhZGllbnQga2VybmVsIChHeSk6KioKJCRHX3kgPSBcYmVnaW57Ym1hdHJpeH0gLTEgJiAtMiAmIC0xIFxcIDAgJiAwICYgMCBcXCAxICYgMiAmIDEgXGVuZHtibWF0cml4fSQkCgojIyBDb252b2x1dGlvbiBPcGVyYXRpb24KCkZvciBlYWNoIHBpeGVsIHBvc2l0aW9uICQoaSwgaikkLCB3ZSBleHRyYWN0IGEgM3gzIHdpbmRvdyBhbmQgY29tcHV0ZSB0aGUgZWxlbWVudC13aXNlIHByb2R1Y3Qgd2l0aCBlYWNoIGtlcm5lbCwgdGhlbiBzdW0gdGhlIHJlc3VsdHM6CgokJEdfeChpLGopID0gXHN1bV97bT0tMX1eezF9IFxzdW1fe249LTF9XnsxfSBJKGkrbSwgaituKSBcY2RvdCBLX3gobSsxLCBuKzEpJCQKCiQkR195KGksaikgPSBcc3VtX3ttPS0xfV57MX0gXHN1bV97bj0tMX1eezF9IEkoaSttLCBqK24pIFxjZG90IEtfeShtKzEsIG4rMSkkJAoKd2hlcmUgJEkkIGlzIHRoZSBpbnB1dCBpbWFnZSBhbmQgJEtfeCQsICRLX3kkIGFyZSB0aGUgU29iZWwga2VybmVscy4KCiMjIEdyYWRpZW50IE1hZ25pdHVkZQoKVGhlIGVkZ2Ugc3RyZW5ndGggYXQgZWFjaCBwaXhlbCBpcyBjb21wdXRlZCBhcyB0aGUgbWFnbml0dWRlIG9mIHRoZSBncmFkaWVudCB2ZWN0b3I6CgokJEcgPSBcc3FydHtHX3heMiArIEdfeV4yfSQkCgpUaGlzIGdpdmVzIHRoZSByYXRlIG9mIGNoYW5nZSBvZiBpbnRlbnNpdHkgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb24uIFN0cm9uZyBlZGdlcyBwcm9kdWNlIGhpZ2ggbWFnbml0dWRlIHZhbHVlcy4KCiMjIEdyYWRpZW50IERpcmVjdGlvbgoKVGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZSBjYW4gYWxzbyBiZSBjb21wdXRlZCAodGhvdWdoIG5vdCByZXF1aXJlZCBmb3IgdGhpcyB0YXNrKToKCiQkXHRoZXRhID0gXGFyY3RhblxsZWZ0KFxmcmFje0dfeX17R194fVxyaWdodCkkJAoKIyMgTm9ybWFsaXphdGlvbgoKVG8gZGlzcGxheSB0aGUgcmVzdWx0IGFzIGFuIGltYWdlLCB3ZSBub3JtYWxpemUgdGhlIG1hZ25pdHVkZSB2YWx1ZXMgdG8gdGhlIHJhbmdlICRbMCwgMjU1XSQ6CgokJEdfe25vcm1hbGl6ZWR9ID0gXGZyYWN7R317R197bWF4fX0gXHRpbWVzIDI1NSQkCgojIyBXaHkgU29iZWwgV29ya3MKClRoZSBTb2JlbCBrZXJuZWxzIGFyZSBkZXNpZ25lZCB0bzoKMS4gKipEZXRlY3QgY2hhbmdlcyoqOiBUaGUgKzEgYW5kIC0xIHZhbHVlcyBjb21wdXRlIGRpZmZlcmVuY2VzIGJldHdlZW4gbmVpZ2hib3JpbmcgcGl4ZWxzCjIuICoqU21vb3RoIG5vaXNlKio6IFRoZSBjZW50ZXIgcm93L2NvbHVtbiB3ZWlnaHRzICgyLCAwLCAyKSBwcm92aWRlIEdhdXNzaWFuLWxpa2Ugc21vb3RoaW5nCjMuICoqU2VwYXJhdGUgZGlyZWN0aW9ucyoqOiAkR194JCBkZXRlY3RzIHZlcnRpY2FsIGVkZ2VzLCAkR195JCBkZXRlY3RzIGhvcml6b250YWwgZWRnZXMKCiMjIEFwcGxpY2F0aW9ucwoKLSBPYmplY3QgZGV0ZWN0aW9uIGFuZCByZWNvZ25pdGlvbgotIEltYWdlIHNlZ21lbnRhdGlvbgotIEZlYXR1cmUgZXh0cmFjdGlvbiBmb3IgbWFjaGluZSBsZWFybmluZwotIFByZXByb2Nlc3NpbmcgZm9yIG1vcmUgY29tcGxleCBlZGdlIGRldGVjdG9ycyAoQ2Fubnkp",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "title": "Sobel Edge Detection",
  "description_decoded": "## Task: Sobel Edge Detection\n\nEdge detection is a fundamental technique in computer vision used to identify boundaries within images. In this task, you will implement a function `sobel_edge_detection(image)` that applies the Sobel operator to detect edges in a grayscale image.\n\n### Input:\n- `image`: A 2D list/array representing a grayscale image with pixel values in range [0, 255]\n\n### Output:\n- Return the edge magnitude image as a 2D list with integer values normalized to [0, 255]\n- The output dimensions will be (H-2, W-2) due to valid convolution (no padding)\n- Return `-1` for invalid inputs\n\n### Edge Cases to Handle:\n- Input is not a valid 2D array\n- Image dimensions are smaller than 3x3 (minimum required for Sobel)\n- Any pixel values are outside the valid range (0-255)\n- Empty image\n\n### Notes:\n- Use the standard Sobel kernels for gradient computation\n- Compute gradient magnitude from horizontal and vertical gradients\n- Normalize the output to the range [0, 255] based on the maximum magnitude value",
  "learn_section_decoded": "# Sobel Edge Detection\n\nThe Sobel operator is a discrete differentiation operator used in image processing and computer vision to detect edges. It computes an approximation of the gradient of the image intensity function.\n\n## Sobel Kernels\n\nThe Sobel operator uses two 3x3 convolution kernels to compute horizontal and vertical gradients:\n\n**Horizontal gradient kernel (Gx):**\n$$G_x = \\begin{bmatrix} -1 & 0 & 1 \\\\ -2 & 0 & 2 \\\\ -1 & 0 & 1 \\end{bmatrix}$$\n\n**Vertical gradient kernel (Gy):**\n$$G_y = \\begin{bmatrix} -1 & -2 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 2 & 1 \\end{bmatrix}$$\n\n## Convolution Operation\n\nFor each pixel position $(i, j)$, we extract a 3x3 window and compute the element-wise product with each kernel, then sum the results:\n\n$$G_x(i,j) = \\sum_{m=-1}^{1} \\sum_{n=-1}^{1} I(i+m, j+n) \\cdot K_x(m+1, n+1)$$\n\n$$G_y(i,j) = \\sum_{m=-1}^{1} \\sum_{n=-1}^{1} I(i+m, j+n) \\cdot K_y(m+1, n+1)$$\n\nwhere $I$ is the input image and $K_x$, $K_y$ are the Sobel kernels.\n\n## Gradient Magnitude\n\nThe edge strength at each pixel is computed as the magnitude of the gradient vector:\n\n$$G = \\sqrt{G_x^2 + G_y^2}$$\n\nThis gives the rate of change of intensity regardless of direction. Strong edges produce high magnitude values.\n\n## Gradient Direction\n\nThe direction of the edge can also be computed (though not required for this task):\n\n$$\\theta = \\arctan\\left(\\frac{G_y}{G_x}\\right)$$\n\n## Normalization\n\nTo display the result as an image, we normalize the magnitude values to the range $[0, 255]$:\n\n$$G_{normalized} = \\frac{G}{G_{max}} \\times 255$$\n\n## Why Sobel Works\n\nThe Sobel kernels are designed to:\n1. **Detect changes**: The +1 and -1 values compute differences between neighboring pixels\n2. **Smooth noise**: The center row/column weights (2, 0, 2) provide Gaussian-like smoothing\n3. **Separate directions**: $G_x$ detects vertical edges, $G_y$ detects horizontal edges\n\n## Applications\n\n- Object detection and recognition\n- Image segmentation\n- Feature extraction for machine learning\n- Preprocessing for more complex edge detectors (Canny)"
}