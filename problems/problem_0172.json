{
  "description": "SW1wbGVtZW50IGEgc2luZ2xlIE11b24gb3B0aW1pemVyIHVwZGF0ZSB1c2luZyBvbmx5IE51bVB5LiBHaXZlbiBhIHBhcmFtZXRlciBtYXRyaXggdGhldGEsIGl0cyBncmFkaWVudCBHLCBtb21lbnR1bSBtdSwgbGVhcm5pbmcgcmF0ZSBsLCBhbmQgYSBudW1iZXIgb2YgTmV3dG9uLVNjaHVseiBzdGVwcywgcGVyZm9ybSBvbmUgdXBkYXRlIHN0ZXAgZm9sbG93aW5nIHRoZSBNdW9uIGFsZ29yaXRobSBiZWxvdy4gWW91IG11c3QgYWxzbyBpbXBsZW1lbnQgdGhlIE5ld3Rvbi1TY2h1bHo1IGZ1bmN0aW9uICg1IHF1aW50aWMgc3RlcHMpIGZvciBtYXRyaXggcHJlY29uZGl0aW9uaW5nKE5vIHNjYWxlIGZhY3RvciBpcyBuZWVkZWQgZm9yIHRoaXMgcXVlc3Rpb24p",
  "id": "172",
  "test_cases": [
    {
      "test": "import numpy as np\nnp.random.seed(1)\ntheta = np.eye(3)\ngrad = np.ones((3, 3))\nB_prev = np.zeros((3, 3))\nmu = 0.8\nlr = 0.05\ntheta_new, B_new, O = muon_update(theta, grad, B_prev, mu, lr)\nprint(B_new.round(2))\nprint(O.round(4))",
      "expected_output": "[[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], [[0.2321, 0.2321, 0.2321], [0.2321, 0.2321, 0.2321], [0.2321, 0.2321, 0.2321]]"
    },
    {
      "test": "import numpy as np\nnp.random.seed(2)\ntheta = np.ones((2, 4)) * 2\ngrad = np.arange(1, 9).reshape(2, 4)\nB_prev = np.zeros((2, 4))\nmu = 0.7\nlr = 0.02\ntheta_new, B_new, O = muon_update(theta, grad, B_prev, mu, lr)\nprint(B_new.round(2))\nprint(O.round(4))",
      "expected_output": "[[1., 2., 3., 4.], [5., 6., 7., 8.]], [[-0.4198, -0.1, 0.2198, 0.5396], [ 0.4367, 0.3761, 0.3155, 0.2549]]"
    }
  ],
  "difficulty": "medium",
  "likes": "0",
  "video": "https://youtu.be/-Cto66pAUXQ?si=d4_ZKgvjheiILrBw",
  "dislikes": "0",
  "example": {
    "input": "import numpy as np\nnp.random.seed(0)\ntheta = np.ones((3, 3))\ngrad = np.arange(1, 10).reshape(3, 3)\nB_prev = np.zeros((3, 3))\nmu = 0.9\nlr = 0.01\ntheta_new, B_new, O = muon_update(theta, grad, B_prev, mu, lr)\nprint(B_new.round(3))\nprint(O.round(4))",
    "output": "[[1. 2. 3.]\n [4. 5. 6.]\n [7. 8. 9.]]\n[[-0.0267  0.0855  0.1979]\n [ 0.1701  0.3036  0.4371]\n [ 0.3669  0.5216  0.6764]]",
    "reasoning": "The first B update is grad (since B_prev = 0). O is the Newton-Schulz5 result. θ_new = θ - lr * O."
  },
  "category": "Deep Learning",
  "starter_code": "import numpy as np\n\ndef newtonschulz5(G: np.ndarray, steps=5, eps=1e-7) -> np.ndarray:\n    \"\"\"\n    Apply the Newton-Schulz (quintic) iteration for 5 steps to matrix G.\n    Args:\n        G: 2D NumPy array\n        steps: Number of iteration steps (default 5)\n        eps: Small constant for stability\n    Returns:\n        Matrix after Newton-Schulz iteration\n    \"\"\"\n    # Your code here\n    pass\n\ndef muon_update(theta: np.ndarray, grad: np.ndarray, B_prev: np.ndarray, mu: float, lr: float) -> tuple:\n    \"\"\"\n    Performs one Muon optimizer update (Algorithm 2). Returns the updated parameter, new B, and the preconditioned update.\n    Args:\n        theta: Parameter matrix (2D NumPy array)\n        grad: Gradient matrix (same shape)\n        B_prev: Previous B matrix (momentum)\n        mu: Momentum factor (0 <= mu < 1)\n        lr: Learning rate (step size)\n    Returns:\n        theta_new: Updated parameter matrix\n        B_new: Updated B matrix\n        O: Preconditioned update\n    \"\"\"\n    # Step 1: Compute B_t\n    # Step 2: Precondition with Newton-Schulz5\n    # Step 3: Update theta\n    # Your code here\n    pass",
  "title": "Muon Optimizer Update with Newton-Schulz Iteration",
  "createdAt": "August 5, 2025 at 7:15:41 PM UTUTC-4",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    }
  ],
  "learn_section": "IyAqKk11b24gT3B0aW1pemVyIGFuZCBOZXd0b24tU2NodWx6IFByZWNvbmRpdGlvbmluZzogVGhlIE1hdGgqKgoKVGhlIE11b24gb3B0aW1pemVyIGlzIGEgbm92ZWwgZmlyc3Qtb3JkZXIgbWV0aG9kIGZvciB0cmFpbmluZyBuZXVyYWwgbmV0d29ya3MsIGNvbWJpbmluZyBtb21lbnR1bSB3aXRoIG1hdHJpeCBwcmVjb25kaXRpb25pbmcgZm9yIGltcHJvdmVkIHN0YWJpbGl0eSBhbmQgY29udmVyZ2VuY2UuCgojIyAqKjEuIFRoZSBNdW9uIFVwZGF0ZSBSdWxlKioKR2l2ZW46Ci0gJFx0aGV0YSQgKHBhcmFtZXRlcnMpLAotICRHJCAoY3VycmVudCBncmFkaWVudCksCi0gJEJfe3QtMX0kIChwcmV2aW91cyBtb21lbnR1bSBidWZmZXIpLAotICRcbXUkIChtb21lbnR1bSBmYWN0b3IpLAotICRcZXRhJCAobGVhcm5pbmcgcmF0ZSksCi0gJE9fdCQgKHByZWNvbmRpdGlvbmVkIHVwZGF0ZSkuCgojIyMgKipVcGRhdGUgU3RlcHMqKgoxLiAqKk1vbWVudHVtIFVwZGF0ZToqKgogICAkJAogICBCX3QgPSBcbXUgQl97dC0xfSArIEdfdAogICAkJAoyLiAqKk1hdHJpeCBQcmVjb25kaXRpb25pbmcgKE5ld3Rvbi1TY2h1bHo1KToqKgogICAkT190ID0gXHRleHR7TmV3dG9uU2NodWx6NX0oQl90KSQKMy4gKipQYXJhbWV0ZXIgVXBkYXRlOioqCiAgICQkCiAgIFx0aGV0YV90ID0gXHRoZXRhX3t0LTF9IC0gXGV0YSBPX3QKICAgJCQKCiMjICoqMi4gTmV3dG9uLVNjaHVseiBJdGVyYXRpb24gKFF1aW50aWMgVmFyaWFudCkqKgpUaGlzIGl0ZXJhdGl2ZSBwcm9jZXNzIGFwcHJveGltYXRlcyBhIHplcm90aC1wb3dlciAob3J0aG9nb25hbGl6YXRpb24pIG9mIGEgbWF0cml4OgoKLSAqKkluaXRpYWxpemU6KiogTm9ybWFsaXplIHRoZSBpbnB1dCAkRyQgYnkgaXRzIEZyb2Jlbml1cyBub3JtCi0gKipJZiByb3dzID4gY29sczoqKiBUcmFuc3Bvc2UgYmVmb3JlIGFuZCBhZnRlcgotICoqSXRlcmF0aW9uOioqCiAgICQkCiAgIFxiZWdpbnthbGlnbip9CiAgIFhfMCAmPSBcdGV4dHtub3JtYWxpemVkIGlucHV0fSBcXAogICBcdGV4dHtSZXBlYXQgNSB0aW1lczp9IFxcCiAgIEEgJj0gWCBYXlQgXFwKICAgQiAmPSBiQSArIGNBQSBcXAogICBYICZcbGVmdGFycm93IGFYICsgQiBYCiAgIFxlbmR7YWxpZ24qfQogICAkJAogICBXaGVyZSAkYSwgYiwgYyQgYXJlIGNvZWZmaWNpZW50cyAocXVpbnRpYyBOZXd0b24tU2NodWx6KToKICAgJGE9My40NDQ1LCBiPS00Ljc3NTAsIGM9Mi4wMzE1JAoKIyMgKiozLiBNdW9uIEFsZ29yaXRobSBJbnR1aXRpb24qKgotICoqTW9tZW50dW0qKiBzbW9vdGhzIHRoZSBncmFkaWVudCBzaWduYWwgdG8gYWNjZWxlcmF0ZSBsZWFybmluZy4KLSAqKlByZWNvbmRpdGlvbmluZyoqIHRyYW5zZm9ybXMgdGhlIHVwZGF0ZSBkaXJlY3Rpb24sIGFjdGluZyBsaWtlIGFuIGFkYXB0aXZlIHN0ZXAgZm9yIG1vcmUgcm9idXN0IGNvbnZlcmdlbmNlLgotICoqTmV3dG9uLVNjaHVseioqIGFjdHMgYXMgYW4gZWZmaWNpZW50IG1hdHJpeCBmdW5jdGlvbiBhcHByb3hpbWF0b3LigJRoZXJlLCBvcnRob2dvbmFsaXppbmcgdGhlIG1vbWVudHVtIGJ1ZmZlci4KCi0tLQoqKkluIHN1bW1hcnk6KiogTXVvbiBjb21iaW5lcyB0aGUgcG93ZXIgb2YgbW9tZW50dW0gYW5kIG1hdHJpeCBwcmVjb25kaXRpb25pbmcgdG8gcHJvdmlkZSBmYXN0LCBzdGFibGUgbmV1cmFsIG5ldHdvcmsgb3B0aW1pemF0aW9uLCB3aXRoIE5ld3Rvbi1TY2h1bHogYXMgYSBjb3JlIG1hdGhlbWF0aWNhbCB0b29sIGZvciB0aGUgcHJlY29uZGl0aW9uaW5nIHN0ZXAu",
  "description_decoded": "Implement a single Muon optimizer update using only NumPy. Given a parameter matrix theta, its gradient G, momentum mu, learning rate l, and a number of Newton-Schulz steps, perform one update step following the Muon algorithm below. You must also implement the Newton-Schulz5 function (5 quintic steps) for matrix preconditioning(No scale factor is needed for this question)",
  "learn_section_decoded": "# **Muon Optimizer and Newton-Schulz Preconditioning: The Math**\n\nThe Muon optimizer is a novel first-order method for training neural networks, combining momentum with matrix preconditioning for improved stability and convergence.\n\n## **1. The Muon Update Rule**\nGiven:\n- $\\theta$ (parameters),\n- $G$ (current gradient),\n- $B_{t-1}$ (previous momentum buffer),\n- $\\mu$ (momentum factor),\n- $\\eta$ (learning rate),\n- $O_t$ (preconditioned update).\n\n### **Update Steps**\n1. **Momentum Update:**\n   $$\n   B_t = \\mu B_{t-1} + G_t\n   $$\n2. **Matrix Preconditioning (Newton-Schulz5):**\n   $O_t = \\text{NewtonSchulz5}(B_t)$\n3. **Parameter Update:**\n   $$\n   \\theta_t = \\theta_{t-1} - \\eta O_t\n   $$\n\n## **2. Newton-Schulz Iteration (Quintic Variant)**\nThis iterative process approximates a zeroth-power (orthogonalization) of a matrix:\n\n- **Initialize:** Normalize the input $G$ by its Frobenius norm\n- **If rows > cols:** Transpose before and after\n- **Iteration:**\n   $$\n   \\begin{align*}\n   X_0 &= \\text{normalized input} \\\\\n   \\text{Repeat 5 times:} \\\\\n   A &= X X^T \\\\\n   B &= bA + cAA \\\\\n   X &\\leftarrow aX + B X\n   \\end{align*}\n   $$\n   Where $a, b, c$ are coefficients (quintic Newton-Schulz):\n   $a=3.4445, b=-4.7750, c=2.0315$\n\n## **3. Muon Algorithm Intuition**\n- **Momentum** smooths the gradient signal to accelerate learning.\n- **Preconditioning** transforms the update direction, acting like an adaptive step for more robust convergence.\n- **Newton-Schulz** acts as an efficient matrix function approximator—here, orthogonalizing the momentum buffer.\n\n---\n**In summary:** Muon combines the power of momentum and matrix preconditioning to provide fast, stable neural network optimization, with Newton-Schulz as a core mathematical tool for the preconditioning step."
}