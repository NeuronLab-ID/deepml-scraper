{
  "description": "V3JpdGUgYSBQeXRob24gZnVuY3Rpb24gYGRic2NhbmAgdGhhdCBpbXBsZW1lbnRzIHRoZSBEZW5zaXR5LUJhc2VkIFNwYXRpYWwgQ2x1c3RlcmluZyBvZiBBcHBsaWNhdGlvbnMgd2l0aCBOb2lzZSAoREJTQ0FOKSBhbGdvcml0aG0uIFRoZSBmdW5jdGlvbiBzaG91bGQgdGFrZSBhIDJEIG51bXB5IGFycmF5IGBYYCByZXByZXNlbnRpbmcgdGhlIGRhdGEgcG9pbnRzIG9mIHNoYXBlIChuX3NhbXBsZXMsIG5fZmVhdHVyZXMpLCBhIGZsb2F0IGBlcHNgIHJlcHJlc2VudGluZyB0aGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzYW1wbGVzIGZvciB0aGVtIHRvIGJlIGNvbnNpZGVyZWQgbmVpZ2hib3JzLCBhbmQgYW4gaW50ZWdlciBgbWluX3NhbXBsZXNgIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGZvcm0gYSBkZW5zZSByZWdpb24gKGNvcmUgcG9pbnQpLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIDFEIG51bXB5IGFycmF5IG9mIGNsdXN0ZXIgbGFiZWxzIHdoZXJlIC0xIGluZGljYXRlcyBub2lzZSBwb2ludHMgKHBvaW50cyB0aGF0IGRvbid0IGJlbG9uZyB0byBhbnkgY2x1c3RlcikuIFVzZSBFdWNsaWRlYW4gZGlzdGFuY2UgZm9yIGNvbXB1dGluZyBkaXN0YW5jZXMgYmV0d2VlbiBwb2ludHMuIFRoZSBhbGdvcml0aG0gc2hvdWxkIGlkZW50aWZ5IGNvcmUgcG9pbnRzLCBleHBhbmQgY2x1c3RlcnMgZnJvbSBjb3JlIHBvaW50cywgYW5kIG1hcmsgcmVtYWluaW5nIHBvaW50cyBhcyBub2lzZS4=",
  "id": "259",
  "test_cases": [
    {
      "test": "import numpy as np\nX = np.array([[1, 1], [1.5, 1.5], [2, 1], [8, 8], [8.5, 8.5], [9, 8]])\nprint(dbscan(X, eps=2.0, min_samples=2))",
      "expected_output": "[0 0 0 1 1 1]"
    },
    {
      "test": "import numpy as np\nX = np.array([[1, 1], [1.5, 1.5], [2, 1], [8, 8], [8.5, 8.5], [100, 100]])\nprint(dbscan(X, eps=2.0, min_samples=2))",
      "expected_output": "[ 0  0  0  1  1 -1]"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "X = np.array([[1, 1], [1.5, 1.5], [2, 1], [8, 8], [8.5, 8.5], [9, 8]])\neps = 2.0\nmin_samples = 2\nprint(dbscan(X, eps, min_samples))",
    "output": "[0 0 0 1 1 1]",
    "reasoning": "Points [1,1], [1.5,1.5], and [2,1] are close together (within eps=2.0 of each other) and each has at least 2 neighbors, so they form cluster 0. Similarly, points [8,8], [8.5,8.5], and [9,8] are close together and form cluster 1. No points are marked as noise since all belong to dense regions."
  },
  "category": "Machine Learning",
  "starter_code": "import numpy as np\n\ndef dbscan(X: np.ndarray, eps: float, min_samples: int) -> np.ndarray:\n    \"\"\"\n    Implement DBSCAN clustering algorithm.\n    \n    Parameters:\n    - X: 2D numpy array of shape (n_samples, n_features)\n    - eps: Maximum distance between two samples to be considered neighbors\n    - min_samples: Minimum number of samples in a neighborhood for a core point\n    \n    Returns:\n    - labels: 1D numpy array of cluster labels (-1 for noise points)\n    \"\"\"\n    # Your code here\n    pass",
  "title": "Implement DBSCAN Clustering Algorithm",
  "createdAt": "December 14, 2025 at 1:18:30â€¯PM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "learn_section": "IyMgREJTQ0FOIENsdXN0ZXJpbmcgQWxnb3JpdGhtCgojIyMgT3ZlcnZpZXcKREJTQ0FOIChEZW5zaXR5LUJhc2VkIFNwYXRpYWwgQ2x1c3RlcmluZyBvZiBBcHBsaWNhdGlvbnMgd2l0aCBOb2lzZSkgaXMgYSBwb3B1bGFyIGNsdXN0ZXJpbmcgYWxnb3JpdGhtIHRoYXQgZ3JvdXBzIHRvZ2V0aGVyIHBvaW50cyB0aGF0IGFyZSBjbG9zZWx5IHBhY2tlZCB0b2dldGhlciwgbWFya2luZyBwb2ludHMgaW4gbG93LWRlbnNpdHkgcmVnaW9ucyBhcyBvdXRsaWVycyAobm9pc2UpLgoKIyMjIEtleSBDb25jZXB0cwoKKioxLiBDb3JlIFBvaW50cyoqCkEgcG9pbnQgJHAkIGlzIGEgY29yZSBwb2ludCBpZiBhdCBsZWFzdCBgbWluX3NhbXBsZXNgIHBvaW50cyAoaW5jbHVkaW5nICRwJCBpdHNlbGYpIGFyZSB3aXRoaW4gZGlzdGFuY2UgJFxlcHNpbG9uJCAoZXBzKSBmcm9tIGl0OgokJHxOX3tcZXBzaWxvbn0ocCl8IFxnZXEgXHRleHR7bWluXF9zYW1wbGVzfSQkCndoZXJlICROX3tcZXBzaWxvbn0ocCkgPSBce3EgXGluIEQgOiBcdGV4dHtkaXN0fShwLCBxKSBcbGVxIFxlcHNpbG9uXH0kCgoqKjIuIERpcmVjdGx5IERlbnNpdHktUmVhY2hhYmxlKioKQSBwb2ludCAkcSQgaXMgZGlyZWN0bHkgZGVuc2l0eS1yZWFjaGFibGUgZnJvbSAkcCQgaWY6Ci0gJHAkIGlzIGEgY29yZSBwb2ludAotICRxIFxpbiBOX3tcZXBzaWxvbn0ocCkkCgoqKjMuIERlbnNpdHktUmVhY2hhYmxlKioKQSBwb2ludCAkcSQgaXMgZGVuc2l0eS1yZWFjaGFibGUgZnJvbSAkcCQgaWYgdGhlcmUgZXhpc3RzIGEgY2hhaW4gb2YgcG9pbnRzICRwXzEsIHBfMiwgLi4uLCBwX24kIHdoZXJlICRwXzEgPSBwJCwgJHBfbiA9IHEkLCBhbmQgZWFjaCAkcF97aSsxfSQgaXMgZGlyZWN0bHkgZGVuc2l0eS1yZWFjaGFibGUgZnJvbSAkcF9pJC4KCioqNC4gTm9pc2UgUG9pbnRzKioKUG9pbnRzIHRoYXQgYXJlIG5vdCByZWFjaGFibGUgZnJvbSBhbnkgY29yZSBwb2ludCBhcmUgbGFiZWxlZCBhcyBub2lzZSAoLTEpLgoKIyMjIEFsZ29yaXRobSBTdGVwcwoKMS4gRm9yIGVhY2ggdW52aXNpdGVkIHBvaW50ICRwJDoKICAgLSBNYXJrICRwJCBhcyB2aXNpdGVkCiAgIC0gRmluZCBhbGwgbmVpZ2hib3JzIHdpdGhpbiAkXGVwc2lsb24kCiAgIC0gSWYgJHxcdGV4dHtuZWlnaGJvcnN9fCA8IFx0ZXh0e21pblxfc2FtcGxlc30kOiBtYXJrIGFzIG5vaXNlIChtYXkgY2hhbmdlIGxhdGVyKQogICAtIEVsc2U6IGNyZWF0ZSBuZXcgY2x1c3RlciBhbmQgZXhwYW5kIGl0CgoyLiBFeHBhbmQgY2x1c3RlcjoKICAgLSBBZGQgYWxsIG5laWdoYm9ycyB0byBjbHVzdGVyCiAgIC0gRm9yIGVhY2ggbmVpZ2hib3IgdGhhdCBpcyBhIGNvcmUgcG9pbnQsIHJlY3Vyc2l2ZWx5IGFkZCBpdHMgbmVpZ2hib3JzCgojIyMgRGlzdGFuY2UgTWV0cmljClR5cGljYWxseSB1c2VzIEV1Y2xpZGVhbiBkaXN0YW5jZToKJCRkKHAsIHEpID0gXHNxcnR7XHN1bV97aT0xfV57bn0ocF9pIC0gcV9pKV4yfSQkCgojIyMgQWR2YW50YWdlcwotIERvZXMgbm90IHJlcXVpcmUgc3BlY2lmeWluZyBudW1iZXIgb2YgY2x1c3RlcnMKLSBDYW4gZmluZCBhcmJpdHJhcmlseSBzaGFwZWQgY2x1c3RlcnMKLSBSb2J1c3QgdG8gb3V0bGllcnMKLSBPbmx5IHR3byBwYXJhbWV0ZXJzOiAkXGVwc2lsb24kIGFuZCBtaW5fc2FtcGxlcwoKIyMjIFRpbWUgQ29tcGxleGl0eQotIFdpdGhvdXQgc3BhdGlhbCBpbmRleGluZzogJE8obl4yKSQKLSBXaXRoIHNwYXRpYWwgaW5kZXhpbmcgKGUuZy4sIEtELXRyZWUpOiAkTyhuIFxsb2cgbikk",
  "description_decoded": "Write a Python function `dbscan` that implements the Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm. The function should take a 2D numpy array `X` representing the data points of shape (n_samples, n_features), a float `eps` representing the maximum distance between two samples for them to be considered neighbors, and an integer `min_samples` representing the minimum number of points required to form a dense region (core point). The function should return a 1D numpy array of cluster labels where -1 indicates noise points (points that don't belong to any cluster). Use Euclidean distance for computing distances between points. The algorithm should identify core points, expand clusters from core points, and mark remaining points as noise.",
  "learn_section_decoded": "## DBSCAN Clustering Algorithm\n\n### Overview\nDBSCAN (Density-Based Spatial Clustering of Applications with Noise) is a popular clustering algorithm that groups together points that are closely packed together, marking points in low-density regions as outliers (noise).\n\n### Key Concepts\n\n**1. Core Points**\nA point $p$ is a core point if at least `min_samples` points (including $p$ itself) are within distance $\\epsilon$ (eps) from it:\n$$|N_{\\epsilon}(p)| \\geq \\text{min\\_samples}$$\nwhere $N_{\\epsilon}(p) = \\{q \\in D : \\text{dist}(p, q) \\leq \\epsilon\\}$\n\n**2. Directly Density-Reachable**\nA point $q$ is directly density-reachable from $p$ if:\n- $p$ is a core point\n- $q \\in N_{\\epsilon}(p)$\n\n**3. Density-Reachable**\nA point $q$ is density-reachable from $p$ if there exists a chain of points $p_1, p_2, ..., p_n$ where $p_1 = p$, $p_n = q$, and each $p_{i+1}$ is directly density-reachable from $p_i$.\n\n**4. Noise Points**\nPoints that are not reachable from any core point are labeled as noise (-1).\n\n### Algorithm Steps\n\n1. For each unvisited point $p$:\n   - Mark $p$ as visited\n   - Find all neighbors within $\\epsilon$\n   - If $|\\text{neighbors}| < \\text{min\\_samples}$: mark as noise (may change later)\n   - Else: create new cluster and expand it\n\n2. Expand cluster:\n   - Add all neighbors to cluster\n   - For each neighbor that is a core point, recursively add its neighbors\n\n### Distance Metric\nTypically uses Euclidean distance:\n$$d(p, q) = \\sqrt{\\sum_{i=1}^{n}(p_i - q_i)^2}$$\n\n### Advantages\n- Does not require specifying number of clusters\n- Can find arbitrarily shaped clusters\n- Robust to outliers\n- Only two parameters: $\\epsilon$ and min_samples\n\n### Time Complexity\n- Without spatial indexing: $O(n^2)$\n- With spatial indexing (e.g., KD-tree): $O(n \\log n)$"
}