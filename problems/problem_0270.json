{
  "description": "SW4gcHJvZHVjdGlvbiBNTE9wcyBzeXN0ZW1zLCBNTCBwaXBlbGluZXMgY29uc2lzdCBvZiBtdWx0aXBsZSBpbnRlcmRlcGVuZGVudCB0YXNrcyAoZGF0YSBsb2FkaW5nLCBmZWF0dXJlIGVuZ2luZWVyaW5nLCB0cmFpbmluZywgZXZhbHVhdGlvbiwgZXRjLikgb3JnYW5pemVkIGFzIGEgRGlyZWN0ZWQgQWN5Y2xpYyBHcmFwaCAoREFHKS4gVW5kZXJzdGFuZGluZyB0YXNrIGRlcGVuZGVuY2llcywgZXhlY3V0aW9uIG9yZGVyLCBhbmQgdGhlIGNyaXRpY2FsIHBhdGggaXMgZXNzZW50aWFsIGZvciBwaXBlbGluZSBvcHRpbWl6YXRpb24gYW5kIHJlc291cmNlIGFsbG9jYXRpb24uCgpHaXZlbiBhIGxpc3Qgb2YgcGlwZWxpbmUgdGFza3Mgd2hlcmUgZWFjaCB0YXNrIGhhcyBhbiBJRCwgZHVyYXRpb24sIGFuZCBsaXN0IG9mIGRlcGVuZGVuY2llcyAodGFzayBJRHMgdGhhdCBtdXN0IGNvbXBsZXRlIGJlZm9yZSB0aGlzIHRhc2sgY2FuIHN0YXJ0KSwgaW1wbGVtZW50IGEgZnVuY3Rpb24gYGFuYWx5emVfbWxfcGlwZWxpbmUodGFza3MpYCB0aGF0IHBlcmZvcm1zIGNvbXBsZXRlIHBpcGVsaW5lIGFuYWx5c2lzLgoKVGhlIGZ1bmN0aW9uIHNob3VsZCBjb21wdXRlOgoKMS4gKipFeGVjdXRpb24gT3JkZXIqKjogQSB2YWxpZCB0b3BvbG9naWNhbCBvcmRlcmluZyBvZiB0YXNrcyAodXNlIGFscGhhYmV0aWNhbCBvcmRlcmluZyB3aGVuIG11bHRpcGxlIHRhc2tzIGFyZSBhdmFpbGFibGUpCgoyLiAqKkVhcmxpZXN0IFN0YXJ0L0ZpbmlzaCBUaW1lcyoqOiBGb3IgZWFjaCB0YXNrLCB0aGUgZWFybGllc3QgcG9zc2libGUgc3RhcnQgYW5kIGZpbmlzaCB0aW1lcyBhc3N1bWluZyB0YXNrcyBzdGFydCBhcyBzb29uIGFzIGRlcGVuZGVuY2llcyBjb21wbGV0ZQoKMy4gKipMYXRlc3QgU3RhcnQvRmluaXNoIFRpbWVzKio6IEZvciBlYWNoIHRhc2ssIHRoZSBsYXRlc3QgdGltZXMgdGhlIHRhc2sgY2FuIHN0YXJ0L2ZpbmlzaCB3aXRob3V0IGRlbGF5aW5nIHRoZSBvdmVyYWxsIHBpcGVsaW5lCgo0LiAqKlNsYWNrIFRpbWUqKjogRm9yIGVhY2ggdGFzaywgdGhlIGFtb3VudCBvZiB0aW1lIHRoZSB0YXNrIGNhbiBiZSBkZWxheWVkIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBtYWtlc3BhbgoKNS4gKipDcml0aWNhbCBQYXRoKio6IFRoZSBzZXF1ZW5jZSBvZiB0YXNrcyB3aXRoIHplcm8gc2xhY2sgdGhhdCBkZXRlcm1pbmVzIHRoZSBtaW5pbXVtIHBpcGVsaW5lIGR1cmF0aW9uCgo2LiAqKk1ha2VzcGFuKio6IFRoZSB0b3RhbCB0aW1lIHJlcXVpcmVkIHRvIGNvbXBsZXRlIGFsbCB0YXNrcwoKSWYgdGhlIGlucHV0IGlzIGVtcHR5LCByZXR1cm4gYSByZXN1bHQgd2l0aCBlbXB0eSBjb2xsZWN0aW9ucyBhbmQgbWFrZXNwYW4gb2YgMC4gQXNzdW1lIHRoZSBpbnB1dCBEQUcgaGFzIG5vIGN5Y2xlcy4=",
  "id": "270",
  "test_cases": [
    {
      "test": "tasks = [{'id': 'A', 'duration': 10, 'dependencies': []}, {'id': 'B', 'duration': 20, 'dependencies': ['A']}, {'id': 'C', 'duration': 15, 'dependencies': ['B']}]\nresult = analyze_ml_pipeline(tasks)\nprint((result['execution_order'], result['critical_path'], result['makespan']))",
      "expected_output": "(['A', 'B', 'C'], ['A', 'B', 'C'], 45)"
    },
    {
      "test": "tasks = [{'id': 'start', 'duration': 2, 'dependencies': []}, {'id': 'left', 'duration': 5, 'dependencies': ['start']}, {'id': 'right', 'duration': 10, 'dependencies': ['start']}, {'id': 'end', 'duration': 3, 'dependencies': ['left', 'right']}]\nresult = analyze_ml_pipeline(tasks)\nprint((result['critical_path'], result['slack']['left'], result['makespan']))",
      "expected_output": "(['start', 'right', 'end'], 5, 15)"
    }
  ],
  "difficulty": "hard",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "tasks = [{'id': 'start', 'duration': 2, 'dependencies': []}, {'id': 'left', 'duration': 5, 'dependencies': ['start']}, {'id': 'right', 'duration': 10, 'dependencies': ['start']}, {'id': 'end', 'duration': 3, 'dependencies': ['left', 'right']}]",
    "output": "{'execution_order': ['start', 'left', 'right', 'end'], 'earliest_start': {'start': 0, 'left': 2, 'right': 2, 'end': 12}, 'earliest_finish': {'start': 2, 'left': 7, 'right': 12, 'end': 15}, 'latest_start': {'start': 0, 'left': 7, 'right': 2, 'end': 12}, 'latest_finish': {'start': 2, 'left': 12, 'right': 12, 'end': 15}, 'slack': {'start': 0, 'left': 5, 'right': 0, 'end': 0}, 'critical_path': ['start', 'right', 'end'], 'makespan': 15}",
    "reasoning": "The pipeline forms a diamond: start splits into left (5min) and right (10min) branches, both merging at end. Forward pass: start finishes at t=2, left at t=7, right at t=12, end waits for both so starts at t=12 and finishes at t=15. Backward pass from makespan=15: end must finish by 15 (LS=12), right must finish by 12 (LS=2), left can finish as late as 12 (LS=7, slack=5). Critical path follows zero-slack tasks: start->right->end."
  },
  "category": "MLOps",
  "starter_code": "def analyze_ml_pipeline(tasks: list) -> dict:\n    \"\"\"\n    Analyze an ML pipeline DAG for scheduling and critical path.\n    \n    Args:\n        tasks: list of task dicts with:\n            - 'id': task identifier (str)\n            - 'duration': task duration in minutes (int)\n            - 'dependencies': list of task IDs this task depends on\n    \n    Returns:\n        dict with:\n            - 'execution_order': topologically sorted list of task IDs\n            - 'earliest_start': dict mapping task ID to earliest start time\n            - 'earliest_finish': dict mapping task ID to earliest finish time\n            - 'latest_start': dict mapping task ID to latest start time\n            - 'latest_finish': dict mapping task ID to latest finish time\n            - 'slack': dict mapping task ID to slack time\n            - 'critical_path': list of task IDs on critical path (in execution order)\n            - 'makespan': total time to complete pipeline\n    \"\"\"\n    pass",
  "title": "ML Pipeline DAG Scheduler with Critical Path Analysis",
  "createdAt": "December 16, 2025 at 1:00:03â€¯PM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "learn_section": "IyMgTUwgUGlwZWxpbmUgREFHIEFuYWx5c2lzIGFuZCBDcml0aWNhbCBQYXRoIE1ldGhvZAoKSW4gTUxPcHMsIG1hY2hpbmUgbGVhcm5pbmcgcGlwZWxpbmVzIGFyZSBtb2RlbGVkIGFzICoqRGlyZWN0ZWQgQWN5Y2xpYyBHcmFwaHMgKERBR3MpKiogd2hlcmUgbm9kZXMgcmVwcmVzZW50IHRhc2tzIGFuZCBlZGdlcyByZXByZXNlbnQgZGVwZW5kZW5jaWVzLiBVbmRlcnN0YW5kaW5nIHBpcGVsaW5lIHNjaGVkdWxpbmcgaXMgY3J1Y2lhbCBmb3Igb3B0aW1pemF0aW9uIGFuZCByZXNvdXJjZSBwbGFubmluZy4KCiMjIyBUb3BvbG9naWNhbCBTb3J0aW5nCgpBIHRvcG9sb2dpY2FsIHNvcnQgcHJvZHVjZXMgYSBsaW5lYXIgb3JkZXJpbmcgb2YgdmVydGljZXMgc3VjaCB0aGF0IGZvciBldmVyeSBkaXJlY3RlZCBlZGdlICQodSwgdikkLCB2ZXJ0ZXggJHUkIGNvbWVzIGJlZm9yZSAkdiQuICoqS2FobidzIEFsZ29yaXRobSoqIGFjaGlldmVzIHRoaXMgaW4gJE8oViArIEUpJCB0aW1lOgoKMS4gQ2FsY3VsYXRlIGluLWRlZ3JlZSBmb3IgZWFjaCB2ZXJ0ZXgKMi4gQWRkIGFsbCB2ZXJ0aWNlcyB3aXRoIGluLWRlZ3JlZSAwIHRvIGEgcXVldWUKMy4gV2hpbGUgcXVldWUgaXMgbm90IGVtcHR5OgogICAtIFJlbW92ZSB2ZXJ0ZXggJHYkIGZyb20gcXVldWUKICAgLSBBZGQgJHYkIHRvIHJlc3VsdAogICAtIEZvciBlYWNoIG5laWdoYm9yICR1JCBvZiAkdiQ6IGRlY3JlbWVudCBpbi1kZWdyZWUgb2YgJHUkOyBpZiBpbi1kZWdyZWUgYmVjb21lcyAwLCBhZGQgdG8gcXVldWUKCiMjIyBDcml0aWNhbCBQYXRoIE1ldGhvZCAoQ1BNKQoKQ1BNIGlkZW50aWZpZXMgdGhlIGxvbmdlc3QgcGF0aCB0aHJvdWdoIHRoZSBwaXBlbGluZSwgZGV0ZXJtaW5pbmcgdGhlIG1pbmltdW0gY29tcGxldGlvbiB0aW1lLgoKIyMjIyBGb3J3YXJkIFBhc3MgKEVhcmxpZXN0IFRpbWVzKQoKRm9yIGVhY2ggdGFzayAkaSQgaW4gdG9wb2xvZ2ljYWwgb3JkZXI6CgokJEVTX2kgPSBcbWF4X3tqIFxpbiBcdGV4dHtwcmVkfShpKX0gRUZfaiQkCgokJEVGX2kgPSBFU19pICsgZF9pJCQKCndoZXJlICRFU19pJCBpcyBlYXJsaWVzdCBzdGFydCwgJEVGX2kkIGlzIGVhcmxpZXN0IGZpbmlzaCwgJGRfaSQgaXMgZHVyYXRpb24sIGFuZCAkXHRleHR7cHJlZH0oaSkkIGFyZSBwcmVkZWNlc3NvcnMuCgojIyMjIEJhY2t3YXJkIFBhc3MgKExhdGVzdCBUaW1lcykKCkZvciBlYWNoIHRhc2sgJGkkIGluIHJldmVyc2UgdG9wb2xvZ2ljYWwgb3JkZXI6CgokJExGX2kgPSBcbWluX3tqIFxpbiBcdGV4dHtzdWNjfShpKX0gTFNfaiQkCgokJExTX2kgPSBMRl9pIC0gZF9pJCQKCndoZXJlICRMRl9pJCBpcyBsYXRlc3QgZmluaXNoLCAkTFNfaSQgaXMgbGF0ZXN0IHN0YXJ0LCBhbmQgJFx0ZXh0e3N1Y2N9KGkpJCBhcmUgc3VjY2Vzc29ycy4KCiMjIyMgU2xhY2sgYW5kIENyaXRpY2FsIFBhdGgKCioqU2xhY2sqKiAob3IgZmxvYXQpIG1lYXN1cmVzIHNjaGVkdWxpbmcgZmxleGliaWxpdHk6CgokJFx0ZXh0e1NsYWNrfV9pID0gTFNfaSAtIEVTX2kgPSBMRl9pIC0gRUZfaSQkCgpUaGUgKipjcml0aWNhbCBwYXRoKiogY29uc2lzdHMgb2YgYWxsIHRhc2tzIHdpdGggemVybyBzbGFjay4gVGhlc2UgdGFza3MgZGV0ZXJtaW5lIHRoZSAqKm1ha2VzcGFuKiogKHRvdGFsIHBpcGVsaW5lIGR1cmF0aW9uKToKCiQkXHRleHR7TWFrZXNwYW59ID0gXG1heF9pIEVGX2kkJAoKIyMjIE1MT3BzIEFwcGxpY2F0aW9ucwoKMS4gKipQaXBlbGluZSBPcHRpbWl6YXRpb24qKjogRm9jdXMgb3B0aW1pemF0aW9uIGVmZm9ydHMgb24gY3JpdGljYWwgcGF0aCB0YXNrcwoyLiAqKlJlc291cmNlIEFsbG9jYXRpb24qKjogUHJpb3JpdGl6ZSByZXNvdXJjZXMgZm9yIHplcm8tc2xhY2sgdGFza3MKMy4gKipTTEEgUGxhbm5pbmcqKjogTWFrZXNwYW4gZGV0ZXJtaW5lcyBtaW5pbXVtIHBpcGVsaW5lIHJ1bnRpbWUKNC4gKipQYXJhbGxlbGl6YXRpb24qKjogVGFza3Mgd2l0aCBoaWdoIHNsYWNrIGNhbiBiZSBwYXJhbGxlbGl6ZWQgb3IgZGVsYXllZAo1LiAqKk1vbml0b3JpbmcqKjogQWxlcnQgd2hlbiBjcml0aWNhbCBwYXRoIHRhc2tzIGFyZSBkZWxheWVkCgojIyMgQ29tcGxleGl0eSBBbmFseXNpcwoKLSAqKlRpbWUgQ29tcGxleGl0eSoqOiAkTyhWICsgRSkkIGZvciB0b3BvbG9naWNhbCBzb3J0IHBsdXMgJE8oVikkIGZvciBmb3J3YXJkL2JhY2t3YXJkIHBhc3NlcwotICoqU3BhY2UgQ29tcGxleGl0eSoqOiAkTyhWICsgRSkkIGZvciBncmFwaCByZXByZXNlbnRhdGlvbg==",
  "description_decoded": "In production MLOps systems, ML pipelines consist of multiple interdependent tasks (data loading, feature engineering, training, evaluation, etc.) organized as a Directed Acyclic Graph (DAG). Understanding task dependencies, execution order, and the critical path is essential for pipeline optimization and resource allocation.\n\nGiven a list of pipeline tasks where each task has an ID, duration, and list of dependencies (task IDs that must complete before this task can start), implement a function `analyze_ml_pipeline(tasks)` that performs complete pipeline analysis.\n\nThe function should compute:\n\n1. **Execution Order**: A valid topological ordering of tasks (use alphabetical ordering when multiple tasks are available)\n\n2. **Earliest Start/Finish Times**: For each task, the earliest possible start and finish times assuming tasks start as soon as dependencies complete\n\n3. **Latest Start/Finish Times**: For each task, the latest times the task can start/finish without delaying the overall pipeline\n\n4. **Slack Time**: For each task, the amount of time the task can be delayed without affecting the makespan\n\n5. **Critical Path**: The sequence of tasks with zero slack that determines the minimum pipeline duration\n\n6. **Makespan**: The total time required to complete all tasks\n\nIf the input is empty, return a result with empty collections and makespan of 0. Assume the input DAG has no cycles.",
  "learn_section_decoded": "## ML Pipeline DAG Analysis and Critical Path Method\n\nIn MLOps, machine learning pipelines are modeled as **Directed Acyclic Graphs (DAGs)** where nodes represent tasks and edges represent dependencies. Understanding pipeline scheduling is crucial for optimization and resource planning.\n\n### Topological Sorting\n\nA topological sort produces a linear ordering of vertices such that for every directed edge $(u, v)$, vertex $u$ comes before $v$. **Kahn's Algorithm** achieves this in $O(V + E)$ time:\n\n1. Calculate in-degree for each vertex\n2. Add all vertices with in-degree 0 to a queue\n3. While queue is not empty:\n   - Remove vertex $v$ from queue\n   - Add $v$ to result\n   - For each neighbor $u$ of $v$: decrement in-degree of $u$; if in-degree becomes 0, add to queue\n\n### Critical Path Method (CPM)\n\nCPM identifies the longest path through the pipeline, determining the minimum completion time.\n\n#### Forward Pass (Earliest Times)\n\nFor each task $i$ in topological order:\n\n$$ES_i = \\max_{j \\in \\text{pred}(i)} EF_j$$\n\n$$EF_i = ES_i + d_i$$\n\nwhere $ES_i$ is earliest start, $EF_i$ is earliest finish, $d_i$ is duration, and $\\text{pred}(i)$ are predecessors.\n\n#### Backward Pass (Latest Times)\n\nFor each task $i$ in reverse topological order:\n\n$$LF_i = \\min_{j \\in \\text{succ}(i)} LS_j$$\n\n$$LS_i = LF_i - d_i$$\n\nwhere $LF_i$ is latest finish, $LS_i$ is latest start, and $\\text{succ}(i)$ are successors.\n\n#### Slack and Critical Path\n\n**Slack** (or float) measures scheduling flexibility:\n\n$$\\text{Slack}_i = LS_i - ES_i = LF_i - EF_i$$\n\nThe **critical path** consists of all tasks with zero slack. These tasks determine the **makespan** (total pipeline duration):\n\n$$\\text{Makespan} = \\max_i EF_i$$\n\n### MLOps Applications\n\n1. **Pipeline Optimization**: Focus optimization efforts on critical path tasks\n2. **Resource Allocation**: Prioritize resources for zero-slack tasks\n3. **SLA Planning**: Makespan determines minimum pipeline runtime\n4. **Parallelization**: Tasks with high slack can be parallelized or delayed\n5. **Monitoring**: Alert when critical path tasks are delayed\n\n### Complexity Analysis\n\n- **Time Complexity**: $O(V + E)$ for topological sort plus $O(V)$ for forward/backward passes\n- **Space Complexity**: $O(V + E)$ for graph representation"
}