{
  "description": "SW1wbGVtZW50IFBUWCAoUHJlLXRyYWluaW5nKSBMb3NzIHRvIHByZXZlbnQgY2F0YXN0cm9waGljIGZvcmdldHRpbmcgZHVyaW5nIFJMSEYuIFBUWCBMb3NzIGNvbWJpbmVzIHJlaW5mb3JjZW1lbnQgbGVhcm5pbmcgb2JqZWN0aXZlcyB3aXRoIGNyb3NzLWVudHJvcHkgbG9zcyBvbiBwcmUtdHJhaW5pbmcgZGF0YSwgbWFpbnRhaW5pbmcgZ2VuZXJhbCBsYW5ndWFnZSBjYXBhYmlsaXRpZXMgd2hpbGUgb3B0aW1pemluZyBmb3IgcmV3YXJkLiBHaXZlbiBSTCBsb3NzLCBtb2RlbCBsb2dpdHMgb24gcHJlLXRyYWluaW5nIGJhdGNoLCB0cnVlIGxhYmVscywgYW5kIGJldGEgY29lZmZpY2llbnQsIGNvbXB1dGUgdG90YWwgbG9zcy4gVXNlZCBpbiBJbnN0cnVjdEdQVCwgQ2hhdEdQVCwgS2ltaSBLMiwgYW5kIG90aGVyIFJMSEYgc3lzdGVtcy4=",
  "id": "232",
  "test_cases": [
    {
      "test": "logits = np.array([[10.0, 0.0, 0.0], [0.0, 10.0, 0.0]]); labels = np.array([0, 1]); total, ce, weighted = compute_ptx_loss(0.5, logits, labels, 0.1); print(f'{total:.6f}')",
      "expected_output": "0.500009"
    },
    {
      "test": "logits = np.array([[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]); labels = np.array([0, 2]); total, ce, weighted = compute_ptx_loss(0.3, logits, labels, 0.2); print(f'{total:.6f}')",
      "expected_output": "0.519722"
    }
  ],
  "difficulty": "medium",
  "pytorch_difficulty": "easy",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "rl_loss=0.5, logits=[[10,0,0],[0,10,0]], labels=[0,1], beta=0.1",
    "output": "(0.500009, 0.000091, 0.000009)",
    "reasoning": "Perfect predictions. Softmax gives ~[1,0,0] and ~[0,1,0]. CE: -log(1)0 for both. Average CE0. Total: 0.5 + 0.1*0  0.5. Minimal PTX penalty for correct predictions."
  },
  "category": "Deep Learning",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCmltcG9ydCB0b3JjaC5ubi5mdW5jdGlvbmFsIGFzIEYKCmRlZiBjb21wdXRlX3B0eF9sb3NzX3B5dG9yY2goCiAgICBybF9sb3NzOiB0b3JjaC5UZW5zb3IsCiAgICBwcmV0cmFpbl9sb2dpdHM6IHRvcmNoLlRlbnNvciwKICAgIHByZXRyYWluX2xhYmVsczogdG9yY2guVGVuc29yLAogICAgYmV0YV9wdHg6IGZsb2F0ID0gMC4xCikgLT4gdHVwbGVbdG9yY2guVGVuc29yLCB0b3JjaC5UZW5zb3IsIHRvcmNoLlRlbnNvcl06CgkiIiIKCUNvbXB1dGUgUFRYIExvc3MgdXNpbmcgUHlUb3JjaC4KCQoJQXJnczoKCQlybF9sb3NzOiBSTCBsb3NzIHRlbnNvciAoc2NhbGFyKQoJCXByZXRyYWluX2xvZ2l0czogU2hhcGUgKGJhdGNoX3NpemUsIHZvY2FiX3NpemUpCgkJcHJldHJhaW5fbGFiZWxzOiBTaGFwZSAoYmF0Y2hfc2l6ZSwpCgkJYmV0YV9wdHg6IFdlaWdodCBjb2VmZmljaWVudAoJCglSZXR1cm5zOgoJCSh0b3RhbF9sb3NzLCBjZV9sb3NzLCB3ZWlnaHRlZF9jZV9sb3NzKSBhcyB0ZW5zb3JzCgkJCglIaW50czoKCQktIFVzZSBGLmNyb3NzX2VudHJvcHkoKSBmb3IgbnVtZXJpY2FsIHN0YWJpbGl0eQoJCS0gY3Jvc3NfZW50cm9weSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgc29mdG1heAoJCS0gcmVkdWN0aW9uPSdtZWFuJyBmb3IgYmF0Y2ggYXZlcmFnaW5nCgkiIiIKCSMgWW91ciBjb2RlIGhlcmUKCXBhc3M=",
  "title": "PTX Loss for Catastrophic Forgetting Prevention (RLHF)",
  "createdAt": "December 11, 2025 at 2:06:00â€¯PM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "logits = torch.tensor([[10.0, 0.0, 0.0], [0.0, 10.0, 0.0]]); labels = torch.tensor([0, 1], dtype=torch.long); rl_loss = torch.tensor(0.5); total, ce, weighted = compute_ptx_loss_pytorch(rl_loss, logits, labels, 0.1); print(f'{total.item():.6f}')",
      "expected_output": "0.500009"
    },
    {
      "test": "logits = torch.tensor([[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]); labels = torch.tensor([0, 2], dtype=torch.long); rl_loss = torch.tensor(0.3); total, ce, weighted = compute_ptx_loss_pytorch(rl_loss, logits, labels, 0.2); print(f'{total.item():.6f}')",
      "expected_output": "0.519722"
    },
    {
      "test": "logits = torch.tensor([[0.0, 10.0], [10.0, 0.0]]); labels = torch.tensor([0, 0], dtype=torch.long); rl_loss = torch.tensor(1.0); total, ce, weighted = compute_ptx_loss_pytorch(rl_loss, logits, labels, 0.15); print(f'{total.item():.6f}')",
      "expected_output": "1.750007"
    },
    {
      "test": "logits = torch.tensor([[2.0, 1.0], [1.0, 2.0]]); labels = torch.tensor([0, 1], dtype=torch.long); rl_loss = torch.tensor(0.8); total, ce, weighted = compute_ptx_loss_pytorch(rl_loss, logits, labels, 0.5); print(f'{weighted.item():.6f}')",
      "expected_output": "0.156631"
    },
    {
      "test": "logits = torch.tensor([[3.0, 1.0, 0.0], [1.0, 3.0, 0.0], [0.0, 1.0, 3.0], [2.0, 2.0, 2.0]]); labels = torch.tensor([0, 1, 2, 1], dtype=torch.long); rl_loss = torch.tensor(0.6); total, ce, weighted = compute_ptx_loss_pytorch(rl_loss, logits, labels, 0.1); print(f'{ce.item():.6f}')",
      "expected_output": "0.402038"
    }
  ],
  "learn_section": "IyMjIFBUWCAoUHJlLXRyYWluaW5nKSBMb3NzIGZvciBSTEhGCgpQVFggKFByZS10cmFpbmluZykgTG9zcyBwcmV2ZW50cyBjYXRhc3Ryb3BoaWMgZm9yZ2V0dGluZyBkdXJpbmcgcmVpbmZvcmNlbWVudCBsZWFybmluZyBmcm9tIGh1bWFuIGZlZWRiYWNrIChSTEhGKSBieSBjb21iaW5pbmcgUkwgb2JqZWN0aXZlcyB3aXRoIGxhbmd1YWdlIG1vZGVsaW5nIG9uIHByZS10cmFpbmluZyBkYXRhLgoKIyMjIyBUaGUgQ2F0YXN0cm9waGljIEZvcmdldHRpbmcgUHJvYmxlbQoKV2hlbiBmaW5lLXR1bmluZyBsYW5ndWFnZSBtb2RlbHMgd2l0aCByZWluZm9yY2VtZW50IGxlYXJuaW5nOgoKKipXaXRob3V0IFBUWCBMb3NzKio6Ci0gTW9kZWwgb3B0aW1pemVzIHB1cmVseSBmb3IgcmV3YXJkIHNpZ25hbAotIEZvcmdldHMgYmFzaWMgbGFuZ3VhZ2UgY2FwYWJpbGl0aWVzIChncmFtbWFyLCBzcGVsbGluZywgZmFjdHVhbCBrbm93bGVkZ2UpCi0gTG9zZXMgZ2VuZXJhbCBpbnRlbGxpZ2VuY2Ugd2hpbGUgbWF4aW1pemluZyBzcGVjaWZpYyByZXdhcmQKLSBSZXN1bHRzIGluIGRlZ3JhZGVkIG92ZXJhbGwgcGVyZm9ybWFuY2UKCioqRXhhbXBsZSoqOiBBIGNoYXRib3QgdHJhaW5lZCBvbmx5IHdpdGggUkwgbWlnaHQ6Ci0gRm9yZ2V0IGhvdyB0byBzcGVsbCBjb21tb24gd29yZHMKLSBMb3NlIGZhY3R1YWwga25vd2xlZGdlCi0gR2VuZXJhdGUgZ3JhbW1hdGljYWxseSBpbmNvcnJlY3Qgc2VudGVuY2VzCi0gT25seSBwcm9kdWNlIHJlc3BvbnNlcyB0aGF0IGdhbWUgdGhlIHJld2FyZCBtb2RlbAoKIyMjIyBQVFggTG9zcyBGb3JtdWxhCgokJApMX3tcdGV4dHt0b3RhbH19ID0gTF97XHRleHR7Ukx9fShcdGhldGEpICsgXGJldGFfe1x0ZXh0e3B0eH19IFxjZG90IExfe1x0ZXh0e0NFfX0oXHRoZXRhLCBEX3tcdGV4dHtwcmV0cmFpbn19KQokJAoKV2hlcmU6Ci0gJExfe1x0ZXh0e1JMfX0oXHRoZXRhKSQgPSBSZWluZm9yY2VtZW50IGxlYXJuaW5nIGxvc3MgKGUuZy4sIFBQTyBvYmplY3RpdmUpCi0gJExfe1x0ZXh0e0NFfX0oXHRoZXRhLCBEX3tcdGV4dHtwcmV0cmFpbn19KSQgPSBDcm9zcy1lbnRyb3B5IGxvc3Mgb24gcHJlLXRyYWluaW5nIGRhdGEKLSAkXGJldGFfe1x0ZXh0e3B0eH19JCA9IFdlaWdodCBjb2VmZmljaWVudCAodHlwaWNhbGx5IDAuMDUtMC4yKQotICRcdGhldGEkID0gTW9kZWwgcGFyYW1ldGVycwoKKipLZXkgaW5zaWdodCoqOiBNYWludGFpbnMgbGFuZ3VhZ2UgbW9kZWxpbmcgYWJpbGl0eSB3aGlsZSBvcHRpbWl6aW5nIGZvciByZXdhcmQuCgojIyMjIENyb3NzLUVudHJvcHkgTG9zcyBDb21wb25lbnQKClRoZSBjcm9zcy1lbnRyb3B5IGxvc3Mgb24gcHJlLXRyYWluaW5nIGRhdGE6CgokJApMX3tcdGV4dHtDRX19ID0gLVxmcmFjezF9e059IFxzdW1fe2k9MX1ee059IFxsb2cgUCh5X2kgfCB4X2k7IFx0aGV0YSkKJCQKCioqQ29tcHV0YXRpb24qKjoKCioqU3RlcCAxKio6IEFwcGx5IHNvZnRtYXggdG8gbG9naXRzCiQkClAoeV9qKSA9IFxmcmFje2Vee3pfan19e1xzdW1fayBlXnt6X2t9fQokJAoKKipTdGVwIDIqKjogQ29tcHV0ZSBuZWdhdGl2ZSBsb2ctbGlrZWxpaG9vZAokJApcdGV4dHtDRX1faSA9IC1cbG9nIFAoeV97XHRleHR7dHJ1ZX0saX0pCiQkCgoqKlN0ZXAgMyoqOiBBdmVyYWdlIG92ZXIgYmF0Y2gKJCQKTF97XHRleHR7Q0V9fSA9IFxmcmFjezF9e059IFxzdW1fe2k9MX1ee059IFx0ZXh0e0NFfV9pCiQkCgojIyMjIEV4YW1wbGUgQ2FsY3VsYXRpb24KCioqU2NlbmFyaW8qKjogTW9kZWwgd2l0aCBwZXJmZWN0IHByZWRpY3Rpb25zIG9uIHByZS10cmFpbmluZyBkYXRhCgoqKkdpdmVuKio6Ci0gUkwgbG9zczogMC41Ci0gTG9naXRzOiBbWzEwLCAwLCAwXSwgWzAsIDEwLCAwXV0gKHZlcnkgY29uZmlkZW50KQotIFRydWUgbGFiZWxzOiBbMCwgMV0gKGNvcnJlY3QpCi0gQmV0YV9wdHg6IDAuMQoKKipTdGVwIDEqKjogQ29tcHV0ZSBwcm9iYWJpbGl0aWVzCi0gU2FtcGxlIDE6IFNvZnRtYXgoWzEwLCAwLCAwXSkgIFsxLjAsIDAuMCwgMC4wXQotIFNhbXBsZSAyOiBTb2Z0bWF4KFswLCAxMCwgMF0pICBbMC4wLCAxLjAsIDAuMF0KCioqU3RlcCAyKio6IENvbXB1dGUgQ0UKLSBTYW1wbGUgMTogLWxvZygxLjApICAwCi0gU2FtcGxlIDI6IC1sb2coMS4wKSAgMAotIEF2ZXJhZ2U6IDAKCioqU3RlcCAzKio6IFRvdGFsIGxvc3MKJCQKTF97XHRleHR7dG90YWx9fSA9IDAuNSArIDAuMSBcdGltZXMgMCA9IDAuNQokJAoKUGVyZmVjdCBwcmVkaWN0aW9ucyAgbWluaW1hbCBQVFggcGVuYWx0eQoKIyMjIyBFZmZlY3Qgb2YgUHJlZGljdGlvbiBRdWFsaXR5CgoqKkhpZ2ggY29uZmlkZW5jZSwgY29ycmVjdCoqIChsb2dpdHMgWzEwLCAwLCAwXSwgbGFiZWwgMCk6Ci0gUHJvYmFiaWxpdHk6IFt+MS4wLCB+MC4wLCB+MC4wXQotIENFOiAtbG9nKDEuMCkgIDAKLSBMb3cgcGVuYWx0eSAoZ29vZCEpCgoqKlVuaWZvcm0gZGlzdHJpYnV0aW9uKiogKGxvZ2l0cyBbMSwgMSwgMV0sIGxhYmVsIDApOgotIFByb2JhYmlsaXR5OiBbMS8zLCAxLzMsIDEvM10KLSBDRTogLWxvZygxLzMpICAxLjA5OQotIE1lZGl1bSBwZW5hbHR5CgoqKkhpZ2ggY29uZmlkZW5jZSwgd3JvbmcqKiAobG9naXRzIFswLCAxMF0sIGxhYmVsIDApOgotIFByb2JhYmlsaXR5OiBbfjAuMCwgfjEuMF0KLSBDRTogLWxvZygwLjApIFwgIHZlcnkgbGFyZ2UKLSBIaWdoIHBlbmFsdHkgKHByZXZlbnRzIGZvcmdldHRpbmchKQoKIyMjIyBDaG9vc2luZyBCZXRhX3B0eAoKVGhlIGNvZWZmaWNpZW50ICRcYmV0YV97XHRleHR7cHR4fX0kIGNvbnRyb2xzIHRoZSB0cmFkZS1vZmY6CgoqKkJldGEgPSAwLjAqKjogTm8gZm9yZ2V0dGluZyBwcmV2ZW50aW9uCi0gUHVyZSBSTCBvcHRpbWl6YXRpb24KLSBGYXN0IHJld2FyZCBpbXByb3ZlbWVudAotIFJpc2sgb2YgY2F0YXN0cm9waGljIGZvcmdldHRpbmcKCioqQmV0YSA9IDAuMDUtMC4xKio6IExpZ2h0IHByZXNlcnZhdGlvbiAodHlwaWNhbCkKLSBNb3N0bHkgUkwtZHJpdmVuCi0gU29tZSBjYXBhYmlsaXR5IG1haW50ZW5hbmNlCi0gR29vZCBiYWxhbmNlIGZvciBtb3N0IHRhc2tzCgoqKkJldGEgPSAwLjItMC41Kio6IFN0cm9uZyBwcmVzZXJ2YXRpb24KLSBFcXVhbCBpbXBvcnRhbmNlIHRvIGNhcGFiaWxpdGllcwotIFNsb3dlciBSTCBpbXByb3ZlbWVudAotIEJldHRlciBmb3IgY29tcGxleCBtb2RlbHMKCioqQmV0YSA9IDEuMCoqOiBFcXVhbCB3ZWlnaHRpbmcKLSBCYWxhbmNlZCBSTCBhbmQgcHJlLXRyYWluaW5nCi0gVmVyeSBjb25zZXJ2YXRpdmUKLSBTbG93ZXN0IGZvcmdldHRpbmcKCioqVHlwaWNhbCBjaG9pY2UqKjogJFxiZXRhX3tcdGV4dHtwdHh9fSA9IDAuMSQgKHVzZWQgaW4gSW5zdHJ1Y3RHUFQsIEtpbWkgSzIpCgojIyMjIFJMSEYgVHJhaW5pbmcgUGlwZWxpbmUKCioqUGhhc2UgMTogU3VwZXJ2aXNlZCBGaW5lLXR1bmluZyAoU0ZUKSoqCi0gVHJhaW4gb24gaGlnaC1xdWFsaXR5IGRlbW9uc3RyYXRpb25zCi0gTG9zczogUHVyZSBjcm9zcy1lbnRyb3B5IG9uIHN1cGVydmlzZWQgZGF0YQotIFJlc3VsdDogTW9kZWwgdGhhdCBpbWl0YXRlcyBkZW1vbnN0cmF0aW9ucwoKKipQaGFzZSAyOiBSZXdhcmQgTW9kZWxpbmcgKFJNKSoqCi0gVHJhaW4gcmV3YXJkIG1vZGVsIG9uIGh1bWFuIHByZWZlcmVuY2VzCi0gTG9zczogQmluYXJ5IGNsYXNzaWZpY2F0aW9uIChwcmVmZXJyZWQgdnMgbm90KQotIFJlc3VsdDogUmV3YXJkIGZ1bmN0aW9uIHRoYXQgY2FwdHVyZXMgaHVtYW4gdmFsdWVzCgoqKlBoYXNlIDM6IFJMIEZpbmUtdHVuaW5nIHdpdGggUFRYKioKLSBPcHRpbWl6ZSBwb2xpY3kgdXNpbmcgcmV3YXJkIG1vZGVsCi0gTG9zczogJExfe1x0ZXh0e3RvdGFsfX0gPSBMX3tcdGV4dHtSTH19ICsgXGJldGFfe1x0ZXh0e3B0eH19IFxjZG90IExfe1x0ZXh0e0NFfX0kCi0gUmVzdWx0OiBNb2RlbCB0aGF0IG1heGltaXplcyByZXdhcmQgd2hpbGUgcHJlc2VydmluZyBjYXBhYmlsaXRpZXMKCioqVHJhaW5pbmcgc3RlcCoqOgoxLiBHZW5lcmF0ZSByZXNwb25zZXMgd2l0aCBjdXJyZW50IHBvbGljeQoyLiBDb21wdXRlIHJld2FyZCBmcm9tIHJld2FyZCBtb2RlbAozLiBDb21wdXRlIFJMIGxvc3MgKFBQTyBjbGlwcGVkIG9iamVjdGl2ZSkKNC4gU2FtcGxlIGJhdGNoIGZyb20gcHJlLXRyYWluaW5nIGRhdGEKNS4gQ29tcHV0ZSBDRSBsb3NzIG9uIHByZS10cmFpbmluZyBiYXRjaAo2LiBDb21iaW5lOiAkTF97XHRleHR7dG90YWx9fSA9IExfe1x0ZXh0e1JMfX0gKyBcYmV0YV97XHRleHR7cHR4fX0gXGNkb3QgTF97XHRleHR7Q0V9fSQKNy4gQmFja3Byb3BhZ2F0ZSBhbmQgdXBkYXRlIG1vZGVsCgojIyMjIFByZS10cmFpbmluZyBEYXRhIFNlbGVjdGlvbgoKKipXaGF0IHRvIGluY2x1ZGUqKjoKLSBSZXByZXNlbnRhdGl2ZSBleGFtcGxlcyBvZiBkZXNpcmVkIGNhcGFiaWxpdGllcwotIEhpZ2gtcXVhbGl0eSwgZGl2ZXJzZSB0ZXh0Ci0gVGFza3MgbW9kZWwgc2hvdWxkIG1haW50YWluIChRQSwgc3VtbWFyaXphdGlvbiwgcmVhc29uaW5nKQotIE1peCBvZiBkb21haW5zIGFuZCBzdHlsZXMKCioqQmF0Y2ggc2l6ZSoqOiAzMi0yNTYgc2FtcGxlcyBwZXIgUkwgYmF0Y2gKCioqRGF0YSBtaXhpbmcqKjogVHlwaWNhbGx5IHNhbXBsZSBmcm9tIHNhbWUgZGlzdHJpYnV0aW9uIGFzIG9yaWdpbmFsIHByZS10cmFpbmluZwoKIyMjIyBSZWFsLVdvcmxkIEV4YW1wbGVzCgoqKkluc3RydWN0R1BUIChPcGVuQUksIDIwMjIpKio6Ci0gVXNlcyBQVFggbG9zcyB3aXRoICRcYmV0YV97XHRleHR7cHR4fX0gXGFwcHJveCAwLjEkCi0gUHJlLXRyYWluaW5nIGRhdGE6IE1peCBvZiBwcm9tcHRzIGFuZCBjb21wbGV0aW9ucwotIFJlc3VsdDogTWFpbnRhaW5zIGhlbHBmdWxuZXNzIHdoaWxlIG9wdGltaXppbmcgZm9yIGh1bWFuIHByZWZlcmVuY2UKCioqS2ltaSBLMiAoTW9vbnNob3QgQUksIDIwMjQpKio6Ci0gRXhwbGljaXQgUFRYIGxvc3MgZm9ybXVsYXRpb24KLSBQcmV2ZW50cyBmb3JnZXR0aW5nIGR1cmluZyBsb25nLWNvbnRleHQgZmluZS10dW5pbmcKLSBDcml0aWNhbCBmb3IgbWFpbnRhaW5pbmcgZ2VuZXJhbCBjYXBhYmlsaXRpZXMKCioqQ2xhdWRlIChBbnRocm9waWMpKio6Ci0gVXNlcyBhdXhpbGlhcnkgb2JqZWN0aXZlcyAoc2ltaWxhciB0byBQVFgpCi0gTWFpbnRhaW5zIGhlbHBmdWxuZXNzLCBoYXJtbGVzc25lc3MsIGhvbmVzdHkgKEhISCkKLSBNdWx0aS1vYmplY3RpdmUgb3B0aW1pemF0aW9uCgojIyMjIEJlbmVmaXRzIG9mIFBUWCBMb3NzCgoqKjEuIFByZXZlbnRzIGNhcGFiaWxpdHkgZGVncmFkYXRpb24qKgotIE1haW50YWlucyBsYW5ndWFnZSBtb2RlbGluZyBxdWFsaXR5Ci0gUHJlc2VydmVzIGZhY3R1YWwga25vd2xlZGdlCi0gS2VlcHMgcmVhc29uaW5nIGFiaWxpdGllcwoKKioyLiBGYXN0ZXIgY29udmVyZ2VuY2UqKgotIFJlZ3VsYXJpemVzIFJMIHRyYWluaW5nCi0gUmVkdWNlcyByZXdhcmQgaGFja2luZwotIE1vcmUgc3RhYmxlIG9wdGltaXphdGlvbgoKKiozLiBCZXR0ZXIgZ2VuZXJhbGl6YXRpb24qKgotIE1vZGVsIHJldGFpbnMgYnJvYWQgY2FwYWJpbGl0aWVzCi0gUGVyZm9ybXMgd2VsbCBvbiBkaXZlcnNlIHRhc2tzCi0gTGVzcyBvdmVyZml0dGluZyB0byByZXdhcmQgbW9kZWwKCioqNC4gTWluaW1hbCBjb21wdXRhdGlvbmFsIG92ZXJoZWFkKioKLSBBZGRzIH4xMC0yMCUgdG8gdHJhaW5pbmcgdGltZQotIFJlcXVpcmVzIHByZS10cmFpbmluZyBkYXRhIHNhbXBsaW5nCi0gV29ydGggdGhlIGNvc3QgZm9yIHF1YWxpdHkgcHJlc2VydmF0aW9uCgojIyMjIENvbW1vbiBQaXRmYWxscwoKKipQaXRmYWxsIDEqKjogQmV0YSB0b28gbG93Ci0gU3ltcHRvbTogTW9kZWwgZm9yZ2V0cyBiYXNpYyBjYXBhYmlsaXRpZXMKLSBTb2x1dGlvbjogSW5jcmVhc2UgJFxiZXRhX3tcdGV4dHtwdHh9fSQgdG8gMC4xLTAuMgoKKipQaXRmYWxsIDIqKjogQmV0YSB0b28gaGlnaAotIFN5bXB0b206IFNsb3cgUkwgaW1wcm92ZW1lbnQsIHJld2FyZCBwbGF0ZWF1cwotIFNvbHV0aW9uOiBEZWNyZWFzZSAkXGJldGFfe1x0ZXh0e3B0eH19JCB0byAwLjA1LTAuMQoKKipQaXRmYWxsIDMqKjogUG9vciBwcmUtdHJhaW5pbmcgZGF0YQotIFN5bXB0b206IE1vZGVsIGxlYXJucyB3cm9uZyBiZWhhdmlvcnMKLSBTb2x1dGlvbjogQ3VyYXRlIGhpZ2gtcXVhbGl0eSwgZGl2ZXJzZSBleGFtcGxlcwoKKipQaXRmYWxsIDQqKjogTWlzbWF0Y2hlZCBiYXRjaCBzaXplcwotIFN5bXB0b206IFVuc3RhYmxlIHRyYWluaW5nCi0gU29sdXRpb246IE1hdGNoIHByZS10cmFpbmluZyBiYXRjaCBzaXplIHRvIFJMIGJhdGNoCgojIyMjIENvbXBhcmlzb24gd2l0aCBBbHRlcm5hdGl2ZXMKCioqUFRYIExvc3MqKiAoVGhpcyBhcHByb2FjaCk6Ci0gUHJvczogU2ltcGxlLCBlZmZlY3RpdmUsIHRoZW9yZXRpY2FsbHkgZ3JvdW5kZWQKLSBDb25zOiBSZXF1aXJlcyBwcmUtdHJhaW5pbmcgZGF0YSwgYWRkcyBjb21wdXRhdGlvbgotIFVzZTogR2VuZXJhbCBSTEhGIHBpcGVsaW5lcwoKKipFbGFzdGljIFdlaWdodCBDb25zb2xpZGF0aW9uIChFV0MpKio6Ci0gUHJvczogTm8gZXh0cmEgZGF0YSBuZWVkZWQKLSBDb25zOiBNb3JlIGNvbXBsZXgsIHNsb3dlcgotIFVzZTogQ29udGludWFsIGxlYXJuaW5nIHNjZW5hcmlvcwoKKipLTCBQZW5hbHR5KiogKGZyb20gcmVmZXJlbmNlIG1vZGVsKToKLSBQcm9zOiBQcmV2ZW50cyBkaXN0cmlidXRpb24gc2hpZnQKLSBDb25zOiBEb2Vzbid0IGV4cGxpY2l0bHkgcHJlc2VydmUgY2FwYWJpbGl0aWVzCi0gVXNlOiBPZnRlbiBjb21iaW5lZCB3aXRoIFBUWAoKKipNaXh0dXJlIG9mIEV4cGVydHMqKjoKLSBQcm9zOiBDYW4gc3BlY2lhbGl6ZSBkaWZmZXJlbnQgZXhwZXJ0cwotIENvbnM6IE11Y2ggbW9yZSBjb21wbGV4IGFyY2hpdGVjdHVyZQotIFVzZTogVmVyeSBsYXJnZSBzY2FsZSBtb2RlbHMKCiMjIyMgTWF0aGVtYXRpY2FsIEluc2lnaHQKClBUWCBsb3NzIGNyZWF0ZXMgYSByZWd1bGFyaXphdGlvbiB0ZXJtOgoKJCQKXG1pbl9cdGhldGEgXG1hdGhiYntFfV97XHBpX1x0aGV0YX0gW1IoeCx5KV0gLSBcYmV0YV97XHRleHR7cHR4fX0gXGNkb3QgRF97XHRleHR7S0x9fShccGlfXHRoZXRhIFx8IFxwaV97XHRleHR7cHJldHJhaW59fSkKJCQKClRoaXMgY2FuIGJlIHZpZXdlZCBhczoKLSBNYXhpbWl6aW5nIHJld2FyZCAoUkwgb2JqZWN0aXZlKQotIFdoaWxlIHN0YXlpbmcgY2xvc2UgdG8gcHJlLXRyYWluaW5nIGRpc3RyaWJ1dGlvbiAocmVndWxhcml6YXRpb24pCi0gQmFsYW5jZWQgYnkgJFxiZXRhX3tcdGV4dHtwdHh9fSQKCioqSW50dWl0aW9uKio6IERvbid0IGRyaWZ0IHRvbyBmYXIgZnJvbSB3aGF0IHlvdSBrbmV3IGJlZm9yZSB3aGlsZSBsZWFybmluZyBuZXcgb2JqZWN0aXZlcy4KCiMjIyMgSW1wbGVtZW50YXRpb24gTm90ZXMKCioqUmV0dXJuIHZhbHVlcyoqOgotICoqdG90YWxfbG9zcyoqOiBVc2VkIGZvciBiYWNrcHJvcGFnYXRpb24KLSAqKmNlX2xvc3MqKjogTW9uaXRvciBmb3JnZXR0aW5nIChzaG91bGQgc3RheSBsb3cpCi0gKip3ZWlnaHRlZF9jZV9sb3NzKio6IFBUWCBjb250cmlidXRpb24gdG8gdG90YWwKCioqTW9uaXRvcmluZyoqOgotIFRyYWNrIENFIGxvc3Mgc2VwYXJhdGVseQotIElmIENFIGxvc3MgaW5jcmVhc2VzIFwgIG1vZGVsIGZvcmdldHRpbmcKLSBJZiBSTCBsb3NzIGRvZXNuJ3QgZGVjcmVhc2UgXCAgYmV0YSB0b28gaGlnaAoKKipIeXBlcnBhcmFtZXRlciB0dW5pbmcqKjoKLSBTdGFydCB3aXRoICRcYmV0YV97XHRleHR7cHR4fX0gPSAwLjEkCi0gSW5jcmVhc2UgaWYgZm9yZ2V0dGluZyBvYnNlcnZlZAotIERlY3JlYXNlIGlmIFJMIGltcHJvdmVtZW50IHRvbyBzbG93CgojIyMjIFN1bW1hcnkKCioqUFRYIExvc3MgZm9ybXVsYSoqOgokJApMX3tcdGV4dHt0b3RhbH19ID0gTF97XHRleHR7Ukx9fSArIFxiZXRhX3tcdGV4dHtwdHh9fSBcY2RvdCBMX3tcdGV4dHtDRX19CiQkCgoqKlB1cnBvc2UqKjogUHJldmVudCBjYXRhc3Ryb3BoaWMgZm9yZ2V0dGluZyBpbiBSTEhGCgoqKktleSBhcHBsaWNhdGlvbnMqKjogSW5zdHJ1Y3RHUFQsIENoYXRHUFQsIENsYXVkZSwgS2ltaSBLMiwgYW5kIG90aGVyIFJMSEYgc3lzdGVtcwoKKipUeXBpY2FsIGJldGEqKjogMC4xICh0dW5lIGJldHdlZW4gMC4wNS0wLjIpCgoqKkVzc2VudGlhbCBmb3IqKjogTWFpbnRhaW5pbmcgZ2VuZXJhbCBjYXBhYmlsaXRpZXMgd2hpbGUgZmluZS10dW5pbmcgd2l0aCBSTA==",
  "starter_code": "import numpy as np\n\ndef compute_ptx_loss(\n    rl_loss: float,\n    pretrain_logits: np.ndarray,\n    pretrain_labels: np.ndarray,\n    beta_ptx: float = 0.1\n) -> tuple[float, float, float]:\n\t\"\"\"\n\tCompute PTX (Pre-training) Loss to prevent catastrophic forgetting in RLHF.\n\t\n\tPTX Loss = RL Loss + beta_ptx * Cross-Entropy Loss\n\t\n\tPrevents model from forgetting general capabilities while\n\tfine-tuning with reinforcement learning from human feedback.\n\t\n\tArgs:\n\t\trl_loss: Reinforcement learning loss (e.g., PPO objective)\n\t\tpretrain_logits: Model logits on pre-training batch\n\t\t  Shape: (batch_size, vocab_size)\n\t\tpretrain_labels: True token indices\n\t\t  Shape: (batch_size,)\n\t\tbeta_ptx: Weight coefficient (typically 0.05-0.2)\n\t\n\tReturns:\n\t\tTuple of (total_loss, ce_loss, weighted_ce_loss):\n\t\t- total_loss: L_RL + beta_ptx * L_CE\n\t\t- ce_loss: Cross-entropy on pre-training data\n\t\t- weighted_ce_loss: beta_ptx * L_CE\n\t\"\"\"\n\t# Your code here\n\tpass",
  "description_decoded": "Implement PTX (Pre-training) Loss to prevent catastrophic forgetting during RLHF. PTX Loss combines reinforcement learning objectives with cross-entropy loss on pre-training data, maintaining general language capabilities while optimizing for reward. Given RL loss, model logits on pre-training batch, true labels, and beta coefficient, compute total loss. Used in InstructGPT, ChatGPT, Kimi K2, and other RLHF systems.",
  "learn_section_decoded": "### PTX (Pre-training) Loss for RLHF\n\nPTX (Pre-training) Loss prevents catastrophic forgetting during reinforcement learning from human feedback (RLHF) by combining RL objectives with language modeling on pre-training data.\n\n#### The Catastrophic Forgetting Problem\n\nWhen fine-tuning language models with reinforcement learning:\n\n**Without PTX Loss**:\n- Model optimizes purely for reward signal\n- Forgets basic language capabilities (grammar, spelling, factual knowledge)\n- Loses general intelligence while maximizing specific reward\n- Results in degraded overall performance\n\n**Example**: A chatbot trained only with RL might:\n- Forget how to spell common words\n- Lose factual knowledge\n- Generate grammatically incorrect sentences\n- Only produce responses that game the reward model\n\n#### PTX Loss Formula\n\n$$\nL_{\\text{total}} = L_{\\text{RL}}(\\theta) + \\beta_{\\text{ptx}} \\cdot L_{\\text{CE}}(\\theta, D_{\\text{pretrain}})\n$$\n\nWhere:\n- $L_{\\text{RL}}(\\theta)$ = Reinforcement learning loss (e.g., PPO objective)\n- $L_{\\text{CE}}(\\theta, D_{\\text{pretrain}})$ = Cross-entropy loss on pre-training data\n- $\\beta_{\\text{ptx}}$ = Weight coefficient (typically 0.05-0.2)\n- $\\theta$ = Model parameters\n\n**Key insight**: Maintains language modeling ability while optimizing for reward.\n\n#### Cross-Entropy Loss Component\n\nThe cross-entropy loss on pre-training data:\n\n$$\nL_{\\text{CE}} = -\\frac{1}{N} \\sum_{i=1}^{N} \\log P(y_i | x_i; \\theta)\n$$\n\n**Computation**:\n\n**Step 1**: Apply softmax to logits\n$$\nP(y_j) = \\frac{e^{z_j}}{\\sum_k e^{z_k}}\n$$\n\n**Step 2**: Compute negative log-likelihood\n$$\n\\text{CE}_i = -\\log P(y_{\\text{true},i})\n$$\n\n**Step 3**: Average over batch\n$$\nL_{\\text{CE}} = \\frac{1}{N} \\sum_{i=1}^{N} \\text{CE}_i\n$$\n\n#### Example Calculation\n\n**Scenario**: Model with perfect predictions on pre-training data\n\n**Given**:\n- RL loss: 0.5\n- Logits: [[10, 0, 0], [0, 10, 0]] (very confident)\n- True labels: [0, 1] (correct)\n- Beta_ptx: 0.1\n\n**Step 1**: Compute probabilities\n- Sample 1: Softmax([10, 0, 0])  [1.0, 0.0, 0.0]\n- Sample 2: Softmax([0, 10, 0])  [0.0, 1.0, 0.0]\n\n**Step 2**: Compute CE\n- Sample 1: -log(1.0)  0\n- Sample 2: -log(1.0)  0\n- Average: 0\n\n**Step 3**: Total loss\n$$\nL_{\\text{total}} = 0.5 + 0.1 \\times 0 = 0.5\n$$\n\nPerfect predictions  minimal PTX penalty\n\n#### Effect of Prediction Quality\n\n**High confidence, correct** (logits [10, 0, 0], label 0):\n- Probability: [~1.0, ~0.0, ~0.0]\n- CE: -log(1.0)  0\n- Low penalty (good!)\n\n**Uniform distribution** (logits [1, 1, 1], label 0):\n- Probability: [1/3, 1/3, 1/3]\n- CE: -log(1/3)  1.099\n- Medium penalty\n\n**High confidence, wrong** (logits [0, 10], label 0):\n- Probability: [~0.0, ~1.0]\n- CE: -log(0.0) \\  very large\n- High penalty (prevents forgetting!)\n\n#### Choosing Beta_ptx\n\nThe coefficient $\\beta_{\\text{ptx}}$ controls the trade-off:\n\n**Beta = 0.0**: No forgetting prevention\n- Pure RL optimization\n- Fast reward improvement\n- Risk of catastrophic forgetting\n\n**Beta = 0.05-0.1**: Light preservation (typical)\n- Mostly RL-driven\n- Some capability maintenance\n- Good balance for most tasks\n\n**Beta = 0.2-0.5**: Strong preservation\n- Equal importance to capabilities\n- Slower RL improvement\n- Better for complex models\n\n**Beta = 1.0**: Equal weighting\n- Balanced RL and pre-training\n- Very conservative\n- Slowest forgetting\n\n**Typical choice**: $\\beta_{\\text{ptx}} = 0.1$ (used in InstructGPT, Kimi K2)\n\n#### RLHF Training Pipeline\n\n**Phase 1: Supervised Fine-tuning (SFT)**\n- Train on high-quality demonstrations\n- Loss: Pure cross-entropy on supervised data\n- Result: Model that imitates demonstrations\n\n**Phase 2: Reward Modeling (RM)**\n- Train reward model on human preferences\n- Loss: Binary classification (preferred vs not)\n- Result: Reward function that captures human values\n\n**Phase 3: RL Fine-tuning with PTX**\n- Optimize policy using reward model\n- Loss: $L_{\\text{total}} = L_{\\text{RL}} + \\beta_{\\text{ptx}} \\cdot L_{\\text{CE}}$\n- Result: Model that maximizes reward while preserving capabilities\n\n**Training step**:\n1. Generate responses with current policy\n2. Compute reward from reward model\n3. Compute RL loss (PPO clipped objective)\n4. Sample batch from pre-training data\n5. Compute CE loss on pre-training batch\n6. Combine: $L_{\\text{total}} = L_{\\text{RL}} + \\beta_{\\text{ptx}} \\cdot L_{\\text{CE}}$\n7. Backpropagate and update model\n\n#### Pre-training Data Selection\n\n**What to include**:\n- Representative examples of desired capabilities\n- High-quality, diverse text\n- Tasks model should maintain (QA, summarization, reasoning)\n- Mix of domains and styles\n\n**Batch size**: 32-256 samples per RL batch\n\n**Data mixing**: Typically sample from same distribution as original pre-training\n\n#### Real-World Examples\n\n**InstructGPT (OpenAI, 2022)**:\n- Uses PTX loss with $\\beta_{\\text{ptx}} \\approx 0.1$\n- Pre-training data: Mix of prompts and completions\n- Result: Maintains helpfulness while optimizing for human preference\n\n**Kimi K2 (Moonshot AI, 2024)**:\n- Explicit PTX loss formulation\n- Prevents forgetting during long-context fine-tuning\n- Critical for maintaining general capabilities\n\n**Claude (Anthropic)**:\n- Uses auxiliary objectives (similar to PTX)\n- Maintains helpfulness, harmlessness, honesty (HHH)\n- Multi-objective optimization\n\n#### Benefits of PTX Loss\n\n**1. Prevents capability degradation**\n- Maintains language modeling quality\n- Preserves factual knowledge\n- Keeps reasoning abilities\n\n**2. Faster convergence**\n- Regularizes RL training\n- Reduces reward hacking\n- More stable optimization\n\n**3. Better generalization**\n- Model retains broad capabilities\n- Performs well on diverse tasks\n- Less overfitting to reward model\n\n**4. Minimal computational overhead**\n- Adds ~10-20% to training time\n- Requires pre-training data sampling\n- Worth the cost for quality preservation\n\n#### Common Pitfalls\n\n**Pitfall 1**: Beta too low\n- Symptom: Model forgets basic capabilities\n- Solution: Increase $\\beta_{\\text{ptx}}$ to 0.1-0.2\n\n**Pitfall 2**: Beta too high\n- Symptom: Slow RL improvement, reward plateaus\n- Solution: Decrease $\\beta_{\\text{ptx}}$ to 0.05-0.1\n\n**Pitfall 3**: Poor pre-training data\n- Symptom: Model learns wrong behaviors\n- Solution: Curate high-quality, diverse examples\n\n**Pitfall 4**: Mismatched batch sizes\n- Symptom: Unstable training\n- Solution: Match pre-training batch size to RL batch\n\n#### Comparison with Alternatives\n\n**PTX Loss** (This approach):\n- Pros: Simple, effective, theoretically grounded\n- Cons: Requires pre-training data, adds computation\n- Use: General RLHF pipelines\n\n**Elastic Weight Consolidation (EWC)**:\n- Pros: No extra data needed\n- Cons: More complex, slower\n- Use: Continual learning scenarios\n\n**KL Penalty** (from reference model):\n- Pros: Prevents distribution shift\n- Cons: Doesn't explicitly preserve capabilities\n- Use: Often combined with PTX\n\n**Mixture of Experts**:\n- Pros: Can specialize different experts\n- Cons: Much more complex architecture\n- Use: Very large scale models\n\n#### Mathematical Insight\n\nPTX loss creates a regularization term:\n\n$$\n\\min_\\theta \\mathbb{E}_{\\pi_\\theta} [R(x,y)] - \\beta_{\\text{ptx}} \\cdot D_{\\text{KL}}(\\pi_\\theta \\| \\pi_{\\text{pretrain}})\n$$\n\nThis can be viewed as:\n- Maximizing reward (RL objective)\n- While staying close to pre-training distribution (regularization)\n- Balanced by $\\beta_{\\text{ptx}}$\n\n**Intuition**: Don't drift too far from what you knew before while learning new objectives.\n\n#### Implementation Notes\n\n**Return values**:\n- **total_loss**: Used for backpropagation\n- **ce_loss**: Monitor forgetting (should stay low)\n- **weighted_ce_loss**: PTX contribution to total\n\n**Monitoring**:\n- Track CE loss separately\n- If CE loss increases \\  model forgetting\n- If RL loss doesn't decrease \\  beta too high\n\n**Hyperparameter tuning**:\n- Start with $\\beta_{\\text{ptx}} = 0.1$\n- Increase if forgetting observed\n- Decrease if RL improvement too slow\n\n#### Summary\n\n**PTX Loss formula**:\n$$\nL_{\\text{total}} = L_{\\text{RL}} + \\beta_{\\text{ptx}} \\cdot L_{\\text{CE}}\n$$\n\n**Purpose**: Prevent catastrophic forgetting in RLHF\n\n**Key applications**: InstructGPT, ChatGPT, Claude, Kimi K2, and other RLHF systems\n\n**Typical beta**: 0.1 (tune between 0.05-0.2)\n\n**Essential for**: Maintaining general capabilities while fine-tuning with RL"
}