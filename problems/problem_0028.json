{
  "description": "R2l2ZW4gYSAyeDIgbWF0cml4LCB3cml0ZSBhIFB5dGhvbiBmdW5jdGlvbiB0byBjb21wdXRlIGl0cyBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIChTVkQpLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBtYXRyaWNlcyBVLCBzLCBhbmQgViBzdWNoIHRoYXQgQSA9IFUgQCBkaWFnKHMpIEAgVi4KCkRvIG5vdCB1c2UgbnVtcHkubGluYWxnLnN2ZCBvciBvdGhlciBidWlsdC1pbiBTVkQgZnVuY3Rpb25zLgoKKipSZXR1cm5zOioqCi0gYFVgOiAyeDIgb3J0aG9nb25hbCBtYXRyaXggKGxlZnQgc2luZ3VsYXIgdmVjdG9ycykKLSBgc2A6IDFEIGFycmF5IG9mIDIgc2luZ3VsYXIgdmFsdWVzIChub24tbmVnYXRpdmUpCi0gYFZgOiAyeDIgbWF0cml4IChyaWdodCBzaW5ndWxhciB2ZWN0b3JzKQ==",
  "mdx_file": "9ed3f67c-f01d-4d4d-b9a2-2e5fa7d61307.mdx",
  "id": "28",
  "test_cases": [
    {
      "test": "U, s, V = svd_2x2(np.array([[-10, 8], [10, -1]]))\nresult = U @ np.diag(s) @ V\nprint(np.allclose(result, [[-10, 8], [10, -1]]))",
      "expected_output": "True"
    },
    {
      "test": "U, s, V = svd_2x2(np.array([[1, 2], [3, 4]]))\nresult = U @ np.diag(s) @ V\nprint(np.allclose(result, [[1, 2], [3, 4]]))",
      "expected_output": "True"
    }
  ],
  "difficulty": "hard",
  "pytorch_difficulty": "hard",
  "likes": "0",
  "video": "",
  "dislikes": "0",
  "example": {
    "input": "A = np.array([[-10, 8], [10, -1]])",
    "output": "U, s, V such that U @ diag(s) @ V ≈ A",
    "reasoning": "The SVD decomposes A into orthogonal matrices U and V, and singular values s. The reconstruction U @ diag(s) @ V equals the original matrix A."
  },
  "category": "Linear Algebra",
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCgpkZWYgc3ZkXzJ4MihBOiB0b3JjaC5UZW5zb3IpIC0+IHR1cGxlW3RvcmNoLlRlbnNvciwgdG9yY2guVGVuc29yLCB0b3JjaC5UZW5zb3JdOgogICAgIiIiCiAgICBDb21wdXRlIFNWRCBvZiBhIDJ4MiBtYXRyaXguCiAgICAKICAgIEFyZ3M6CiAgICAgICAgQTogMngyIHRvcmNoIHRlbnNvcgogICAgCiAgICBSZXR1cm5zOgogICAgICAgIFU6IDJ4MiBvcnRob2dvbmFsIHRlbnNvciAobGVmdCBzaW5ndWxhciB2ZWN0b3JzKQogICAgICAgIHM6IDFEIHRlbnNvciBvZiBzaW5ndWxhciB2YWx1ZXMKICAgICAgICBWOiAyeDIgdGVuc29yIChyaWdodCBzaW5ndWxhciB2ZWN0b3JzKQogICAgIiIiCiAgICAjIFlvdXIgY29kZSBoZXJlCiAgICBwYXNz",
  "title": "SVD of a 2x2 Matrix",
  "createdAt": "December 15, 2025 at 9:44:34 AM UTC-0500",
  "contributor": [
    {
      "profile_link": "https://github.com/brentspell",
      "name": "brentspell"
    },
    {
      "profile_link": "https://github.com/EpsIotaPi",
      "name": "EpsIotaPi"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "U, s, V = svd_2x2(torch.tensor([[-10.0, 8.0], [10.0, -1.0]]))\nresult = U @ torch.diag(s) @ V\nprint(torch.allclose(result, torch.tensor([[-10.0, 8.0], [10.0, -1.0]])))",
      "expected_output": "True"
    },
    {
      "test": "U, s, V = svd_2x2(torch.tensor([[1.0, 2.0], [3.0, 4.0]]))\nresult = U @ torch.diag(s) @ V\nprint(torch.allclose(result, torch.tensor([[1.0, 2.0], [3.0, 4.0]])))",
      "expected_output": "True"
    },
    {
      "test": "# Verify orthogonality of U\nU, s, V = svd_2x2(torch.tensor([[1.0, 2.0], [3.0, 4.0]]))\nprint(torch.allclose(U @ U.T, torch.eye(2)))",
      "expected_output": "True"
    }
  ],
  "learn_section": "IyMgVW5kZXJzdGFuZGluZyBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIChTVkQpCgpTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIChTVkQpIGlzIGEgZnVuZGFtZW50YWwgbWF0cml4IGZhY3Rvcml6YXRpb24gaW4gbGluZWFyIGFsZ2VicmEuIEZvciBhbnkgbWF0cml4ICRBJCwgU1ZEIGRlY29tcG9zZXMgaXQgYXM6CgokJEEgPSBVIFxjZG90IFMgXGNkb3QgVl5UJCQKCldoZXJlOgotICRVJCBpcyBhbiBvcnRob2dvbmFsIG1hdHJpeCAobGVmdCBzaW5ndWxhciB2ZWN0b3JzKQotICRTJCBpcyBhIGRpYWdvbmFsIG1hdHJpeCBvZiBzaW5ndWxhciB2YWx1ZXMKLSAkViQgaXMgYW4gb3J0aG9nb25hbCBtYXRyaXggKHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnMpCgojIyMgUHJvcGVydGllcwoKLSBTaW5ndWxhciB2YWx1ZXMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmU6ICRcc2lnbWFfaSBcZ2VxIDAkCi0gJFUkIGFuZCAkViQgYXJlIG9ydGhvZ29uYWw6ICRVXlQgVSA9IEkkIGFuZCAkVl5UIFYgPSBJJAotIFNpbmd1bGFyIHZhbHVlcyBhcmUgdGhlIHNxdWFyZSByb290cyBvZiBlaWdlbnZhbHVlcyBvZiAkQV5UIEEkCgojIyMgQ29tcHV0aW5nIFNWRCBmb3IgMngyIE1hdHJpY2VzCgpGb3IgYSAyeDIgbWF0cml4LCB0aGVyZSdzIGEgY2xvc2VkLWZvcm0gc29sdXRpb24gdGhhdCBhdm9pZHMgaXRlcmF0aXZlIG1ldGhvZHM6CgoxLiAqKkNvbXB1dGUgYXV4aWxpYXJ5IHZhbHVlczoqKgogICAkJHlfMSA9IGFfezIxfSArIGFfezEyfSwgXHF1YWQgeF8xID0gYV97MTF9IC0gYV97MjJ9JCQKICAgJCR5XzIgPSBhX3syMX0gLSBhX3sxMn0sIFxxdWFkIHhfMiA9IGFfezExfSArIGFfezIyfSQkCgoyLiAqKkNvbXB1dGUgbm9ybXM6KioKICAgJCRoXzEgPSBcc3FydHt5XzFeMiArIHhfMV4yfSwgXHF1YWQgaF8yID0gXHNxcnR7eV8yXjIgKyB4XzJeMn0kJAoKMy4gKipTaW5ndWxhciB2YWx1ZXM6KioKICAgJCRcc2lnbWFfMSA9IFxmcmFje2hfMSArIGhfMn17Mn0sIFxxdWFkIFxzaWdtYV8yID0gXGZyYWN7fGhfMSAtIGhfMnx9ezJ9JCQKCjQuICoqQnVpbGQgVSBmcm9tIHJvdGF0aW9uIGFuZ2xlcyoqIGRlcml2ZWQgZnJvbSAkdF8xID0geF8xL2hfMSQgYW5kICR0XzIgPSB4XzIvaF8yJAoKNS4gKipDb21wdXRlIFY6KioKICAgJCRWID0gU157LTF9IFVeVCBBJCQKCiMjIyBWZXJpZmljYXRpb24KCkFsd2F5cyB2ZXJpZnkgeW91ciBTVkQgYnkgY2hlY2tpbmc6Ci0gUmVjb25zdHJ1Y3Rpb246ICRVIFxjZG90IFMgXGNkb3QgVl5UIFxhcHByb3ggQSQKLSBPcnRob2dvbmFsaXR5OiAkVV5UIFUgPSBJJCBhbmQgJFZeVCBWID0gSSQKLSBOb24tbmVnYXRpdmUgc2luZ3VsYXIgdmFsdWVzCgojIyMgQXBwbGljYXRpb25zCgotICoqSW1hZ2UgY29tcHJlc3Npb24qKjogS2VlcCBvbmx5IGxhcmdlc3Qgc2luZ3VsYXIgdmFsdWVzCi0gKipQc2V1ZG9pbnZlcnNlKio6IENvbXB1dGUgJEFeKyA9IFYgU157LTF9IFVeVCQKLSAqKlBDQSoqOiBQcmluY2lwYWwgY29tcG9uZW50cyBmcm9tIFNWRCBvZiBjZW50ZXJlZCBkYXRhCi0gKipSZWNvbW1lbmRlciBzeXN0ZW1zKio6IE1hdHJpeCBmYWN0b3JpemF0aW9uIGZvciBjb2xsYWJvcmF0aXZlIGZpbHRlcmluZwo=",
  "starter_code": "import numpy as np\n\ndef svd_2x2(A: np.ndarray) -> tuple:\n    \"\"\"\n    Compute SVD of a 2x2 matrix.\n    \n    Args:\n        A: 2x2 numpy array\n    \n    Returns:\n        U: 2x2 orthogonal matrix (left singular vectors)\n        s: 1D array of singular values\n        V: 2x2 matrix (right singular vectors)\n    \"\"\"\n    # Your code here\n    pass",
  "description_decoded": "Given a 2x2 matrix, write a Python function to compute its Singular Value Decomposition (SVD). The function should return matrices U, s, and V such that A = U @ diag(s) @ V.\n\nDo not use numpy.linalg.svd or other built-in SVD functions.\n\n**Returns:**\n- `U`: 2x2 orthogonal matrix (left singular vectors)\n- `s`: 1D array of 2 singular values (non-negative)\n- `V`: 2x2 matrix (right singular vectors)",
  "learn_section_decoded": "## Understanding Singular Value Decomposition (SVD)\n\nSingular Value Decomposition (SVD) is a fundamental matrix factorization in linear algebra. For any matrix $A$, SVD decomposes it as:\n\n$$A = U \\cdot S \\cdot V^T$$\n\nWhere:\n- $U$ is an orthogonal matrix (left singular vectors)\n- $S$ is a diagonal matrix of singular values\n- $V$ is an orthogonal matrix (right singular vectors)\n\n### Properties\n\n- Singular values are always non-negative: $\\sigma_i \\geq 0$\n- $U$ and $V$ are orthogonal: $U^T U = I$ and $V^T V = I$\n- Singular values are the square roots of eigenvalues of $A^T A$\n\n### Computing SVD for 2x2 Matrices\n\nFor a 2x2 matrix, there's a closed-form solution that avoids iterative methods:\n\n1. **Compute auxiliary values:**\n   $$y_1 = a_{21} + a_{12}, \\quad x_1 = a_{11} - a_{22}$$\n   $$y_2 = a_{21} - a_{12}, \\quad x_2 = a_{11} + a_{22}$$\n\n2. **Compute norms:**\n   $$h_1 = \\sqrt{y_1^2 + x_1^2}, \\quad h_2 = \\sqrt{y_2^2 + x_2^2}$$\n\n3. **Singular values:**\n   $$\\sigma_1 = \\frac{h_1 + h_2}{2}, \\quad \\sigma_2 = \\frac{|h_1 - h_2|}{2}$$\n\n4. **Build U from rotation angles** derived from $t_1 = x_1/h_1$ and $t_2 = x_2/h_2$\n\n5. **Compute V:**\n   $$V = S^{-1} U^T A$$\n\n### Verification\n\nAlways verify your SVD by checking:\n- Reconstruction: $U \\cdot S \\cdot V^T \\approx A$\n- Orthogonality: $U^T U = I$ and $V^T V = I$\n- Non-negative singular values\n\n### Applications\n\n- **Image compression**: Keep only largest singular values\n- **Pseudoinverse**: Compute $A^+ = V S^{-1} U^T$\n- **PCA**: Principal components from SVD of centered data\n- **Recommender systems**: Matrix factorization for collaborative filtering\n"
}