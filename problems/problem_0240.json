{
  "description": "IyMgVGFzazogSW1hZ2UgUmVzaXppbmcgd2l0aCBCaWxpbmVhciBJbnRlcnBvbGF0aW9uCgpCaWxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIGEgZnVuZGFtZW50YWwgdGVjaG5pcXVlIGluIGNvbXB1dGVyIHZpc2lvbiBmb3IgcmVzaXppbmcgaW1hZ2VzLiBVbmxpa2UgbmVhcmVzdC1uZWlnaGJvciBpbnRlcnBvbGF0aW9uIHdoaWNoIHNpbXBseSBwaWNrcyB0aGUgY2xvc2VzdCBwaXhlbCwgYmlsaW5lYXIgaW50ZXJwb2xhdGlvbiBjb25zaWRlcnMgdGhlIGZvdXIgbmVhcmVzdCBwaXhlbHMgYW5kIGNvbXB1dGVzIGEgd2VpZ2h0ZWQgYXZlcmFnZSBiYXNlZCBvbiB0aGUgZGlzdGFuY2VzIHRvIGVhY2ggcGl4ZWwuCgpJbXBsZW1lbnQgYSBmdW5jdGlvbiBgYmlsaW5lYXJfcmVzaXplKGltYWdlLCBuZXdfaGVpZ2h0LCBuZXdfd2lkdGgpYCB0aGF0IHJlc2l6ZXMgYSBncmF5c2NhbGUgb3IgUkdCIGltYWdlIHRvIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9ucyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLgoKIyMjIElucHV0OgotIGBpbWFnZWA6IEEgMkQgbGlzdC9hcnJheSAoZ3JheXNjYWxlKSBvciAzRCBsaXN0L2FycmF5IChSR0IpIHJlcHJlc2VudGluZyBhbiBpbWFnZQotIGBuZXdfaGVpZ2h0YDogVGFyZ2V0IGhlaWdodCBvZiB0aGUgcmVzaXplZCBpbWFnZSAocG9zaXRpdmUgaW50ZWdlcikKLSBgbmV3X3dpZHRoYDogVGFyZ2V0IHdpZHRoIG9mIHRoZSByZXNpemVkIGltYWdlIChwb3NpdGl2ZSBpbnRlZ2VyKQoKIyMjIE91dHB1dDoKLSBSZXR1cm4gdGhlIHJlc2l6ZWQgaW1hZ2UgYXMgYSBuZXN0ZWQgbGlzdCB3aXRoIHZhbHVlcyByb3VuZGVkIHRvIDIgZGVjaW1hbCBwbGFjZXMKCiMjIyBOb3RlczoKLSBNYXAgZWFjaCBvdXRwdXQgcGl4ZWwgdG8gY29ycmVzcG9uZGluZyBzb3VyY2UgY29vcmRpbmF0ZXMKLSBVc2UgdGhlIGZvdXIgbmVhcmVzdCBzb3VyY2UgcGl4ZWxzIGZvciBpbnRlcnBvbGF0aW9uCi0gSGFuZGxlIGJvdW5kYXJ5IGNhc2VzIGJ5IGNsYW1waW5nIGNvb3JkaW5hdGVzIHRvIHZhbGlkIHJhbmdlCi0gV29ya3MgZm9yIGJvdGggdXBzY2FsaW5nIGFuZCBkb3duc2NhbGluZw==",
  "id": "240",
  "test_cases": [
    {
      "test": "image = [[0, 100], [100, 200]]\nprint(bilinear_resize(image, 4, 4))",
      "expected_output": "[[0.0, 50.0, 100.0, 100.0], [50.0, 100.0, 150.0, 150.0], [100.0, 150.0, 200.0, 200.0], [100.0, 150.0, 200.0, 200.0]]"
    },
    {
      "test": "image = [[0, 50, 100], [50, 100, 150], [100, 150, 200]]\nprint(bilinear_resize(image, 2, 2))",
      "expected_output": "[[0.0, 75.0], [75.0, 150.0]]"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "image = [[0, 100], [100, 200]]\nbilinear_resize(image, 4, 4)",
    "output": "[[0.0, 50.0, 100.0, 100.0], [50.0, 100.0, 150.0, 150.0], [100.0, 150.0, 200.0, 200.0], [100.0, 150.0, 200.0, 200.0]]",
    "reasoning": "The 2x2 image is upscaled to 4x4. Each output pixel maps to source coordinates with scale factor 0.5. For example, output pixel (1,1) maps to source (0.5, 0.5), which lies at the center of all four source pixels. The bilinear interpolation computes: 0*0.25 + 100*0.25 + 100*0.25 + 200*0.25 = 100."
  },
  "category": "Computer Vision",
  "starter_code": "import numpy as np\n\ndef bilinear_resize(image, new_height: int, new_width: int) -> list:\n    \"\"\"\n    Resize an image using bilinear interpolation.\n    \n    Args:\n        image: 2D (grayscale) or 3D (RGB) array representing an image\n        new_height: Target height of the resized image\n        new_width: Target width of the resized image\n    \n    Returns:\n        Resized image as a nested list with values rounded to 2 decimal places\n    \"\"\"\n    # Your code here\n    pass",
  "createdAt": "December 14, 2025 at 11:26:37â€¯AM UTC-0500",
  "learn_section": "IyMgQmlsaW5lYXIgSW50ZXJwb2xhdGlvbiBmb3IgSW1hZ2UgUmVzaXppbmcKCkJpbGluZWFyIGludGVycG9sYXRpb24gaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbiBtZXRob2RzIGZvciByZXNhbXBsaW5nIGltYWdlcyB3aGVuIHJlc2l6aW5nLiBJdCBwcm9kdWNlcyBzbW9vdGhlciByZXN1bHRzIHRoYW4gbmVhcmVzdC1uZWlnaGJvciBpbnRlcnBvbGF0aW9uIHdoaWxlIGJlaW5nIGNvbXB1dGF0aW9uYWxseSBlZmZpY2llbnQuCgojIyMgQ29vcmRpbmF0ZSBNYXBwaW5nCgpXaGVuIHJlc2l6aW5nIGFuIGltYWdlIGZyb20gZGltZW5zaW9ucyAkKEhfe29sZH0sIFdfe29sZH0pJCB0byAkKEhfe25ld30sIFdfe25ld30pJCwgd2UgZmlyc3QgY29tcHV0ZSBzY2FsZSBmYWN0b3JzOgoKJCRzX3kgPSBcZnJhY3tIX3tvbGR9fXtIX3tuZXd9fSwgXHF1YWQgc194ID0gXGZyYWN7V197b2xkfX17V197bmV3fX0kJAoKRm9yIGVhY2ggb3V0cHV0IHBpeGVsIGF0IHBvc2l0aW9uICQoaSwgaikkLCB3ZSBtYXAgdG8gc291cmNlIGNvb3JkaW5hdGVzOgoKJCR5ID0gaSBcY2RvdCBzX3ksIFxxdWFkIHggPSBqIFxjZG90IHNfeCQkCgojIyMgVGhlIEZvdXIgTmVhcmVzdCBOZWlnaGJvcnMKClRoZSBtYXBwZWQgY29vcmRpbmF0ZXMgJCh5LCB4KSQgdHlwaWNhbGx5IGZhbGwgYmV0d2VlbiBwaXhlbCBjZW50ZXJzLiBXZSBpZGVudGlmeSB0aGUgZm91ciBuZWFyZXN0IHBpeGVsczoKCi0gVG9wLWxlZnQ6ICQoeV8wLCB4XzApID0gKFxsZmxvb3IgeSBccmZsb29yLCBcbGZsb29yIHggXHJmbG9vcikkCi0gVG9wLXJpZ2h0OiAkKHlfMCwgeF8xKSQKLSBCb3R0b20tbGVmdDogJCh5XzEsIHhfMCkkCi0gQm90dG9tLXJpZ2h0OiAkKHlfMSwgeF8xKSQKCndoZXJlICR5XzEgPSB5XzAgKyAxJCBhbmQgJHhfMSA9IHhfMCArIDEkIChjbGFtcGVkIHRvIGltYWdlIGJvdW5kYXJpZXMpLgoKIyMjIEJpbGluZWFyIEludGVycG9sYXRpb24gRm9ybXVsYQoKVGhlIGZyYWN0aW9uYWwgZGlzdGFuY2VzIGFyZToKJCRcRGVsdGEgeSA9IHkgLSB5XzAsIFxxdWFkIFxEZWx0YSB4ID0geCAtIHhfMCQkCgpUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGlzIGNvbXB1dGVkIGFzIGEgd2VpZ2h0ZWQgYXZlcmFnZToKCiQkSSh5LCB4KSA9IEkoeV8wLCB4XzApIFxjZG90ICgxIC0gXERlbHRhIHgpKDEgLSBcRGVsdGEgeSkgKyBJKHlfMCwgeF8xKSBcY2RvdCBcRGVsdGEgeCgxIC0gXERlbHRhIHkpICsgSSh5XzEsIHhfMCkgXGNkb3QgKDEgLSBcRGVsdGEgeClcRGVsdGEgeSArIEkoeV8xLCB4XzEpIFxjZG90IFxEZWx0YSB4IFxjZG90IFxEZWx0YSB5JCQKCiMjIyBHZW9tZXRyaWMgSW50ZXJwcmV0YXRpb24KCkJpbGluZWFyIGludGVycG9sYXRpb24gY2FuIGJlIHVuZGVyc3Rvb2QgYXMgdHdvIGxpbmVhciBpbnRlcnBvbGF0aW9uczoKCjEuICoqRmlyc3QqKiwgaW50ZXJwb2xhdGUgaG9yaXpvbnRhbGx5IGF0IGJvdGggJHlfMCQgYW5kICR5XzEkOgokJFJfMSA9IEkoeV8wLCB4XzApKDEgLSBcRGVsdGEgeCkgKyBJKHlfMCwgeF8xKVxEZWx0YSB4JCQKJCRSXzIgPSBJKHlfMSwgeF8wKSgxIC0gXERlbHRhIHgpICsgSSh5XzEsIHhfMSlcRGVsdGEgeCQkCgoyLiAqKlRoZW4qKiwgaW50ZXJwb2xhdGUgdmVydGljYWxseSBiZXR3ZWVuICRSXzEkIGFuZCAkUl8yJDoKJCRJKHksIHgpID0gUl8xKDEgLSBcRGVsdGEgeSkgKyBSXzIgXGNkb3QgXERlbHRhIHkkJAoKIyMjIFByb3BlcnRpZXMKCjEuICoqQ29udGludWl0eSoqOiBQcm9kdWNlcyBzbW9vdGggZ3JhZGllbnRzIGJldHdlZW4gcGl4ZWxzCjIuICoqQ29tcHV0YXRpb25hbCBDb3N0Kio6ICRPKEhfe25ld30gXHRpbWVzIFdfe25ld30pJCBmb3IgZ3JheXNjYWxlCjMuICoqUXVhbGl0eSoqOiBCZXR0ZXIgdGhhbiBuZWFyZXN0LW5laWdoYm9yLCBmYXN0ZXIgdGhhbiBiaWN1YmljCjQuICoqQm91bmRhcnkgSGFuZGxpbmcqKjogQ29vcmRpbmF0ZXMgYXJlIHR5cGljYWxseSBjbGFtcGVkIHRvIHZhbGlkIHJhbmdlCgojIyMgQXBwbGljYXRpb25zCgotIEltYWdlIHJlc2l6aW5nIGluIHdlYiBicm93c2VycyBhbmQgaW1hZ2UgZWRpdG9ycwotIFRleHR1cmUgbWFwcGluZyBpbiBjb21wdXRlciBncmFwaGljcwotIERhdGEgYXVnbWVudGF0aW9uIGZvciBkZWVwIGxlYXJuaW5nIChyYW5kb20gc2NhbGluZykKLSBWaWRlbyBmcmFtZSBpbnRlcnBvbGF0aW9u",
  "contributor": [
    {
      "profile_link": "https://github.com/Open-Deep-ML",
      "name": "Deep-ML"
    }
  ],
  "title": "Bilinear Image Resizing",
  "description_decoded": "## Task: Image Resizing with Bilinear Interpolation\n\nBilinear interpolation is a fundamental technique in computer vision for resizing images. Unlike nearest-neighbor interpolation which simply picks the closest pixel, bilinear interpolation considers the four nearest pixels and computes a weighted average based on the distances to each pixel.\n\nImplement a function `bilinear_resize(image, new_height, new_width)` that resizes a grayscale or RGB image to the specified dimensions using bilinear interpolation.\n\n### Input:\n- `image`: A 2D list/array (grayscale) or 3D list/array (RGB) representing an image\n- `new_height`: Target height of the resized image (positive integer)\n- `new_width`: Target width of the resized image (positive integer)\n\n### Output:\n- Return the resized image as a nested list with values rounded to 2 decimal places\n\n### Notes:\n- Map each output pixel to corresponding source coordinates\n- Use the four nearest source pixels for interpolation\n- Handle boundary cases by clamping coordinates to valid range\n- Works for both upscaling and downscaling",
  "learn_section_decoded": "## Bilinear Interpolation for Image Resizing\n\nBilinear interpolation is one of the most common methods for resampling images when resizing. It produces smoother results than nearest-neighbor interpolation while being computationally efficient.\n\n### Coordinate Mapping\n\nWhen resizing an image from dimensions $(H_{old}, W_{old})$ to $(H_{new}, W_{new})$, we first compute scale factors:\n\n$$s_y = \\frac{H_{old}}{H_{new}}, \\quad s_x = \\frac{W_{old}}{W_{new}}$$\n\nFor each output pixel at position $(i, j)$, we map to source coordinates:\n\n$$y = i \\cdot s_y, \\quad x = j \\cdot s_x$$\n\n### The Four Nearest Neighbors\n\nThe mapped coordinates $(y, x)$ typically fall between pixel centers. We identify the four nearest pixels:\n\n- Top-left: $(y_0, x_0) = (\\lfloor y \\rfloor, \\lfloor x \\rfloor)$\n- Top-right: $(y_0, x_1)$\n- Bottom-left: $(y_1, x_0)$\n- Bottom-right: $(y_1, x_1)$\n\nwhere $y_1 = y_0 + 1$ and $x_1 = x_0 + 1$ (clamped to image boundaries).\n\n### Bilinear Interpolation Formula\n\nThe fractional distances are:\n$$\\Delta y = y - y_0, \\quad \\Delta x = x - x_0$$\n\nThe interpolated value is computed as a weighted average:\n\n$$I(y, x) = I(y_0, x_0) \\cdot (1 - \\Delta x)(1 - \\Delta y) + I(y_0, x_1) \\cdot \\Delta x(1 - \\Delta y) + I(y_1, x_0) \\cdot (1 - \\Delta x)\\Delta y + I(y_1, x_1) \\cdot \\Delta x \\cdot \\Delta y$$\n\n### Geometric Interpretation\n\nBilinear interpolation can be understood as two linear interpolations:\n\n1. **First**, interpolate horizontally at both $y_0$ and $y_1$:\n$$R_1 = I(y_0, x_0)(1 - \\Delta x) + I(y_0, x_1)\\Delta x$$\n$$R_2 = I(y_1, x_0)(1 - \\Delta x) + I(y_1, x_1)\\Delta x$$\n\n2. **Then**, interpolate vertically between $R_1$ and $R_2$:\n$$I(y, x) = R_1(1 - \\Delta y) + R_2 \\cdot \\Delta y$$\n\n### Properties\n\n1. **Continuity**: Produces smooth gradients between pixels\n2. **Computational Cost**: $O(H_{new} \\times W_{new})$ for grayscale\n3. **Quality**: Better than nearest-neighbor, faster than bicubic\n4. **Boundary Handling**: Coordinates are typically clamped to valid range\n\n### Applications\n\n- Image resizing in web browsers and image editors\n- Texture mapping in computer graphics\n- Data augmentation for deep learning (random scaling)\n- Video frame interpolation"
}