{
  "description": "V3JpdGUgYSBQeXRob24gZnVuY3Rpb24gdGhhdCB0YWtlcyBhIDItRCBOdW1QeSBhcnJheSAqKlgqKiBhbmQgYW4gaW50ZWdlciAqKmRlZ3JlZSoqLCBnZW5lcmF0ZXMgYWxsIHBvbHlub21pYWwgZmVhdHVyZSBjb21iaW5hdGlvbnMgb2YgdGhlIGNvbHVtbnMgb2YgKipYKiogdXAgdG8gdGhlIGdpdmVuIGRlZ3JlZSAqKmluY2x1c2l2ZSoqLCAqKnRoZW4gc29ydHMgdGhlIHJlc3VsdGluZyBmZWF0dXJlcyBmb3IgZWFjaCBzYW1wbGUgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCB2YWx1ZSoqLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG5ldyAyLUQgTnVtUHkgYXJyYXkgd2hvc2Ugcm93cyBjb3JyZXNwb25kIHRvIHRoZSBpbnB1dCBzYW1wbGVzIGFuZCB3aG9zZSBjb2x1bW5zIGFyZSB0aGUgKiphc2NlbmRpbmctc29ydGVkKiogcG9seW5vbWlhbCBmZWF0dXJlcy4=",
  "mdx_file": "1a78a74c-dffb-4e87-8e0a-1e9c05d7ec23.mdx",
  "id": "32",
  "test_cases": [
    {
      "test": "print(polynomial_features(np.array([[2, 3], [3, 4], [5, 6]]), 2))",
      "expected_output": "[[ 1.  2.  3.  4.  6.  9.]\n [ 1.  3.  4.  9. 12. 16.]\n [ 1.  5.  6. 25. 30. 36.]]"
    },
    {
      "test": "print(polynomial_features(np.array([[1, 2], [3, 4], [5, 6]]), 3))",
      "expected_output": "[[1., 1., 1., 1., 2., 2., 2., 4., 4., 8.], [ 1., 3., 4., 9., 12., 16., 27., 36., 48., 64.], [ 1., 5., 6., 25., 30., 36., 125., 150., 180., 216.]]"
    }
  ],
  "difficulty": "medium",
  "pytorch_difficulty": "medium",
  "likes": "0",
  "video": "",
  "dislikes": "0",
  "example": {
    "input": "X = np.array([[2, 3],\n              [3, 4],\n              [5, 6]])\ndegree = 2\noutput = polynomial_features(X, degree)\nprint(output)",
    "output": "[[ 1.  2.  3.  4.  6.  9.]\n [ 1.  3.  4.  9. 12. 16.]\n [ 1.  5.  6. 25. 30. 36.]]",
    "reasoning": "For **degree = 2**, the raw polynomial terms for the first sample are [1, 2, 3, 4, 6, 9].  Sorting them from smallest to largest yields [1, 2, 3, 4, 6, 9]. The same procedure is applied to every sample."
  },
  "category": "Machine Learning",
  "starter_code": "import numpy as np\nfrom itertools import combinations_with_replacement\n\ndef polynomial_features(X, degree):\n    # ✏️  Your code here\n    pass",
  "learn_section": "IyMgVW5kZXJzdGFuZGluZyBQb2x5bm9taWFsIEZlYXR1cmVzCgpHZW5lcmF0aW5nIHBvbHlub21pYWwgZmVhdHVyZXMgaXMgYSBtZXRob2QgdXNlZCB0byBjcmVhdGUgbmV3IGZlYXR1cmVzIGZvciBhIG1hY2hpbmUtbGVhcm5pbmcgbW9kZWwgYnkgcmFpc2luZyBleGlzdGluZyBmZWF0dXJlcyB0byBhIHNwZWNpZmllZCBwb3dlci4gVGhpcyB0ZWNobmlxdWUgaGVscHMgY2FwdHVyZSBub24tbGluZWFyIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBmZWF0dXJlcy4KCiMjIyBFeGFtcGxlCkdpdmVuIGEgZGF0YXNldCB3aXRoIHR3byBmZWF0dXJlcyAkeF8xJCBhbmQgJHhfMiQsIGdlbmVyYXRpbmcgcG9seW5vbWlhbCBmZWF0dXJlcyB1cCB0byBkZWdyZWUgMiB3aWxsIGNyZWF0ZSBuZXcgZmVhdHVyZXMgc3VjaCBhczoKLSAkeF8xXjIkCi0gJHhfMl4yJAotICR4XzEgeF8yJAoKIyMjIFByb2JsZW0gT3ZlcnZpZXcKSW4gdGhpcyBwcm9ibGVtIHlvdSB3aWxsIHdyaXRlIGEgZnVuY3Rpb24gdG8gKipnZW5lcmF0ZSoqIHBvbHlub21pYWwgZmVhdHVyZXMgKiphbmQgdGhlbiBzb3J0IGVhY2ggc2FtcGxlJ3MgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyKiouIFNwZWNpZmljYWxseToKLSBHaXZlbiBhIDItRCBOdW1QeSBhcnJheSAqKlgqKiBhbmQgYW4gaW50ZWdlciAqKmRlZ3JlZSoqLCBjcmVhdGUgYSBuZXcgMi1EIGFycmF5IHdpdGggYWxsIHBvbHlub21pYWwgY29tYmluYXRpb25zIG9mIHRoZSBmZWF0dXJlcyB1cCB0byB0aGUgc3BlY2lmaWVkIGRlZ3JlZS4KLSBGaW5hbGx5LCBzb3J0IGVhY2ggcm93IGZyb20gdGhlIGxvd2VzdCB2YWx1ZSB0byB0aGUgaGlnaGVzdCB2YWx1ZS4KCiMjIyBJbXBvcnRhbmNlClBvbHlub21pYWwgZXhwYW5zaW9uIGFsbG93cyBvdGhlcndpc2UgbGluZWFyIG1vZGVscyB0byBoYW5kbGUgbm9uLWxpbmVhciBkYXRhLiBTb3J0aW5nIHRoZSBleHBhbmRlZCBmZWF0dXJlcyBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIGRvd25zdHJlYW0gdGFza3MgKGUuZy4sIGhpc3RvZ3JhbS1iYXNlZCBtb2RlbHMgb3IgZmVhdHVyZSBzZWxlY3Rpb24gaGV1cmlzdGljcykgYW5kIHJlaW5mb3JjZXMgYXJyYXktbWFuaXB1bGF0aW9uIHNraWxscyBpbiBOdW1QeS4=",
  "title": "Generate Sorted Polynomial Features",
  "contributor": [
    {
      "profile_link": "https://github.com/eriklindernoren/ML-From-Scratch",
      "name": "Erik Linder-Norén"
    },
    {
      "profile_link": "https://github.com/peppermin-t",
      "name": "Yinjia Chen"
    }
  ],
  "pytorch_test_cases": [
    {
      "test": "import numpy as np, torch; from __main__ import polynomial_features; out = polynomial_features(np.array([[2, 3], [3, 4], [5, 6]]), 2); print(out.numpy())",
      "expected_output": "[[ 1.  2.  3.  4.  6.  9.]\n [ 1.  3.  4.  9. 12. 16.]\n [ 1.  5.  6. 25. 30. 36.]]"
    }
  ],
  "pytorch_starter_code": "aW1wb3J0IHRvcmNoCmZyb20gaXRlcnRvb2xzIGltcG9ydCBjb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudAoKZGVmIHBvbHlub21pYWxfZmVhdHVyZXMoWCwgZGVncmVlKToKICAgICIiIgogICAgR2l2ZW4gYSAyRCB0ZW5zb3IgWCBhbmQgaW50ZWdlciBkZWdyZWUsIHJldHVybiBhIG5ldyB0ZW5zb3Igb2YgYWxsIHBvbHlub21pYWwgZmVhdHVyZSBjb21iaW5hdGlvbnMKICAgICh3aXRoIGNvbnN0YW50IHRlcm0pLCBzb3J0ZWQgZm9yIGVhY2ggc2FtcGxlIGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdC4KICAgICIiIgogICAgIyBIaW50OiBVc2UgY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQgYW5kIHRvcmNoLnByb2QuCiAgICBwYXNzCg==",
  "description_decoded": "Write a Python function that takes a 2-D NumPy array **X** and an integer **degree**, generates all polynomial feature combinations of the columns of **X** up to the given degree **inclusive**, **then sorts the resulting features for each sample from lowest to highest value**. The function should return a new 2-D NumPy array whose rows correspond to the input samples and whose columns are the **ascending-sorted** polynomial features.",
  "learn_section_decoded": "## Understanding Polynomial Features\n\nGenerating polynomial features is a method used to create new features for a machine-learning model by raising existing features to a specified power. This technique helps capture non-linear relationships between features.\n\n### Example\nGiven a dataset with two features $x_1$ and $x_2$, generating polynomial features up to degree 2 will create new features such as:\n- $x_1^2$\n- $x_2^2$\n- $x_1 x_2$\n\n### Problem Overview\nIn this problem you will write a function to **generate** polynomial features **and then sort each sample's features in ascending order**. Specifically:\n- Given a 2-D NumPy array **X** and an integer **degree**, create a new 2-D array with all polynomial combinations of the features up to the specified degree.\n- Finally, sort each row from the lowest value to the highest value.\n\n### Importance\nPolynomial expansion allows otherwise linear models to handle non-linear data. Sorting the expanded features can be useful for certain downstream tasks (e.g., histogram-based models or feature selection heuristics) and reinforces array-manipulation skills in NumPy."
}