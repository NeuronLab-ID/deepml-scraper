{
  "description": "SW1wbGVtZW50IGEgZnVuY3Rpb24gdGhhdCBzY2FucyBldmVyeSBmZWF0dXJlIGFuZCB0aHJlc2hvbGQgaW4gYSBzbWFsbCBkYXRhIHNldCwgdGhlbiByZXR1cm5zIHRoZSBzcGxpdCB0aGF0IG1pbmltaXNlcyB0aGUgd2VpZ2h0ZWQgR2luaSBpbXB1cml0eS4gWW91ciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgc3VwcG9ydCBiaW5hcnkgY2xhc3MgbGFiZWxzICgwIG9yIDEpIGFuZCBoYW5kbGUgdGllcyBncmFjZWZ1bGx5LiAgCgpZb3Ugd2lsbCB3cml0ZSAqKm9uZSoqIGZ1bmN0aW9uOgoKYGBgcHl0aG9uCmZpbmRfYmVzdF9zcGxpdChYOiBucC5uZGFycmF5LCB5OiBucC5uZGFycmF5KSAtPiB0dXBsZVtpbnQsIGZsb2F0XQpgYGAKCiogKipgWGAqKiBpcyBhbiAkblx0aW1lcyBkJCBOdW1QeSBhcnJheSBvZiBudW1lcmljIGZlYXR1cmVzLgoqICoqYHlgKiogaXMgYSBsZW5ndGgtJG4kIE51bVB5IGFycmF5IG9mIDAvMSBsYWJlbHMuCiogVGhlIGZ1bmN0aW9uIHJldHVybnMgYChiZXN0X2ZlYXR1cmVfaW5kZXgsIGJlc3RfdGhyZXNob2xkKWAgZm9yIHRoZSBzcGxpdCB3aXRoIHRoZSAqKmxvd2VzdCoqIHdlaWdodGVkIEdpbmkgaW1wdXJpdHkuCiogSWYgc2V2ZXJhbCBzcGxpdHMgc2hhcmUgdGhlIHNhbWUgaW1wdXJpdHksIHJldHVybiB0aGUgZmlyc3QgdGhhdCB5b3UgZW5jb3VudGVyIHdoaWxlIHNjYW5uaW5nIGZlYXR1cmVzIGFuZCB0aHJlc2hvbGRzLg==",
  "id": "138",
  "test_cases": [
    {
      "test": "import numpy as np\nX1 = np.array([[2.5], [3.5], [1.0], [4.0]])\ny1 = np.array([0, 1, 0, 1])\nf1, t1 = find_best_split(X1, y1)\nprint(f1, round(t1, 4))",
      "expected_output": "0, 2.5"
    },
    {
      "test": "import numpy as np\nX2 = np.array([[1], [2], [3]])\ny2 = np.array([1, 1, 1])\nf2, t2 = find_best_split(X2, y2)\nprint(f2, t2)",
      "expected_output": "0, 1"
    }
  ],
  "difficulty": "medium",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "example": {
    "input": "import numpy as np\nX = np.array([[2.5],[3.5],[1.0],[4.0]])\ny = np.array([0,1,0,1])\nprint(find_best_split(X, y))",
    "output": "(0, 2.5)",
    "reasoning": "Splitting on feature 0 at threshold 2.5 yields two perfectly pure leaves, producing the minimum possible weighted Gini impurity."
  },
  "category": "Machine Learning",
  "starter_code": "import numpy as np\nfrom typing import Tuple\n\ndef find_best_split(X: np.ndarray, y: np.ndarray) -> Tuple[int, float]:\n    \"\"\"Return the (feature_index, threshold) that minimises weighted Gini impurity.\"\"\"\n    # ✏️ TODO: implement\n    pass",
  "title": "Find the Best Gini-Based Split for a Binary Decision Tree",
  "learn_section": "IyBMZWFybjogR2luaSBJbXB1cml0eSBhbmQgQmVzdCBTcGxpdCBpbiBEZWNpc2lvbiBUcmVlcwoKIyMgT3ZlcnZpZXcKCkEgY29yZSBjb25jZXB0IGluIERlY2lzaW9uIFRyZWVzIChhbmQgYnkgZXh0ZW5zaW9uLCBSYW5kb20gRm9yZXN0cykgaXMgaG93IHRoZSBtb2RlbCBjaG9vc2VzIHdoZXJlIHRvIHNwbGl0IHRoZSBkYXRhIGF0IGVhY2ggbm9kZS4gT25lIHBvcHVsYXIgY3JpdGVyaW9uIHVzZWQgZm9yIHNwbGl0dGluZyBpcyAqKkdpbmkgSW1wdXJpdHkqKi4KCkluIHRoaXMgdGFzaywgeW91IHdpbGwgaW1wbGVtZW50OgotIEdpbmkgaW1wdXJpdHkgY29tcHV0YXRpb24KLSBGaW5kaW5nIHRoZSBiZXN0IGZlYXR1cmUgYW5kIHRocmVzaG9sZCB0byBzcGxpdCBvbiBiYXNlZCBvbiBpbXB1cml0eSByZWR1Y3Rpb24KClRoaXMgaGVscHMgYnVpbGQgdGhlIGZvdW5kYXRpb24gZm9yIGhvdyB0cmVlcyBncm93IGluIGEgUmFuZG9tIEZvcmVzdC4KCi0tLQoKIyMgR2luaSBJbXB1cml0eQoKRm9yIGEgc2V0IG9mIHNhbXBsZXMgd2l0aCBjbGFzcyBsYWJlbHMgXCggeSBcKSwgdGhlIEdpbmkgSW1wdXJpdHkgaXMgZGVmaW5lZCBhczoKCiQkCkcoeSkgPSAxIC0gXHN1bV97aT0xfV57a30gcF9pXjIKJCQKCldoZXJlIFwoIHBfaSBcKSBpcyB0aGUgcHJvcG9ydGlvbiBvZiBzYW1wbGVzIGJlbG9uZ2luZyB0byBjbGFzcyBcKCBpIFwpLgoKQSBwdXJlIG5vZGUgKGFsbCBvbmUgY2xhc3MpIGhhcyBcKCBHID0gMCBcKSwgYW5kIGhpZ2hlciB2YWx1ZXMgaW5kaWNhdGUgbW9yZSBjbGFzcyBkaXZlcnNpdHkuCgotLS0KCiMjIFdlaWdodGVkIEdpbmkgSW1wdXJpdHkKCkdpdmVuIGEgZmVhdHVyZSBhbmQgYSB0aHJlc2hvbGQgdG8gc3BsaXQgdGhlIGRhdGFzZXQgaW50byBsZWZ0IGFuZCByaWdodCBzdWJzZXRzOgoKJCQKR197XHRleHR7c3BsaXR9fSA9IFxmcmFje25fe1x0ZXh0e2xlZnR9fX17bn0gRyh5X3tcdGV4dHtsZWZ0fX0pICsgXGZyYWN7bl97XHRleHR7cmlnaHR9fX17bn0gRyh5X3tcdGV4dHtyaWdodH19KQokJAoKV2UgY2hvb3NlIHRoZSBzcGxpdCB0aGF0ICoqbWluaW1pemVzKiogJCggR197XHRleHR7c3BsaXR9fSApJC4KCi0tLQoKIyMgUHJvYmxlbSBTdGF0ZW1lbnQKCllvdSBhcmUgZ2l2ZW4gYSBkYXRhc2V0ICQoIFggXGluIFxtYXRoYmJ7Un1ee24gXHRpbWVzIGR9ICkkIGFuZCBsYWJlbHMgJCggeSBcaW4gXHswLCAxXH1ebiAkKS4gSW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOgoKIyMjIEZ1bmN0aW9ucyB0byBJbXBsZW1lbnQKCmBgYHB5dGhvbgpkZWYgZmluZF9iZXN0X3NwbGl0KFg6IG5wLm5kYXJyYXksIHk6IG5wLm5kYXJyYXkpIC0+IFR1cGxlW2ludCwgZmxvYXRdOgogICAgLi4uCmBgYA==",
  "contributor": [
    {
      "profile_link": "https://github.com/hardik1408",
      "name": "Hardik Jindal"
    }
  ],
  "description_decoded": "Implement a function that scans every feature and threshold in a small data set, then returns the split that minimises the weighted Gini impurity. Your implementation should support binary class labels (0 or 1) and handle ties gracefully.  \n\nYou will write **one** function:\n\n```python\nfind_best_split(X: np.ndarray, y: np.ndarray) -> tuple[int, float]\n```\n\n* **`X`** is an $n\\times d$ NumPy array of numeric features.\n* **`y`** is a length-$n$ NumPy array of 0/1 labels.\n* The function returns `(best_feature_index, best_threshold)` for the split with the **lowest** weighted Gini impurity.\n* If several splits share the same impurity, return the first that you encounter while scanning features and thresholds.",
  "learn_section_decoded": "# Learn: Gini Impurity and Best Split in Decision Trees\n\n## Overview\n\nA core concept in Decision Trees (and by extension, Random Forests) is how the model chooses where to split the data at each node. One popular criterion used for splitting is **Gini Impurity**.\n\nIn this task, you will implement:\n- Gini impurity computation\n- Finding the best feature and threshold to split on based on impurity reduction\n\nThis helps build the foundation for how trees grow in a Random Forest.\n\n---\n\n## Gini Impurity\n\nFor a set of samples with class labels \\( y \\), the Gini Impurity is defined as:\n\n$$\nG(y) = 1 - \\sum_{i=1}^{k} p_i^2\n$$\n\nWhere \\( p_i \\) is the proportion of samples belonging to class \\( i \\).\n\nA pure node (all one class) has \\( G = 0 \\), and higher values indicate more class diversity.\n\n---\n\n## Weighted Gini Impurity\n\nGiven a feature and a threshold to split the dataset into left and right subsets:\n\n$$\nG_{\\text{split}} = \\frac{n_{\\text{left}}}{n} G(y_{\\text{left}}) + \\frac{n_{\\text{right}}}{n} G(y_{\\text{right}})\n$$\n\nWe choose the split that **minimizes** $( G_{\\text{split}} )$.\n\n---\n\n## Problem Statement\n\nYou are given a dataset $( X \\in \\mathbb{R}^{n \\times d} )$ and labels $( y \\in \\{0, 1\\}^n $). Implement the following functions:\n\n### Functions to Implement\n\n```python\ndef find_best_split(X: np.ndarray, y: np.ndarray) -> Tuple[int, float]:\n    ...\n```"
}