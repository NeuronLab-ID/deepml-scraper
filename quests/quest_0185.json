{
  "problem_id": 185,
  "title": "Optical Flow EPE with Masks (OmniWorld-style metric)",
  "category": "Computer Vision",
  "difficulty": "medium",
  "description": "Compute the mean End-Point Error (EPE) between a predicted optical flow field and its ground-truth, optionally using an occlusion/validity mask and an outlier clip (max_flow). Your function should ignore invalid values (NaN/±Inf), support Python lists or NumPy arrays with shape (H, W, 2), and return -1 if inputs are malformed or no valid pixels remain.",
  "example": {
    "input": "pred = [[[1,0],[0,1]], [[-1,0],[0,-1]]]; gt = [[[0,0],[0,0]], [[0,0],[0,0]]]\nprint(round(flow_epe(pred, gt), 4))",
    "output": "1.0",
    "reasoning": "Each of the four pixels has EPE = 1, so the mean is 1.0."
  },
  "starter_code": "from typing import Optional, Union\n\ntry:\n    import numpy as np\nexcept Exception:\n    np = None\n\nArrayLike = Union[list, \"np.ndarray\"]\n\ndef flow_epe(pred: ArrayLike,\n             gt: ArrayLike,\n             mask: Optional[ArrayLike] = None,\n             max_flow: Optional[float] = None) -> float:\n    \"\"\"\n    Compute mean End-Point Error (EPE) between predicted and ground-truth optical flow.\n\n    Args:\n        pred, gt: (H, W, 2) lists or NumPy arrays.\n        mask: optional (H, W) or broadcastable to (H, W); 1=include, 0=ignore.\n        max_flow: optional float; clip per-pixel EPE to this value.\n\n    Returns:\n        float: mean EPE over valid pixels. Returns -1 on invalid input or if no valid pixels.\n    \"\"\"\n    # Your implementation here\n    pass",
  "sub_quests": [
    {
      "step": 1,
      "title": "Euclidean Distance in 2D Space",
      "relation_to_problem": "Computing EPE requires calculating the Euclidean distance between predicted and ground-truth flow vectors at each pixel. This is the fundamental building block for the EPE metric.",
      "prerequisites": [
        "Basic algebra",
        "Pythagorean theorem"
      ],
      "learning_objectives": [
        "Understand the formal definition of Euclidean distance in $\\mathbb{R}^2$",
        "Compute point-to-point distances using the distance formula",
        "Handle edge cases with zero vectors and identical points"
      ],
      "math_content": {
        "definition": "The **Euclidean distance** (or $L^2$ norm) between two points $\\mathbf{p} = (p_x, p_y)$ and $\\mathbf{q} = (q_x, q_y)$ in $\\mathbb{R}^2$ is defined as: $$d(\\mathbf{p}, \\mathbf{q}) = \\|\\mathbf{p} - \\mathbf{q}\\|_2 = \\sqrt{(p_x - q_x)^2 + (p_y - q_y)^2}$$",
        "notation": "$\\|\\mathbf{v}\\|_2$ denotes the $L^2$ norm (Euclidean norm) of vector $\\mathbf{v}$; $d(\\mathbf{p}, \\mathbf{q})$ denotes the distance between points $\\mathbf{p}$ and $\\mathbf{q}$",
        "theorem": "**Triangle Inequality**: For any three points $\\mathbf{a}, \\mathbf{b}, \\mathbf{c} \\in \\mathbb{R}^2$, we have $d(\\mathbf{a}, \\mathbf{c}) \\leq d(\\mathbf{a}, \\mathbf{b}) + d(\\mathbf{b}, \\mathbf{c})$",
        "proof_sketch": "The Euclidean distance satisfies all metric axioms: (1) Non-negativity: $d(\\mathbf{p}, \\mathbf{q}) \\geq 0$ with equality iff $\\mathbf{p} = \\mathbf{q}$ (follows from the square root of a sum of squares); (2) Symmetry: $d(\\mathbf{p}, \\mathbf{q}) = d(\\mathbf{q}, \\mathbf{p})$ (follows from commutativity of subtraction after squaring); (3) Triangle inequality (proven via Cauchy-Schwarz inequality).",
        "examples": [
          "Example 1: $d((1, 0), (0, 0)) = \\sqrt{(1-0)^2 + (0-0)^2} = \\sqrt{1} = 1$",
          "Example 2: $d((3, 4), (0, 0)) = \\sqrt{9 + 16} = 5$",
          "Example 3: $d((1, 2), (1, 2)) = 0$ (distance to itself is zero)"
        ]
      },
      "key_formulas": [
        {
          "name": "2D Euclidean Distance",
          "latex": "$d(\\mathbf{p}, \\mathbf{q}) = \\sqrt{(p_x - q_x)^2 + (p_y - q_y)^2}$",
          "description": "Use this to compute the distance between any two 2D points or vectors"
        }
      ],
      "exercise": {
        "description": "Implement a function that computes the Euclidean distance between two 2D vectors. This is the core operation for computing EPE at a single pixel.",
        "function_signature": "def euclidean_distance_2d(v1: list, v2: list) -> float:",
        "starter_code": "def euclidean_distance_2d(v1: list, v2: list) -> float:\n    \"\"\"\n    Compute Euclidean distance between two 2D vectors.\n    \n    Args:\n        v1: [x1, y1] as a list of two floats\n        v2: [x2, y2] as a list of two floats\n    \n    Returns:\n        float: Euclidean distance between v1 and v2\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "euclidean_distance_2d([1, 0], [0, 0])",
            "expected": "1.0",
            "explanation": "Distance from (1,0) to origin is 1"
          },
          {
            "input": "euclidean_distance_2d([3, 4], [0, 0])",
            "expected": "5.0",
            "explanation": "Classic 3-4-5 right triangle"
          },
          {
            "input": "euclidean_distance_2d([1, 1], [1, 1])",
            "expected": "0.0",
            "explanation": "Distance to itself is zero"
          },
          {
            "input": "euclidean_distance_2d([-1, 0], [0, -1])",
            "expected": "1.4142135623730951",
            "explanation": "Distance is sqrt(2)"
          }
        ]
      },
      "common_mistakes": [
        "Forgetting to take the square root after summing squared differences",
        "Confusing the order of subtraction (though it doesn't matter after squaring)",
        "Not handling negative coordinates correctly"
      ],
      "hint": "Use the Pythagorean theorem: the distance is the hypotenuse of a right triangle formed by the x and y differences.",
      "references": [
        "Metric spaces",
        "Vector norms",
        "Inner product spaces"
      ]
    },
    {
      "step": 2,
      "title": "Mean Computation over Valid Elements",
      "relation_to_problem": "EPE is the mean of per-pixel distances over all valid pixels. This sub-quest teaches how to compute means while handling invalid data (NaN, Inf) and filtering based on a validity mask.",
      "prerequisites": [
        "Arithmetic mean",
        "Boolean masking",
        "IEEE 754 floating-point special values"
      ],
      "learning_objectives": [
        "Understand the formal definition of arithmetic mean",
        "Identify and filter invalid floating-point values (NaN, ±Inf)",
        "Apply boolean masks to select valid elements",
        "Handle edge case when no valid elements exist"
      ],
      "math_content": {
        "definition": "The **arithmetic mean** of a set $S = \\{x_1, x_2, \\ldots, x_n\\}$ is defined as: $$\\bar{x} = \\frac{1}{|S|} \\sum_{i=1}^{|S|} x_i = \\frac{x_1 + x_2 + \\cdots + x_n}{n}$$ where $|S| = n$ denotes the cardinality (size) of set $S$.",
        "notation": "$\\bar{x}$ denotes the mean of $x$; $|S|$ denotes the number of elements in set $S$; $\\text{NaN}$ denotes Not-a-Number; $\\pm\\infty$ denotes positive/negative infinity",
        "theorem": "**Filtered Mean**: Given a set $S$ and a boolean predicate $P$, the mean over valid elements is: $$\\bar{x}_P = \\frac{1}{|S_P|} \\sum_{x \\in S_P} x$$ where $S_P = \\{x \\in S : P(x) = \\text{true}\\}$. If $|S_P| = 0$, the mean is undefined.",
        "proof_sketch": "The filtered mean is simply the arithmetic mean applied to the subset $S_P \\subseteq S$ that satisfies predicate $P$. The cardinality requirement $|S_P| > 0$ ensures we avoid division by zero. In practice, when $|S_P| = 0$, we return a sentinel value (e.g., -1) to indicate failure.",
        "examples": [
          "Example 1: Mean of $[1, 2, 3, 4]$ is $(1+2+3+4)/4 = 2.5$",
          "Example 2: Mean of $[1, \\text{NaN}, 3]$ excluding NaN is $(1+3)/2 = 2.0$",
          "Example 3: With mask $[1, 0, 1, 1]$ applied to $[10, 20, 30, 40]$, valid elements are $[10, 30, 40]$ with mean $(10+30+40)/3 = 26.\\overline{6}$"
        ]
      },
      "key_formulas": [
        {
          "name": "Arithmetic Mean",
          "latex": "$\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i$",
          "description": "Use when all elements are valid"
        },
        {
          "name": "Masked Mean",
          "latex": "$\\bar{x}_M = \\frac{\\sum_{i=1}^{n} m_i \\cdot x_i}{\\sum_{i=1}^{n} m_i}$",
          "description": "Use when mask $m_i \\in \\{0,1\\}$ determines validity"
        }
      ],
      "exercise": {
        "description": "Implement a function that computes the mean of a list of numbers, filtering out invalid values (NaN, Inf) and applying an optional boolean mask. Return -1 if no valid values remain.",
        "function_signature": "def filtered_mean(values: list, mask: list = None) -> float:",
        "starter_code": "def filtered_mean(values: list, mask: list = None) -> float:\n    \"\"\"\n    Compute mean of values, filtering invalid entries and applying optional mask.\n    \n    Args:\n        values: List of floats (may contain NaN or Inf)\n        mask: Optional list of 0/1 values (1=include, 0=exclude)\n    \n    Returns:\n        float: Mean of valid values, or -1 if no valid values exist\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "filtered_mean([1.0, 2.0, 3.0, 4.0])",
            "expected": "2.5",
            "explanation": "Simple mean: (1+2+3+4)/4 = 2.5"
          },
          {
            "input": "filtered_mean([1.0, float('nan'), 3.0])",
            "expected": "2.0",
            "explanation": "NaN is filtered out, mean of [1, 3] is 2.0"
          },
          {
            "input": "filtered_mean([1.0, float('inf'), 3.0])",
            "expected": "2.0",
            "explanation": "Inf is filtered out, mean of [1, 3] is 2.0"
          },
          {
            "input": "filtered_mean([10.0, 20.0, 30.0, 40.0], [1, 0, 1, 1])",
            "expected": "26.666666666666668",
            "explanation": "Mask excludes 20.0, mean of [10, 30, 40] is 80/3"
          },
          {
            "input": "filtered_mean([float('nan'), float('inf')])",
            "expected": "-1",
            "explanation": "No valid values, return -1"
          }
        ]
      },
      "common_mistakes": [
        "Not checking for NaN and Inf separately (use math.isnan and math.isinf)",
        "Forgetting to handle the case when mask is None",
        "Not returning -1 when no valid elements exist (division by zero)",
        "Using mask values as weights instead of binary filters"
      ],
      "hint": "Use Python's math.isfinite() to check if a value is neither NaN nor Inf. Count valid elements before dividing.",
      "references": [
        "IEEE 754 standard",
        "Numpy masked arrays",
        "Robust statistics"
      ]
    },
    {
      "step": 3,
      "title": "Multi-dimensional Array Indexing and Traversal",
      "relation_to_problem": "Optical flow data is stored as 3D arrays (H×W×2), and masks are 2D arrays (H×W). We must iterate over spatial dimensions while accessing 2D flow vectors.",
      "prerequisites": [
        "Array indexing",
        "Nested loops",
        "Shape/dimension concepts"
      ],
      "learning_objectives": [
        "Understand multi-dimensional array structure (H, W, 2) for flow fields",
        "Iterate over 2D spatial coordinates while accessing vector data",
        "Handle both list-based and NumPy array inputs uniformly",
        "Validate array shapes and dimensions"
      ],
      "math_content": {
        "definition": "An **optical flow field** is a function $\\mathbf{f}: \\Omega \\to \\mathbb{R}^2$ where $\\Omega = \\{(x,y) : 0 \\leq x < W, 0 \\leq y < H\\}$ is the image domain. In discrete form, we represent this as a 3D tensor $F \\in \\mathbb{R}^{H \\times W \\times 2}$ where $F[y, x] = [u, v]$ is the flow vector at pixel $(x, y)$. The first two dimensions $(H, W)$ are spatial (height, width), and the last dimension encodes the 2D displacement vector.",
        "notation": "$H$ = height (rows), $W$ = width (columns); $F[y, x, c]$ = element at row $y$, column $x$, channel $c$; $F[y, x] = [F[y,x,0], F[y,x,1]]$ = flow vector at pixel $(x,y)$",
        "theorem": "**Shape Compatibility**: For two flow fields $F_1$ and $F_2$ to be comparable, they must have identical shapes: $\\text{shape}(F_1) = \\text{shape}(F_2) = (H, W, 2)$. A mask $M$ must be broadcastable to $(H, W)$, meaning $\\text{shape}(M) = (H, W)$ or $\\text{shape}(M) = (H, W, 1)$.",
        "proof_sketch": "Shape validation prevents index errors and ensures spatial correspondence. When computing per-pixel operations like EPE, we require $F_1[y,x]$ and $F_2[y,x]$ to represent flow at the same spatial location. Broadcasting allows a mask of shape $(H,W)$ to apply to both channels of a $(H,W,2)$ flow field.",
        "examples": [
          "Example 1: Flow field shape $(2, 3, 2)$ means 2 rows, 3 columns, and 2 channels (u,v). Total of 6 pixels.",
          "Example 2: Accessing $F[1, 2] = [u, v]$ retrieves the flow vector at row 1, column 2.",
          "Example 3: A mask of shape $(2, 3)$ can be broadcast to mask a $(2, 3, 2)$ flow field by applying to each pixel."
        ]
      },
      "key_formulas": [
        {
          "name": "Array Shape",
          "latex": "$F \\in \\mathbb{R}^{H \\times W \\times 2}$",
          "description": "Standard shape for optical flow: height × width × 2-channel displacement"
        },
        {
          "name": "Pixel Traversal",
          "latex": "$\\text{for } y \\in [0, H), x \\in [0, W): \\text{ process } F[y, x]$",
          "description": "Nested loop structure for visiting all spatial locations"
        }
      ],
      "exercise": {
        "description": "Implement a function that validates and extracts flow vectors from a 3D array structure (H, W, 2), returning a flattened list of valid 2D vectors. Handle both nested lists and check shape validity.",
        "function_signature": "def extract_flow_vectors(flow_field: list) -> list:",
        "starter_code": "def extract_flow_vectors(flow_field: list) -> list:\n    \"\"\"\n    Extract all 2D flow vectors from a (H, W, 2) flow field structure.\n    \n    Args:\n        flow_field: Nested list with shape (H, W, 2)\n    \n    Returns:\n        List of [u, v] vectors, or empty list if shape is invalid\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "extract_flow_vectors([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])",
            "expected": "[[1, 2], [3, 4], [5, 6], [7, 8]]",
            "explanation": "2×2 flow field yields 4 vectors"
          },
          {
            "input": "extract_flow_vectors([[[0, 0]]])",
            "expected": "[[0, 0]]",
            "explanation": "1×1 flow field yields 1 vector"
          },
          {
            "input": "extract_flow_vectors([[[1, 2, 3]]])",
            "expected": "[]",
            "explanation": "Invalid: last dimension is 3, not 2"
          },
          {
            "input": "extract_flow_vectors([[1, 2]])",
            "expected": "[]",
            "explanation": "Invalid: only 2D, missing spatial dimension"
          }
        ]
      },
      "common_mistakes": [
        "Confusing row-major (y, x) indexing with Cartesian (x, y) coordinates",
        "Not validating that the innermost dimension has exactly 2 elements",
        "Assuming uniform dimensions without checking all rows",
        "Mixing up height and width (rows vs columns)"
      ],
      "hint": "Use nested loops: outer loop for rows (y), inner loop for columns (x). Check that each flow_field[y][x] has exactly 2 elements.",
      "references": [
        "NumPy array indexing",
        "Tensor dimensions",
        "Broadcasting rules"
      ]
    },
    {
      "step": 4,
      "title": "Per-Pixel Error Field Computation",
      "relation_to_problem": "Before computing mean EPE, we must first compute the EPE at each individual pixel by comparing predicted and ground-truth flow vectors. This step combines Euclidean distance with spatial traversal.",
      "prerequisites": [
        "Euclidean distance in 2D",
        "Multi-dimensional array indexing",
        "Element-wise operations"
      ],
      "learning_objectives": [
        "Compute error metrics at each spatial location independently",
        "Build an error field of the same spatial dimensions as input",
        "Understand the relationship between per-pixel errors and aggregate metrics",
        "Handle mismatched shapes gracefully"
      ],
      "math_content": {
        "definition": "Given predicted flow field $\\hat{F} \\in \\mathbb{R}^{H \\times W \\times 2}$ and ground-truth flow field $F \\in \\mathbb{R}^{H \\times W \\times 2}$, the **per-pixel EPE field** is a function $E: \\Omega \\to \\mathbb{R}_+$ defined as: $$E[y, x] = \\|\\hat{F}[y,x] - F[y,x]\\|_2 = \\sqrt{(\\hat{u}_{y,x} - u_{y,x})^2 + (\\hat{v}_{y,x} - v_{y,x})^2}$$ where $\\hat{F}[y,x] = [\\hat{u}_{y,x}, \\hat{v}_{y,x}]$ and $F[y,x] = [u_{y,x}, v_{y,x}]$.",
        "notation": "$E[y,x]$ = EPE at pixel $(x,y)$; $\\hat{F}$ = predicted flow; $F$ = ground-truth flow; $\\mathbb{R}_+$ = non-negative real numbers",
        "theorem": "**Error Field Properties**: The error field $E$ satisfies: (1) Non-negativity: $E[y,x] \\geq 0$ for all $(x,y)$; (2) Zero-error condition: $E[y,x] = 0$ iff $\\hat{F}[y,x] = F[y,x]$; (3) Shape preservation: $\\text{shape}(E) = (H, W)$ when $\\text{shape}(\\hat{F}) = \\text{shape}(F) = (H, W, 2)$.",
        "proof_sketch": "Property (1) follows from the fact that the Euclidean norm is non-negative. Property (2) follows from the definiteness property of the norm: $\\|\\mathbf{v}\\|_2 = 0$ iff $\\mathbf{v} = \\mathbf{0}$. Property (3) follows from the dimension reduction: we map each 2D vector to a scalar distance, reducing $(H,W,2) \\to (H,W)$.",
        "examples": [
          "Example 1: If $\\hat{F}[0,0] = [1, 0]$ and $F[0,0] = [0, 0]$, then $E[0,0] = \\sqrt{1^2 + 0^2} = 1$",
          "Example 2: If $\\hat{F}[1,1] = [3, 4]$ and $F[1,1] = [0, 0]$, then $E[1,1] = 5$ (3-4-5 triangle)",
          "Example 3: Perfect prediction $\\hat{F} = F$ yields $E[y,x] = 0$ everywhere"
        ]
      },
      "key_formulas": [
        {
          "name": "Per-Pixel EPE",
          "latex": "$E[y,x] = \\|\\hat{F}[y,x] - F[y,x]\\|_2$",
          "description": "Compute at each spatial location independently"
        },
        {
          "name": "Component-wise EPE",
          "latex": "$E[y,x] = \\sqrt{(\\hat{u} - u)^2 + (\\hat{v} - v)^2}$",
          "description": "Expanded form showing both flow components"
        }
      ],
      "exercise": {
        "description": "Implement a function that computes the per-pixel EPE field given predicted and ground-truth flow fields. Return a 2D list (H, W) of EPE values, or None if inputs have incompatible shapes.",
        "function_signature": "def compute_epe_field(pred: list, gt: list) -> list:",
        "starter_code": "def compute_epe_field(pred: list, gt: list) -> list:\n    \"\"\"\n    Compute per-pixel End-Point Error field.\n    \n    Args:\n        pred: Predicted flow field (H, W, 2) as nested list\n        gt: Ground-truth flow field (H, W, 2) as nested list\n    \n    Returns:\n        2D list (H, W) of EPE values, or None if shapes incompatible\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "compute_epe_field([[[1,0],[0,1]],[[-1,0],[0,-1]]], [[[0,0],[0,0]],[[0,0],[0,0]]])",
            "expected": "[[1.0, 1.0], [1.0, 1.0]]",
            "explanation": "Each pixel has flow magnitude 1, EPE is 1 at all locations"
          },
          {
            "input": "compute_epe_field([[[3,4]]], [[[0,0]]])",
            "expected": "[[5.0]]",
            "explanation": "Single pixel with 3-4-5 triangle gives EPE=5"
          },
          {
            "input": "compute_epe_field([[[0,0]]], [[[0,0]]])",
            "expected": "[[0.0]]",
            "explanation": "Perfect match gives zero error"
          },
          {
            "input": "compute_epe_field([[[1,2]]], [[[3,4],[5,6]]])",
            "expected": "None",
            "explanation": "Incompatible shapes: 1×1 vs 1×2"
          }
        ]
      },
      "common_mistakes": [
        "Returning a 3D structure instead of 2D (should reduce dimension from (H,W,2) to (H,W))",
        "Not validating that pred and gt have the same shape",
        "Forgetting to compute square root in Euclidean distance",
        "Using absolute difference instead of Euclidean distance"
      ],
      "hint": "Reuse your euclidean_distance_2d function from step 1. Check shapes first, then iterate through all (y, x) positions.",
      "references": [
        "Error metrics in computer vision",
        "Dense prediction evaluation",
        "Pixel-wise loss functions"
      ]
    },
    {
      "step": 5,
      "title": "Outlier Clipping for Robust Statistics",
      "relation_to_problem": "The max_flow parameter allows capping per-pixel EPE values to reduce the influence of large outliers. This improves robustness when evaluating flow in challenging regions.",
      "prerequisites": [
        "Maximum/minimum functions",
        "Robust statistics concepts"
      ],
      "learning_objectives": [
        "Understand why outlier clipping improves metric robustness",
        "Implement element-wise minimum operation (clipping)",
        "Analyze the effect of clipping on mean values",
        "Determine appropriate clipping thresholds"
      ],
      "math_content": {
        "definition": "Given a threshold $\\tau \\in \\mathbb{R}_+$, the **clipped EPE** at pixel $(y,x)$ is defined as: $$E_{\\text{clip}}[y,x] = \\min(E[y,x], \\tau) = \\begin{cases} E[y,x] & \\text{if } E[y,x] \\leq \\tau \\\\ \\tau & \\text{if } E[y,x] > \\tau \\end{cases}$$ This operation is also called **truncation** or **winsorizing** at level $\\tau$.",
        "notation": "$\\tau$ = clipping threshold (max_flow); $E_{\\text{clip}}$ = clipped error field; $\\min(a,b)$ = minimum of $a$ and $b$",
        "theorem": "**Clipping Properties**: (1) Boundedness: $0 \\leq E_{\\text{clip}}[y,x] \\leq \\tau$; (2) Monotonicity: If $E_1[y,x] \\leq E_2[y,x]$, then $\\min(E_1[y,x], \\tau) \\leq \\min(E_2[y,x], \\tau)$; (3) Mean reduction: $\\overline{E_{\\text{clip}}} \\leq \\overline{E}$ (clipping never increases the mean).",
        "proof_sketch": "Property (1) follows from the definition: the minimum of a non-negative value and $\\tau$ lies in $[0, \\tau]$. Property (2) follows from the fact that $\\min$ preserves order when applied element-wise. Property (3) follows because $E_{\\text{clip}}[y,x] \\leq E[y,x]$ for all $(y,x)$, so summing over all pixels gives a smaller or equal total, and thus a smaller or equal mean.",
        "examples": [
          "Example 1: With $\\tau = 10$ and $E = [5, 15, 20]$, clipping gives $E_{\\text{clip}} = [5, 10, 10]$",
          "Example 2: Mean before clipping: $(5+15+20)/3 = 13.\\overline{3}$; after clipping: $(5+10+10)/3 = 8.\\overline{3}$",
          "Example 3: If all errors are below threshold ($E = [1,2,3]$, $\\tau=10$), clipping has no effect"
        ]
      },
      "key_formulas": [
        {
          "name": "Clipping Operation",
          "latex": "$E_{\\text{clip}} = \\min(E, \\tau)$",
          "description": "Element-wise minimum with threshold"
        },
        {
          "name": "Clipped Mean EPE",
          "latex": "$\\overline{\\text{EPE}}_{\\text{clip}} = \\frac{1}{|\\Omega|} \\sum_{(x,y) \\in \\Omega} \\min(E[y,x], \\tau)$",
          "description": "Mean EPE after outlier clipping"
        }
      ],
      "exercise": {
        "description": "Implement a function that applies outlier clipping to a list of error values. Each value should be capped at a maximum threshold. Handle the case when no threshold is provided (return original values).",
        "function_signature": "def clip_errors(errors: list, max_value: float = None) -> list:",
        "starter_code": "def clip_errors(errors: list, max_value: float = None) -> list:\n    \"\"\"\n    Apply outlier clipping to error values.\n    \n    Args:\n        errors: List of error values (floats)\n        max_value: Maximum allowed value (None means no clipping)\n    \n    Returns:\n        List of clipped error values\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "clip_errors([1.0, 5.0, 10.0, 15.0], 8.0)",
            "expected": "[1.0, 5.0, 8.0, 8.0]",
            "explanation": "Values above 8.0 are clipped to 8.0"
          },
          {
            "input": "clip_errors([1.0, 2.0, 3.0], 10.0)",
            "expected": "[1.0, 2.0, 3.0]",
            "explanation": "No values exceed threshold, no clipping occurs"
          },
          {
            "input": "clip_errors([5.0, 10.0, 15.0], None)",
            "expected": "[5.0, 10.0, 15.0]",
            "explanation": "No threshold provided, return original values"
          },
          {
            "input": "clip_errors([100.0, 200.0], 50.0)",
            "expected": "[50.0, 50.0]",
            "explanation": "All values clipped to maximum"
          }
        ]
      },
      "common_mistakes": [
        "Using max instead of min (clipping should reduce values, not increase them)",
        "Not handling the None case for optional clipping",
        "Modifying the original list instead of creating a new one",
        "Applying threshold as a filter (removing values) instead of clipping (capping values)"
      ],
      "hint": "Use Python's built-in min(value, threshold) for each element. If max_value is None, return the original list unchanged.",
      "references": [
        "Robust statistics",
        "Winsorizing",
        "Outlier detection",
        "Trimmed mean"
      ]
    },
    {
      "step": 6,
      "title": "Comprehensive EPE Computation with Validation",
      "relation_to_problem": "This final sub-quest integrates all previous concepts: compute per-pixel EPE, filter using masks and validity checks, apply optional clipping, and compute the mean. This directly mirrors the main problem structure.",
      "prerequisites": [
        "All previous sub-quests",
        "Input validation",
        "Type checking"
      ],
      "learning_objectives": [
        "Integrate Euclidean distance, masking, clipping, and mean computation",
        "Validate input shapes and types comprehensively",
        "Handle both list and NumPy array inputs uniformly",
        "Implement robust error handling for edge cases"
      ],
      "math_content": {
        "definition": "The **masked and clipped mean EPE** with validity checking is defined as: $$\\overline{\\text{EPE}} = \\begin{cases} \\frac{1}{|\\Omega_v|} \\sum_{(x,y) \\in \\Omega_v} \\min(E[y,x], \\tau) & \\text{if } |\\Omega_v| > 0 \\\\ -1 & \\text{if } |\\Omega_v| = 0 \\text{ or inputs invalid} \\end{cases}$$ where $\\Omega_v = \\{(x,y) \\in \\Omega : M[y,x] = 1 \\land E[y,x] \\in \\mathbb{R} \\land E[y,x] \\neq \\pm\\infty\\}$ is the set of valid pixels, $M$ is the binary mask, $E[y,x] = \\|\\hat{F}[y,x] - F[y,x]\\|_2$ is the per-pixel EPE, and $\\tau$ is the optional clipping threshold.",
        "notation": "$\\Omega_v$ = set of valid pixels; $M[y,x] \\in \\{0,1\\}$ = mask value; $\\land$ = logical AND; $\\mathbb{R}$ = real numbers (excludes NaN); $\\tau$ = max_flow threshold",
        "theorem": "**Input Validation Theorem**: For the EPE computation to be well-defined, the following conditions must hold: (1) Shape compatibility: $\\text{shape}(\\hat{F}) = \\text{shape}(F) = (H, W, 2)$; (2) Mask compatibility: if provided, $\\text{shape}(M) = (H, W)$ or broadcastable; (3) Non-empty valid set: $|\\Omega_v| > 0$. If any condition fails, return -1 as a sentinel value.",
        "proof_sketch": "Condition (1) ensures spatial correspondence between predicted and ground-truth flows. Without it, we cannot meaningfully compare flows at the same pixel location. Condition (2) ensures the mask can be applied to each spatial location. Condition (3) prevents division by zero when computing the mean. The sentinel value -1 (which is impossible for a true EPE since $E[y,x] \\geq 0$) signals invalid input or no valid data.",
        "examples": [
          "Example 1: $\\hat{F} = [[[1,0]]]$, $F = [[[0,0]]]$, no mask, no clip: $E[0,0] = 1$, mean = $1.0$",
          "Example 2: With mask $M = [[0]]$, all pixels excluded, return $-1$",
          "Example 3: $E = [5, 15, 25]$ with $\\tau = 10$: clipped errors $[5, 10, 10]$, mean = $8.\\overline{3}$"
        ]
      },
      "key_formulas": [
        {
          "name": "Complete EPE Formula",
          "latex": "$\\overline{\\text{EPE}} = \\frac{1}{|\\Omega_v|} \\sum_{(x,y) \\in \\Omega_v} \\min(\\|\\hat{F}[y,x] - F[y,x]\\|_2, \\tau)$",
          "description": "Full formula integrating all components"
        },
        {
          "name": "Validity Condition",
          "latex": "$\\Omega_v = \\{(x,y) : M[y,x]=1 \\land E[y,x] \\text{ is finite}\\}$",
          "description": "Definition of valid pixel set"
        }
      ],
      "exercise": {
        "description": "Implement a comprehensive function that computes masked, clipped mean EPE. Validate input shapes, extract flow vectors, compute per-pixel EPE, apply mask and clipping, and return the mean or -1 on error. This exercise synthesizes all previous sub-quests but is not the complete final solution (which must also handle NumPy arrays seamlessly).",
        "function_signature": "def compute_masked_clipped_epe(pred: list, gt: list, mask: list = None, max_flow: float = None) -> float:",
        "starter_code": "def compute_masked_clipped_epe(pred: list, gt: list, mask: list = None, max_flow: float = None) -> float:\n    \"\"\"\n    Compute mean EPE with masking and clipping (list inputs only).\n    \n    Args:\n        pred: Predicted flow (H, W, 2)\n        gt: Ground-truth flow (H, W, 2)\n        mask: Optional binary mask (H, W)\n        max_flow: Optional clipping threshold\n    \n    Returns:\n        float: Mean EPE over valid pixels, or -1 if invalid/empty\n    \"\"\"\n    # Your code here\n    pass",
        "test_cases": [
          {
            "input": "compute_masked_clipped_epe([[[1,0],[0,1]],[[-1,0],[0,-1]]], [[[0,0],[0,0]],[[0,0],[0,0]]])",
            "expected": "1.0",
            "explanation": "All four pixels have EPE=1, mean is 1.0"
          },
          {
            "input": "compute_masked_clipped_epe([[[10,0]]], [[[0,0]]], None, 5.0)",
            "expected": "5.0",
            "explanation": "EPE=10 clipped to max_flow=5"
          },
          {
            "input": "compute_masked_clipped_epe([[[1,0],[2,0]]], [[[0,0],[0,0]]], [[1,0]])",
            "expected": "1.0",
            "explanation": "Mask excludes second pixel with EPE=2, only first pixel (EPE=1) counts"
          },
          {
            "input": "compute_masked_clipped_epe([[[1,0]]], [[[0,0]]], [[0]])",
            "expected": "-1",
            "explanation": "Mask excludes all pixels, return -1"
          },
          {
            "input": "compute_masked_clipped_epe([[[1,0]]], [[[0,0],[0,0]]])",
            "expected": "-1",
            "explanation": "Shape mismatch: 1×1 vs 1×2, return -1"
          }
        ]
      },
      "common_mistakes": [
        "Not validating shapes before processing",
        "Applying mask before computing EPE instead of after",
        "Forgetting to filter NaN/Inf values from EPE field",
        "Incorrect order of operations: should be compute EPE → clip → mask → mean",
        "Not returning -1 when valid pixel count is zero"
      ],
      "hint": "Reuse functions from previous sub-quests: compute EPE field (step 4), clip errors (step 5), and filtered mean (step 2). Validate shapes first, then process step-by-step.",
      "references": [
        "Complete pipeline design",
        "Error handling patterns",
        "Type-generic programming"
      ]
    }
  ]
}