{
  "problem_id": 29,
  "title": "Random Shuffle of Dataset",
  "category": "Machine Learning",
  "difficulty": "easy",
  "description": "Write a Python function to perform a random shuffle of the samples in two numpy arrays, X and y, while maintaining the corresponding order between them. The function should have an optional seed parameter for reproducibility.",
  "example": {
    "input": "X = np.array([[1, 2], \n                  [3, 4], \n                  [5, 6], \n                  [7, 8]])\n    y = np.array([1, 2, 3, 4])",
    "output": "(array([[5, 6],\n                    [1, 2],\n                    [7, 8],\n                    [3, 4]]), \n             array([3, 1, 4, 2]))",
    "reasoning": "The samples in X and y are shuffled randomly, maintaining the correspondence between the samples in both arrays."
  },
  "starter_code": "import numpy as np\n\ndef shuffle_data(X, y, seed=None):\n\t# Your code here\n\tpass",
  "sub_quests": [
    {
      "step": 1,
      "title": "Understanding Random Permutations and Index Arrays",
      "relation_to_problem": "Dataset shuffling relies on generating a random permutation of indices, which is then used to reorder both X and y arrays while maintaining their correspondence.",
      "prerequisites": [
        "Basic probability theory",
        "Array indexing",
        "Python numpy basics"
      ],
      "learning_objectives": [
        "Understand the mathematical definition of permutations",
        "Learn how to generate and work with index arrays",
        "Implement index-based array reordering"
      ],
      "math_content": {
        "definition": "A **permutation** of a finite set $S$ of size $n$ is a bijective function $\\sigma: S \\to S$. For index sets, we consider permutations of $\\{0, 1, 2, \\ldots, n-1\\}$. The set of all permutations of $n$ elements, denoted $S_n$, has cardinality $|S_n| = n!$.",
        "notation": "$\\sigma(i)$ = the position to which index $i$ is mapped under permutation $\\sigma$\n$S_n$ = symmetric group of all permutations on $n$ elements\n$n!$ = number of possible permutations of $n$ elements",
        "theorem": "**Theorem (Permutation Composition):** If $\\sigma$ and $\\tau$ are permutations in $S_n$, then their composition $\\sigma \\circ \\tau$ is also a permutation in $S_n$. The symmetric group $(S_n, \\circ)$ forms a group under composition.",
        "proof_sketch": "Since both $\\sigma$ and $\\tau$ are bijective, their composition is bijective. Closure follows from the fact that composing two bijections yields a bijection. Identity exists (the identity permutation), and each permutation has an inverse.",
        "examples": [
          "For $n=3$: The permutation $\\sigma = [2, 0, 1]$ maps index 0→2, 1→0, 2→1. Applying this to array $[a, b, c]$ yields $[c, a, b]$.",
          "For $n=4$: The permutation $[1, 3, 0, 2]$ applied to $[10, 20, 30, 40]$ yields $[20, 40, 10, 30]$."
        ]
      },
      "key_formulas": [
        {
          "name": "Index Permutation",
          "latex": "$X_{\\text{shuffled}}[i] = X[\\sigma(i)]$ for $i \\in \\{0, 1, \\ldots, n-1\\}$",
          "description": "Use this to reorder an array according to a permutation σ"
        },
        {
          "name": "Total Permutations",
          "latex": "$|S_n| = n! = n \\times (n-1) \\times \\cdots \\times 2 \\times 1$",
          "description": "The number of distinct ways to arrange n elements"
        }
      ],
      "exercise": {
        "description": "Implement a function that takes an array and an explicit permutation (as an index array) and returns the reordered array. This is the fundamental operation underlying dataset shuffling.",
        "function_signature": "def apply_permutation(arr: np.ndarray, permutation: np.ndarray) -> np.ndarray:",
        "starter_code": "import numpy as np\n\ndef apply_permutation(arr: np.ndarray, permutation: np.ndarray) -> np.ndarray:\n    # Your code here\n    # Apply the permutation to reorder the array\n    pass",
        "test_cases": [
          {
            "input": "apply_permutation(np.array([10, 20, 30]), np.array([2, 0, 1]))",
            "expected": "np.array([30, 10, 20])",
            "explanation": "Index 0 gets value from position 2 (30), index 1 from position 0 (10), index 2 from position 1 (20)"
          },
          {
            "input": "apply_permutation(np.array([[1, 2], [3, 4], [5, 6]]), np.array([1, 2, 0]))",
            "expected": "np.array([[3, 4], [5, 6], [1, 2]])",
            "explanation": "Works with 2D arrays: row at index 0 gets row from position 1, etc."
          },
          {
            "input": "apply_permutation(np.array([100]), np.array([0]))",
            "expected": "np.array([100])",
            "explanation": "Edge case: single element array remains unchanged under identity permutation"
          }
        ]
      },
      "common_mistakes": [
        "Confusing the permutation direction: permutation[i] should give the source index for position i",
        "Not handling multi-dimensional arrays correctly (need to permute along axis 0)",
        "Assuming in-place modification instead of creating a new array"
      ],
      "hint": "Use numpy's advanced indexing: arr[permutation] applies the permutation directly.",
      "references": [
        "Symmetric groups in abstract algebra",
        "Numpy fancy indexing",
        "Bijective functions"
      ]
    },
    {
      "step": 2,
      "title": "Uniform Random Permutations and the Fisher-Yates Algorithm",
      "relation_to_problem": "To shuffle datasets fairly, we need to generate random permutations where each of the n! possible orderings has equal probability 1/n!. This ensures unbiased training data.",
      "prerequisites": [
        "Permutations",
        "Discrete uniform distribution",
        "Array manipulation"
      ],
      "learning_objectives": [
        "Understand the uniform distribution over permutations",
        "Learn the Fisher-Yates shuffle algorithm and its correctness proof",
        "Implement random permutation generation with proper statistical properties"
      ],
      "math_content": {
        "definition": "A **uniform random permutation** on $n$ elements is a random variable $\\Sigma$ taking values in $S_n$ such that $P(\\Sigma = \\sigma) = \\frac{1}{n!}$ for all $\\sigma \\in S_n$. This means every possible ordering has equal probability.",
        "notation": "$\\Sigma$ = random permutation (random variable)\n$\\sigma$ = specific permutation (value)\n$P(\\Sigma = \\sigma) = \\frac{1}{n!}$ = uniform probability mass function",
        "theorem": "**Theorem (Fisher-Yates Correctness):** The Fisher-Yates algorithm generates a uniform random permutation. Specifically, after $k$ iterations, the first $k$ positions contain a uniformly random selection of $k$ elements from $n$, arranged in uniformly random order.\n\n**Algorithm:** For $i$ from $n-1$ down to $1$: \n1. Choose $j$ uniformly at random from $\\{0, 1, \\ldots, i\\}$\n2. Swap elements at positions $i$ and $j$",
        "proof_sketch": "**Proof by induction:** Base case ($k=1$): Each element has probability $\\frac{1}{n}$ of being selected first. Inductive step: Assume first $k-1$ positions are uniformly random. The $k$-th position selects uniformly from remaining $n-k+1$ elements. The total number of ways to reach any specific configuration after $k$ steps is $\\frac{n!}{(n-k)!} \\times \\frac{(n-k)!}{n!} = \\frac{1}{\\binom{n}{k} k!}$, which equals the uniform probability. Therefore, after $n$ iterations, all $n!$ permutations are equiprobable.",
        "examples": [
          "For $n=3$: There are $3! = 6$ possible permutations: [0,1,2], [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]. A uniform shuffle gives each probability $\\frac{1}{6} \\approx 0.1667$.",
          "Non-uniform example (incorrect): Independently selecting random positions for each element yields biased distributions. For $n=3$, some permutations may have probability $\\frac{2}{9}$ while others have $\\frac{1}{9}$."
        ]
      },
      "key_formulas": [
        {
          "name": "Uniform Permutation Probability",
          "latex": "$P(\\Sigma = \\sigma) = \\frac{1}{n!}$ for all $\\sigma \\in S_n$",
          "description": "The defining property of a fair shuffle"
        },
        {
          "name": "Fisher-Yates Swap Selection",
          "latex": "$j \\sim \\text{Uniform}(\\{0, 1, \\ldots, i\\})$ at iteration $i$",
          "description": "At each step, select swap partner uniformly from unprocessed elements"
        },
        {
          "name": "Complexity",
          "latex": "$\\Theta(n)$ time, $O(1)$ auxiliary space",
          "description": "Linear time complexity with constant extra space"
        }
      ],
      "exercise": {
        "description": "Implement a function that generates a random permutation of indices from 0 to n-1. This permutation will later be used to shuffle datasets. Include a seed parameter for reproducibility.",
        "function_signature": "def generate_random_permutation(n: int, seed: int = None) -> np.ndarray:",
        "starter_code": "import numpy as np\n\ndef generate_random_permutation(n: int, seed: int = None) -> np.ndarray:\n    # Your code here\n    # Generate a random permutation of indices [0, 1, ..., n-1]\n    # Use seed if provided for reproducibility\n    pass",
        "test_cases": [
          {
            "input": "generate_random_permutation(5, seed=42)",
            "expected": "np.array([3, 4, 0, 1, 2]) (deterministic with seed)",
            "explanation": "With seed=42, the permutation is reproducible and should be the same every time"
          },
          {
            "input": "len(generate_random_permutation(100)) == 100 and set(generate_random_permutation(100, seed=0)) == set(range(100))",
            "expected": "True",
            "explanation": "Permutation should contain all indices from 0 to n-1 exactly once"
          },
          {
            "input": "generate_random_permutation(1, seed=0)",
            "expected": "np.array([0])",
            "explanation": "Edge case: permutation of single element is always [0]"
          }
        ]
      },
      "common_mistakes": [
        "Using np.random.randint() without setting the seed through np.random.seed() or using a Generator",
        "Implementing a biased shuffle (e.g., swapping each element with a random position instead of only forward positions)",
        "Not ensuring each index appears exactly once in the output",
        "Forgetting to handle the seed parameter for reproducibility"
      ],
      "hint": "NumPy provides np.random.permutation() which implements Fisher-Yates. You can also use np.random.Generator with a seed for modern, thread-safe random number generation.",
      "references": [
        "Fisher-Yates shuffle algorithm",
        "Knuth shuffle",
        "Numpy random number generation",
        "Pseudorandom number generators"
      ]
    },
    {
      "step": 3,
      "title": "Maintaining Correspondence Between Paired Arrays",
      "relation_to_problem": "In supervised learning, features X and labels y must remain synchronized during shuffling. This requires applying the same permutation to both arrays to preserve (feature, label) pairs.",
      "prerequisites": [
        "Array indexing",
        "Permutations",
        "Coordinate arrays"
      ],
      "learning_objectives": [
        "Understand the mathematical requirement for maintaining paired data",
        "Learn how to apply identical transformations to multiple arrays",
        "Implement synchronized array operations"
      ],
      "math_content": {
        "definition": "A **paired dataset** is a tuple $(X, y)$ where $X \\in \\mathbb{R}^{n \\times d}$ represents $n$ samples with $d$ features, and $y \\in \\mathbb{R}^n$ (or $\\mathbb{R}^{n \\times k}$) represents corresponding labels. The **correspondence relation** is $C = \\{(X_i, y_i) : i \\in \\{0, 1, \\ldots, n-1\\}\\}$, representing the pairing between sample $i$'s features and label.",
        "notation": "$X_i$ = feature vector for sample $i$ (row $i$ of $X$)\n$y_i$ = label for sample $i$ (element $i$ of $y$)\n$(X, y) \\xrightarrow{\\sigma} (X', y')$ = applying permutation $\\sigma$ to paired dataset\n$C$ = correspondence relation (set of paired tuples)",
        "theorem": "**Theorem (Correspondence Preservation):** Let $(X, y)$ be a paired dataset and $\\sigma \\in S_n$ be a permutation. Applying $\\sigma$ independently to both $X$ and $y$ preserves correspondence if and only if:\n$$X'_i = X_{\\sigma(i)} \\text{ and } y'_i = y_{\\sigma(i)} \\text{ for all } i \\in \\{0, 1, \\ldots, n-1\\}$$\nThis ensures $C' = \\{(X'_i, y'_i) : i \\in \\{0, \\ldots, n-1\\}\\} = \\{(X_{\\sigma(i)}, y_{\\sigma(i)}) : i \\in \\{0, \\ldots, n-1\\}\\}$ represents the same pairings, just reordered.",
        "proof_sketch": "The correspondence is preserved because $(X'_i, y'_i) = (X_{\\sigma(i)}, y_{\\sigma(i)})$, meaning the pair that was at position $\\sigma(i)$ is now at position $i$. Since $\\sigma$ is a bijection, every original pair appears exactly once in the shuffled dataset, maintaining the one-to-one relationship between features and labels.",
        "examples": [
          "Original: $X = \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ 5 & 6 \\end{bmatrix}, y = \\begin{bmatrix} 10 \\\\ 20 \\\\ 30 \\end{bmatrix}$. Pairs: $\\{([1,2], 10), ([3,4], 20), ([5,6], 30)\\}$. After permutation $\\sigma = [2, 0, 1]$: $X' = \\begin{bmatrix} 5 & 6 \\\\ 1 & 2 \\\\ 3 & 4 \\end{bmatrix}, y' = \\begin{bmatrix} 30 \\\\ 10 \\\\ 20 \\end{bmatrix}$. Pairs preserved: $\\{([5,6], 30), ([1,2], 10), ([3,4], 20)\\}$.",
          "Incorrect shuffle (different permutations): Apply $\\sigma_1 = [1, 0, 2]$ to $X$ and $\\sigma_2 = [2, 1, 0]$ to $y$ would break correspondence, creating invalid pairs."
        ]
      },
      "key_formulas": [
        {
          "name": "Synchronized Permutation",
          "latex": "$X' = X[\\sigma], \\quad y' = y[\\sigma]$ where $\\sigma$ is the same for both",
          "description": "Apply the identical permutation to both arrays to maintain pairing"
        },
        {
          "name": "Correspondence Invariant",
          "latex": "$\\forall i: (X'_i, y'_i) \\in C \\Leftrightarrow (X_i, y_i) \\in C_{\\text{original}}$",
          "description": "The set of pairs remains the same, only their order changes"
        }
      ],
      "exercise": {
        "description": "Implement a function that takes two arrays (features and labels) and a permutation, then returns both arrays reordered according to the same permutation. This ensures the pairing between features and labels is maintained.",
        "function_signature": "def apply_permutation_to_pair(X: np.ndarray, y: np.ndarray, permutation: np.ndarray) -> tuple:",
        "starter_code": "import numpy as np\n\ndef apply_permutation_to_pair(X: np.ndarray, y: np.ndarray, permutation: np.ndarray) -> tuple:\n    # Your code here\n    # Apply the same permutation to both X and y\n    # Return tuple (X_shuffled, y_shuffled)\n    pass",
        "test_cases": [
          {
            "input": "apply_permutation_to_pair(np.array([[1, 2], [3, 4], [5, 6]]), np.array([10, 20, 30]), np.array([2, 0, 1]))",
            "expected": "(np.array([[5, 6], [1, 2], [3, 4]]), np.array([30, 10, 20]))",
            "explanation": "The pair ([5,6], 30) moves to index 0, ([1,2], 10) to index 1, ([3,4], 20) to index 2 - correspondence maintained"
          },
          {
            "input": "apply_permutation_to_pair(np.array([[1], [2]]), np.array([100, 200]), np.array([1, 0]))",
            "expected": "(np.array([[2], [1]]), np.array([200, 100]))",
            "explanation": "Simple swap: pairs flip positions but remain paired correctly"
          },
          {
            "input": "X, y = apply_permutation_to_pair(np.array([[1, 2, 3]]), np.array([99]), np.array([0])); (X[0], y[0])",
            "expected": "(np.array([1, 2, 3]), 99)",
            "explanation": "Single sample remains paired after identity permutation"
          }
        ]
      },
      "common_mistakes": [
        "Applying different permutations to X and y, breaking the correspondence",
        "Permuting columns instead of rows in X (should permute samples, not features)",
        "Not verifying that X and y have compatible first dimensions (same number of samples)",
        "Returning modified arrays instead of new arrays"
      ],
      "hint": "Use the same index array for both X and y: X[permutation] and y[permutation].",
      "references": [
        "Paired data in statistics",
        "Numpy array indexing",
        "Data integrity in machine learning"
      ]
    },
    {
      "step": 4,
      "title": "Random Seeds and Reproducibility in Stochastic Algorithms",
      "relation_to_problem": "Machine learning experiments must be reproducible. Using random seeds ensures that the same shuffle permutation is generated across different runs, enabling debugging and verification of results.",
      "prerequisites": [
        "Pseudorandom number generation",
        "Random permutations",
        "Algorithm determinism"
      ],
      "learning_objectives": [
        "Understand pseudorandom number generators (PRNGs) and their deterministic nature",
        "Learn how seeds control randomness for reproducibility",
        "Implement seeded random operations correctly"
      ],
      "math_content": {
        "definition": "A **pseudorandom number generator (PRNG)** is a deterministic algorithm that produces a sequence of numbers $\\{x_1, x_2, x_3, \\ldots\\}$ that approximates a random sequence. It is initialized with a **seed** $s \\in \\mathbb{Z}$, and the sequence is a deterministic function of the seed: $x_i = f_i(s)$. Given the same seed, the PRNG produces the same sequence.",
        "notation": "$s$ = seed value (initial state)\n$f_i(s)$ = $i$-th pseudorandom number generated from seed $s$\n$\\mathcal{G}(s)$ = PRNG initialized with seed $s$\n$U[a, b]$ = uniform distribution over interval $[a, b]$",
        "theorem": "**Theorem (Reproducibility):** Let $\\mathcal{G}(s)$ be a PRNG with seed $s$. If two independent computations both initialize $\\mathcal{G}$ with the same seed $s$ and make the same sequence of random number requests, they will produce identical outputs.\n\n**Corollary:** For dataset shuffling, if the same seed is used to initialize the PRNG before generating a permutation, the same permutation will be produced, ensuring reproducible shuffles.",
        "proof_sketch": "PRNGs are deterministic state machines. The internal state after $k$ random number generations is a function $g_k(s)$ of the seed alone (assuming no other sources of randomness). Therefore, the $k$-th output depends only on $s$ and the sequence of prior operations. With identical seeds and operation sequences, the states and outputs are identical.",
        "examples": [
          "NumPy example: `rng = np.random.default_rng(42)` creates a generator with seed 42. Calling `rng.permutation(5)` always yields the same permutation: `[2, 4, 0, 3, 1]`. Using seed 42 again produces the same result.",
          "Without seed: `rng = np.random.default_rng()` uses system entropy (e.g., current time), producing different results each run: `[1, 3, 0, 2, 4]` first run, `[4, 2, 1, 0, 3]` second run."
        ]
      },
      "key_formulas": [
        {
          "name": "Seeded Generator Initialization",
          "latex": "$\\mathcal{G}(s) \\rightarrow x_1, x_2, \\ldots$ where each $x_i$ depends deterministically on $s$",
          "description": "Initialize generator with seed to produce reproducible sequence"
        },
        {
          "name": "Conditional Seed Usage",
          "latex": "$\\text{seed} = \\begin{cases} s & \\text{if reproducibility required} \\\\ \\text{None} & \\text{if true randomness desired} \\end{cases}$",
          "description": "Use explicit seed for testing/debugging, None for production randomness"
        }
      ],
      "exercise": {
        "description": "Implement a function that generates a random permutation with optional seed parameter. When a seed is provided, the function should produce reproducible results. When no seed is provided (None), it should produce different results each time.",
        "function_signature": "def seeded_permutation(n: int, seed: int = None) -> np.ndarray:",
        "starter_code": "import numpy as np\n\ndef seeded_permutation(n: int, seed: int = None) -> np.ndarray:\n    # Your code here\n    # If seed is provided, use it to ensure reproducibility\n    # If seed is None, generate a random permutation without fixed seed\n    pass",
        "test_cases": [
          {
            "input": "seeded_permutation(4, seed=42) == seeded_permutation(4, seed=42)",
            "expected": "True (arrays are equal)",
            "explanation": "With the same seed, the function produces identical permutations - this is reproducibility"
          },
          {
            "input": "seeded_permutation(10, seed=0)",
            "expected": "np.array([7, 3, 5, 9, 1, 6, 4, 0, 2, 8]) (specific to seed 0 and implementation)",
            "explanation": "A specific seed produces a specific, reproducible permutation"
          },
          {
            "input": "perm1 = seeded_permutation(100); perm2 = seeded_permutation(100); np.array_equal(perm1, perm2)",
            "expected": "False (very likely, with probability ≈ 1 - 1/100!)",
            "explanation": "Without a seed, successive calls produce different random permutations"
          },
          {
            "input": "all(i in seeded_permutation(20, seed=5) for i in range(20))",
            "expected": "True",
            "explanation": "Regardless of seed, permutation must contain all indices 0 to n-1"
          }
        ]
      },
      "common_mistakes": [
        "Using deprecated np.random.seed() instead of the modern Generator approach (np.random.default_rng)",
        "Setting the global random seed, which affects other parts of the program (not thread-safe)",
        "Forgetting to handle the seed=None case (should use system entropy)",
        "Not understanding that 'random' with a seed is actually deterministic"
      ],
      "hint": "Use np.random.default_rng(seed) to create a Generator object, then call its permutation() method. When seed is None, default_rng() automatically uses system entropy.",
      "references": [
        "Mersenne Twister algorithm",
        "PCG family of PRNGs",
        "NumPy random number generation",
        "Reproducible research in machine learning"
      ]
    },
    {
      "step": 5,
      "title": "Statistical Properties of Shuffled Training Data",
      "relation_to_problem": "Understanding why we shuffle datasets requires knowledge of how random ordering affects learning algorithms. Shuffling prevents order-based bias and improves convergence properties of stochastic optimization.",
      "prerequisites": [
        "Probability distributions",
        "Expected value",
        "Stochastic gradient descent basics"
      ],
      "learning_objectives": [
        "Understand the statistical motivation for dataset shuffling",
        "Learn how shuffling affects bias and variance in gradient estimates",
        "Recognize the connection between shuffling and i.i.d. sampling assumptions"
      ],
      "math_content": {
        "definition": "In supervised learning, we assume samples $(x_i, y_i)$ are **independently and identically distributed (i.i.d.)** from some joint distribution $P(X, Y)$. However, data collection often introduces **ordering bias** where consecutive samples are correlated. **Random shuffling** approximates i.i.d. sampling by decorrelating the presentation order.\n\nFormally, let $D = \\{(x_1, y_1), \\ldots, (x_n, y_n)\\}$ be the dataset. A **random shuffle** produces a permuted dataset $D_{\\sigma} = \\{(x_{\\sigma(1)}, y_{\\sigma(1)}), \\ldots, (x_{\\sigma(n)}, y_{\\sigma(n)})\\}$ where $\\sigma \\sim \\text{Uniform}(S_n)$.",
        "notation": "$D$ = original dataset\n$D_{\\sigma}$ = shuffled dataset under permutation $\\sigma$\n$\\mathbb{E}_{\\sigma}[\\cdot]$ = expectation over random shuffles\n$\\text{Cov}(X_i, X_j)$ = covariance between samples $i$ and $j$\n$\\nabla L(\\theta; x_i, y_i)$ = gradient of loss for sample $i$",
        "theorem": "**Theorem (Shuffle Invariance of Empirical Risk):** Let $L(\\theta; D)$ be an empirical risk function. For any permutation $\\sigma$, we have:\n$$L(\\theta; D) = L(\\theta; D_{\\sigma})$$\nThis holds because the empirical risk is typically a sum or average over samples: $L(\\theta; D) = \\frac{1}{n}\\sum_{i=1}^n \\ell(\\theta; x_i, y_i)$, which is order-invariant.\n\n**Theorem (Reduced Gradient Correlation):** For stochastic gradient descent with sequential mini-batches, shuffling reduces the autocorrelation between consecutive gradient estimates. If samples are ordered by a confounding variable (e.g., time, class label), consecutive gradients $\\nabla L(\\theta; x_i, y_i)$ and $\\nabla L(\\theta; x_{i+1}, y_{i+1})$ may be highly correlated. Shuffling makes the expected correlation:\n$$\\mathbb{E}_{\\sigma}[\\text{Corr}(\\nabla L(\\theta; x_{\\sigma(i)}, y_{\\sigma(i)}), \\nabla L(\\theta; x_{\\sigma(i+1)}, y_{\\sigma(i+1)}))] \\approx 0$$",
        "proof_sketch": "The empirical risk is a symmetric function of the dataset samples, so permutation doesn't change the value. For gradient correlation, when samples are randomly ordered, the probability that consecutive samples share correlation-inducing properties decreases from potentially 1 (if ordered) to approximately $\\frac{k}{n}$ where $k$ is the number of samples with similar properties. As $n$ grows, this approaches 0.",
        "examples": [
          "Without shuffling: A dataset of medical records ordered by hospital visit date may show temporal trends (e.g., treatment protocols changing over time). Training on sequential batches would first learn early protocols, then unlearn and relearn later ones, oscillating and converging slowly.",
          "With shuffling: The same dataset, shuffled, presents mixed temporal data in each batch. Gradients average across time periods, leading to more stable convergence toward a time-averaged solution.",
          "Class-ordered data: If dataset is ordered as [class 0 samples, class 1 samples, class 2 samples], early training batches only see class 0, creating extreme overfitting to that class before seeing others. Shuffling mixes classes in each batch."
        ]
      },
      "key_formulas": [
        {
          "name": "Empirical Risk",
          "latex": "$L(\\theta; D) = \\frac{1}{n}\\sum_{i=1}^n \\ell(\\theta; x_i, y_i)$",
          "description": "Order-invariant objective function for training"
        },
        {
          "name": "Expected Gradient Under Shuffling",
          "latex": "$\\mathbb{E}_{\\sigma}[\\nabla L(\\theta; D_{\\sigma})] = \\nabla L(\\theta; D)$",
          "description": "Shuffling doesn't bias the gradient, only affects variance and correlation"
        },
        {
          "name": "Mini-batch Gradient Variance Reduction",
          "latex": "$\\text{Var}(\\frac{1}{b}\\sum_{i=1}^b g_i) = \\frac{\\sigma^2}{b}$ when $g_i$ are i.i.d.",
          "description": "Variance decreases with batch size when gradients are decorrelated"
        }
      ],
      "exercise": {
        "description": "Implement a function that checks whether two arrays have the same elements (regardless of order). This is crucial for verifying that shuffling preserves the dataset content - only the order changes, not the data itself.",
        "function_signature": "def same_elements(arr1: np.ndarray, arr2: np.ndarray) -> bool:",
        "starter_code": "import numpy as np\n\ndef same_elements(arr1: np.ndarray, arr2: np.ndarray) -> bool:\n    # Your code here\n    # Check if arr1 and arr2 contain the same elements\n    # Return True if they're permutations of each other, False otherwise\n    pass",
        "test_cases": [
          {
            "input": "same_elements(np.array([1, 2, 3, 4]), np.array([4, 2, 1, 3]))",
            "expected": "True",
            "explanation": "Both arrays contain {1, 2, 3, 4}, just in different order - this is what shuffling should do"
          },
          {
            "input": "same_elements(np.array([1, 2, 3]), np.array([1, 2, 4]))",
            "expected": "False",
            "explanation": "Different elements: 3 vs 4 means these are not permutations of each other"
          },
          {
            "input": "same_elements(np.array([[1, 2], [3, 4]]), np.array([[3, 4], [1, 2]]))",
            "expected": "True",
            "explanation": "Works with 2D arrays: rows are reordered but content is preserved"
          },
          {
            "input": "same_elements(np.array([5, 5, 3]), np.array([5, 3, 5]))",
            "expected": "True",
            "explanation": "Handles duplicates correctly: both have two 5s and one 3"
          }
        ]
      },
      "common_mistakes": [
        "Using == to compare arrays directly (compares element-wise, not set equality)",
        "Not handling multi-dimensional arrays correctly",
        "Ignoring duplicate elements (using set() doesn't preserve counts)",
        "Not considering that rows in 2D arrays need to be compared as units"
      ],
      "hint": "For 1D arrays, you can sort both and compare. For 2D arrays, consider sorting rows lexicographically. NumPy's array_equal() combined with sorting can help.",
      "references": [
        "Stochastic gradient descent convergence theory",
        "Mini-batch training",
        "i.i.d. assumption in machine learning",
        "Bias-variance tradeoff"
      ]
    },
    {
      "step": 6,
      "title": "Complete Dataset Shuffling: Synthesis and Implementation",
      "relation_to_problem": "Combine all previous concepts to implement a complete dataset shuffling function that generates random permutations with optional seeds and applies them synchronously to paired feature-label arrays.",
      "prerequisites": [
        "All previous sub-quests"
      ],
      "learning_objectives": [
        "Synthesize permutation generation, seed management, and paired array operations",
        "Implement robust dataset shuffling with proper error handling",
        "Verify correctness through correspondence preservation and element invariance"
      ],
      "math_content": {
        "definition": "The **dataset shuffling operation** is a function $\\text{Shuffle}: \\mathbb{R}^{n \\times d} \\times \\mathbb{R}^n \\times (\\mathbb{Z} \\cup \\{\\text{None}\\}) \\to \\mathbb{R}^{n \\times d} \\times \\mathbb{R}^n$ defined as:\n$$\\text{Shuffle}(X, y, s) = (X[\\sigma_s], y[\\sigma_s])$$\nwhere $\\sigma_s \\sim \\text{Uniform}(S_n)$ is a random permutation generated with seed $s$ (if $s \\neq \\text{None}$) or from system entropy (if $s = \\text{None}$).",
        "notation": "$\\text{Shuffle}(X, y, s)$ = shuffling function with optional seed\n$X[\\sigma]$ = array $X$ reordered by permutation $\\sigma$\n$s \\in \\mathbb{Z} \\cup \\{\\text{None}\\}$ = optional seed parameter",
        "theorem": "**Theorem (Correctness of Dataset Shuffling):** A correct implementation of $\\text{Shuffle}(X, y, s)$ satisfies:\n1. **Correspondence preservation:** $(X'_i, y'_i)$ corresponds to some original pair $(X_j, y_j)$\n2. **Bijection:** Every original pair appears exactly once in output\n3. **Reproducibility:** For any fixed seed $s \\neq \\text{None}$, $\\text{Shuffle}(X, y, s)$ is deterministic\n4. **Uniformity:** When $s = \\text{None}$, all $n!$ orderings are equally likely\n5. **Content preservation:** $\\text{multiset}(X') = \\text{multiset}(X)$ and $\\text{multiset}(y') = \\text{multiset}(y)$",
        "proof_sketch": "Properties 1 and 2 follow from using the same permutation $\\sigma$ for both arrays. Property 3 follows from PRNG determinism. Property 4 follows from using Fisher-Yates algorithm. Property 5 follows from permutations being bijections that only reorder elements without addition or deletion.",
        "examples": [
          "Complete example: $X = \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ 5 & 6 \\end{bmatrix}, y = [10, 20, 30]$. With seed producing $\\sigma = [2, 0, 1]$: $X' = \\begin{bmatrix} 5 & 6 \\\\ 1 & 2 \\\\ 3 & 4 \\end{bmatrix}, y' = [30, 10, 20]$. Pairs: $(5,6)\\to 30$, $(1,2)\\to 10$, $(3,4)\\to 20$ ✓",
          "Validation: After shuffling, verify sorted $X'$ equals sorted $X$ (element-wise), and sorted $y'$ equals sorted $y$. This confirms content preservation.",
          "Reproducibility test: $\\text{Shuffle}(X, y, 42) = \\text{Shuffle}(X, y, 42)$ for any $X, y$ ✓"
        ]
      },
      "key_formulas": [
        {
          "name": "Complete Shuffling Algorithm",
          "latex": "$\\begin{align*}1. &\\ \\sigma \\gets \\text{GeneratePermutation}(n, s) \\\\ 2. &\\ X' \\gets X[\\sigma] \\\\ 3. &\\ y' \\gets y[\\sigma] \\\\ 4. &\\ \\text{return } (X', y')\\end{align*}$",
          "description": "Four-step algorithm combining all previous concepts"
        },
        {
          "name": "Correctness Verification",
          "latex": "$\\forall i \\in \\{0, \\ldots, n-1\\}: X'_i = X_{\\sigma(i)} \\land y'_i = y_{\\sigma(i)}$",
          "description": "Mathematical property to verify in testing"
        }
      ],
      "exercise": {
        "description": "Implement a complete dataset shuffling function that combines random permutation generation with synchronized array reordering. The function must handle optional seeds for reproducibility and maintain correspondence between features and labels. This is a simplified version of the main problem - your implementation should handle the core logic without necessarily matching the exact output format of the main problem.",
        "function_signature": "def shuffle_dataset(X: np.ndarray, y: np.ndarray, seed: int = None) -> tuple:",
        "starter_code": "import numpy as np\n\ndef shuffle_dataset(X: np.ndarray, y: np.ndarray, seed: int = None) -> tuple:\n    # Your code here\n    # 1. Generate a random permutation (use seed if provided)\n    # 2. Apply it to both X and y\n    # 3. Return the shuffled pair (X_shuffled, y_shuffled)\n    pass",
        "test_cases": [
          {
            "input": "shuffle_dataset(np.array([[1, 2], [3, 4], [5, 6]]), np.array([10, 20, 30]), seed=42)",
            "expected": "Reproducible output where pairs are preserved (exact output depends on numpy version)",
            "explanation": "With seed=42, output should be deterministic and maintain (row, label) correspondence"
          },
          {
            "input": "X, y = np.array([[1], [2], [3]]), np.array([100, 200, 300]); X_s, y_s = shuffle_dataset(X, y, seed=0); all((X_s[i], y_s[i]) in [([1], 100), ([2], 200), ([3], 300)] for i in range(3))",
            "expected": "True",
            "explanation": "All output pairs must be from the original set of pairs, verifying correspondence preservation"
          },
          {
            "input": "X = np.array([[1, 2], [3, 4]]); y = np.array([10, 20]); X_s1, y_s1 = shuffle_dataset(X, y, seed=5); X_s2, y_s2 = shuffle_dataset(X, y, seed=5); (np.array_equal(X_s1, X_s2) and np.array_equal(y_s1, y_s2))",
            "expected": "True",
            "explanation": "Same seed produces identical shuffles - reproducibility requirement"
          },
          {
            "input": "X, y = shuffle_dataset(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), np.array([1, 2, 3]), seed=100); (X.shape == (3, 3) and y.shape == (3,))",
            "expected": "True",
            "explanation": "Shuffling preserves array shapes and dimensions"
          }
        ]
      },
      "common_mistakes": [
        "Creating the permutation without considering the seed parameter",
        "Generating different permutations for X and y (breaks correspondence)",
        "Modifying input arrays instead of creating new shuffled copies",
        "Not validating that X and y have compatible dimensions (X.shape[0] == y.shape[0])",
        "Using deprecated numpy.random functions instead of the Generator API"
      ],
      "hint": "Use np.random.default_rng(seed) to create a generator, then generator.permutation(n) to get the permutation indices. Apply these indices to both X and y using fancy indexing.",
      "references": [
        "NumPy array manipulation",
        "Scikit-learn shuffle utilities",
        "Data preprocessing pipelines",
        "Machine learning best practices"
      ]
    }
  ]
}